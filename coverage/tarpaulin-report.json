{"files":[{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","amm_bench.rs"],"content":"fn main() {\n    println!(\"AMM benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","concurrency_bench.rs"],"content":"fn main() {\n    println!(\"Concurrency benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","ingestion_bench.rs"],"content":"fn main() {\n    println!(\"Ingestion benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","orderbook_bench.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse quant_trading_system::*;\nuse rust_decimal_macros::dec;\nuse std::hint::black_box;\n\nfn benchmark_orderbook_operations(c: &mut Criterion) {\n    let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Setup initial state\n    let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n    for i in 0..1000 {\n        let price = dec!(2000.0) + rust_decimal::Decimal::from(i);\n        snapshot.bids.insert(Price(price), Quantity(dec!(1.0)));\n        snapshot\n            .asks\n            .insert(Price(price + dec!(1.0)), Quantity(dec!(1.0)));\n    }\n    book.apply_snapshot(snapshot).unwrap();\n\n    c.bench_function(\"orderbook_best_bid\", |b| {\n        b.iter(|| black_box(book.best_bid()))\n    });\n\n    c.bench_function(\"orderbook_best_ask\", |b| {\n        b.iter(|| black_box(book.best_ask()))\n    });\n\n    c.bench_function(\"orderbook_mid_price\", |b| {\n        b.iter(|| black_box(book.mid_price()))\n    });\n}\n\ncriterion_group!(benches, benchmark_orderbook_operations);\ncriterion_main!(benches);\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":11,"address":[],"length":0,"stats":{"Line":2001}},{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":5}}],"covered":11,"coverable":11},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","arbitrage_bot.rs"],"content":"fn main() {\n    println!(\"Arbitrage bot example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","basic_usage.rs"],"content":"fn main() {\n    println!(\"Basic usage example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","data_replay.rs"],"content":"fn main() {\n    println!(\"Data replay example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","market_maker.rs"],"content":"fn main() {\n    println!(\"Market maker example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","amm_pool.rs"],"content":"use crate::domain::{events::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// AMM pool types supported by the system\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum AMMPoolType {\n    /// Uniswap V2 style constant product (x * y = k)\n    ConstantProduct,\n    /// Uniswap V3 style concentrated liquidity\n    ConcentratedLiquidity,\n}\n\n/// Core AMM pool implementation supporting both V2 and V3 mechanics\n#[derive(Debug)]\npub struct AMMPool {\n    address: PoolAddress,\n    pool_type: AMMPoolType,\n    /// Token reserves (for V2) or virtual reserves (for V3)\n    reserves: TokenReserves,\n    /// Square root price for V3 pools\n    sqrt_price: Option<SqrtPriceX96>,\n    /// Fee tier in basis points\n    fee_tier: FeeTier,\n    /// Last update timestamp\n    last_update: Timestamp,\n}\n\nimpl AMMPool {\n    /// Creates a new Uniswap V2 style AMM pool\n    pub fn new_v2(address: PoolAddress, reserves: TokenReserves, fee_tier: FeeTier) -> Self {\n        Self {\n            address,\n            pool_type: AMMPoolType::ConstantProduct,\n            reserves,\n            sqrt_price: None,\n            fee_tier,\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Creates a new Uniswap V3 style AMM pool with sqrt price\n    pub fn new_v3(\n        address: PoolAddress,\n        reserves: TokenReserves,\n        sqrt_price: SqrtPriceX96,\n        fee_tier: FeeTier,\n    ) -> Self {\n        Self {\n            address,\n            pool_type: AMMPoolType::ConcentratedLiquidity,\n            reserves,\n            sqrt_price: Some(sqrt_price),\n            fee_tier,\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Update pool state\n    pub fn update_state(&mut self, update: AMMPoolUpdate) -> TradingResult<()> {\n        self.reserves = update.reserves;\n        self.sqrt_price = update.sqrt_price;\n        self.fee_tier = update.fee_tier;\n        self.last_update = update.timestamp;\n        Ok(())\n    }\n\n    /// Get current implied mid price\n    pub fn implied_mid(&self) -> Price {\n        match self.sqrt_price {\n            Some(sqrt_price) => sqrt_price.to_price(),\n            None => self.implied_mid_from_reserves(),\n        }\n    }\n\n    /// Calculate implied mid price from reserves (V2 style)\n    pub fn implied_mid_from_reserves(&self) -> Price {\n        if self.reserves.token0.is_zero() {\n            return Price::zero();\n        }\n        Price(self.reserves.token1 / self.reserves.token0)\n    }\n\n    /// Calculate price impact for a given input amount\n    /// Returns (output_amount, price_impact_percent, effective_price)\n    pub fn calculate_price_impact(\n        &self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -> TradingResult<PriceImpactResult> {\n        match self.pool_type {\n            AMMPoolType::ConstantProduct => {\n                self.calculate_v2_price_impact(input_token, input_amount)\n            }\n            AMMPoolType::ConcentratedLiquidity => {\n                self.calculate_v3_price_impact(input_token, input_amount)\n            }\n        }\n    }\n\n    /// Calculate V2 style price impact using constant product formula\n    fn calculate_v2_price_impact(\n        &self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -> TradingResult<PriceImpactResult> {\n        let (reserve_in, reserve_out) = match input_token {\n            TokenIndex::Token0 => (self.reserves.token0, self.reserves.token1),\n            TokenIndex::Token1 => (self.reserves.token1, self.reserves.token0),\n        };\n\n        if reserve_in.is_zero() || reserve_out.is_zero() {\n            return Err(TradingError::InsufficientLiquidity(input_amount));\n        }\n\n        // Apply fee\n        let fee_decimal = self.fee_tier.to_decimal();\n        let input_after_fee = input_amount * (Decimal::ONE - fee_decimal);\n\n        // Constant product formula: (x + dx) * (y - dy) = x * y\n        // Solving for dy: dy = (y * dx) / (x + dx)\n        let output_amount = (reserve_out * input_after_fee) / (reserve_in + input_after_fee);\n\n        if output_amount >= reserve_out {\n            return Err(TradingError::InsufficientLiquidity(input_amount));\n        }\n\n        // Calculate price impact\n        let initial_price = reserve_out / reserve_in;\n        let effective_price = output_amount / input_amount;\n        let price_impact =\n            ((initial_price - effective_price) / initial_price).abs() * Decimal::from(100);\n\n        Ok(PriceImpactResult {\n            output_amount,\n            price_impact_percent: price_impact,\n            effective_price: Price(effective_price),\n            fee_amount: input_amount * fee_decimal,\n        })\n    }\n\n    /// Calculate V3 style price impact (simplified - would need tick math in production)\n    fn calculate_v3_price_impact(\n        &self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -> TradingResult<PriceImpactResult> {\n        // For V3, we'll use a simplified approach similar to V2\n        // In production, this would involve complex tick math and liquidity distribution\n        self.calculate_v2_price_impact(input_token, input_amount)\n    }\n\n    /// Get pool address\n    pub fn address(&self) -> &PoolAddress {\n        &self.address\n    }\n\n    /// Get pool type\n    pub fn pool_type(&self) -> &AMMPoolType {\n        &self.pool_type\n    }\n\n    /// Get current reserves\n    pub fn get_reserves(&self) -> TokenReserves {\n        self.reserves.clone()\n    }\n\n    /// Get sqrt price (if available)\n    pub fn sqrt_price(&self) -> Option<SqrtPriceX96> {\n        self.sqrt_price\n    }\n\n    /// Get fee tier\n    pub fn get_fee_tier(&self) -> FeeTier {\n        self.fee_tier\n    }\n\n    /// Get last update timestamp\n    pub fn last_update(&self) -> Timestamp {\n        self.last_update\n    }\n\n    /// Get pool address\n    pub fn get_address(&self) -> PoolAddress {\n        self.address.clone()\n    }\n\n    /// Get current sqrt price (V3 only)\n    pub fn get_sqrt_price(&self) -> Option<SqrtPriceX96> {\n        self.sqrt_price\n    }\n}\n\n/// Token index for AMM operations\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum TokenIndex {\n    /// First token in the pair\n    Token0,\n    /// Second token in the pair\n    Token1,\n}\n\n/// Result of a price impact calculation\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceImpactResult {\n    /// Amount of output tokens received\n    pub output_amount: Decimal,\n    /// Price impact as a percentage\n    pub price_impact_percent: Decimal,\n    /// Effective price after impact\n    pub effective_price: Price,\n    /// Fee amount charged\n    pub fee_amount: Decimal,\n}\n\n/// Thread-safe wrapper around AMMPool\n#[derive(Debug, Clone)]\npub struct ThreadSafeAMMPool {\n    inner: Arc<RwLock<AMMPool>>,\n}\n\nimpl ThreadSafeAMMPool {\n    /// Creates a new thread-safe Uniswap V2 style AMM pool\n    pub fn new_v2(address: PoolAddress, reserves: TokenReserves, fee_tier: FeeTier) -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(AMMPool::new_v2(address, reserves, fee_tier))),\n        }\n    }\n\n    /// Creates a new thread-safe Uniswap V3 style AMM pool with sqrt price\n    pub fn new_v3(\n        address: PoolAddress,\n        reserves: TokenReserves,\n        sqrt_price: SqrtPriceX96,\n        fee_tier: FeeTier,\n    ) -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(AMMPool::new_v3(\n                address, reserves, sqrt_price, fee_tier,\n            ))),\n        }\n    }\n\n    /// Update pool state with write lock\n    pub fn update_state(&self, update: AMMPoolUpdate) -> TradingResult<()> {\n        let mut pool = self.inner.write().expect(\"Failed to acquire write lock\");\n        pool.update_state(update)\n    }\n\n    /// Get implied mid price with read lock\n    pub fn implied_mid(&self) -> Price {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .implied_mid()\n    }\n\n    /// Calculate price impact for a given trade\n    pub fn calculate_price_impact(\n        &self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -> TradingResult<PriceImpactResult> {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .calculate_price_impact(input_token, input_amount)\n    }\n\n    /// Get pool address with read lock\n    pub fn get_address(&self) -> PoolAddress {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .address\n            .clone()\n    }\n\n    /// Get pool type with read lock\n    pub fn pool_type(&self) -> AMMPoolType {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .pool_type()\n            .clone()\n    }\n\n    /// Get reserves with read lock\n    pub fn get_reserves(&self) -> TokenReserves {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .reserves\n            .clone()\n    }\n\n    /// Get sqrt price with read lock\n    pub fn get_sqrt_price(&self) -> Option<SqrtPriceX96> {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .sqrt_price\n    }\n\n    /// Get fee tier with read lock\n    pub fn get_fee_tier(&self) -> FeeTier {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .fee_tier\n    }\n\n    /// Get last update timestamp with read lock\n    pub fn last_update(&self) -> Timestamp {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_update()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_v2_pool_creation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        assert_eq!(pool.pool_type(), &AMMPoolType::ConstantProduct);\n        assert_eq!(pool.implied_mid_from_reserves(), Price(dec!(2.0)));\n    }\n\n    #[test]\n    fn test_v3_pool_creation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let sqrt_price = SqrtPriceX96(2u128.pow(96)); // sqrt(1) = 1\n        let pool = AMMPool::new_v3(\n            PoolAddress(\"0x456\".to_string()),\n            reserves,\n            sqrt_price,\n            FeeTier(30),\n        );\n\n        assert_eq!(pool.pool_type(), &AMMPoolType::ConcentratedLiquidity);\n        assert!(pool.sqrt_price().is_some());\n    }\n\n    #[test]\n    fn test_price_impact_calculation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(\n            PoolAddress(\"0x123\".to_string()),\n            reserves,\n            FeeTier(30), // 0.3%\n        );\n\n        // Test small trade (should have minimal impact)\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(10.0))\n            .unwrap();\n\n        // With 0.3% fee, input after fee = 10 * 0.997 = 9.97\n        // Output = (2000 * 9.97) / (1000 + 9.97) = 19.7406...\n        assert!(result.output_amount > dec!(19.7));\n        assert!(result.output_amount < dec!(19.8));\n        assert!(result.price_impact_percent > dec!(0.0)); // Should have some impact\n        assert_eq!(result.fee_amount, dec!(0.03)); // 0.3% of 10\n    }\n\n    #[test]\n    fn test_large_trade_price_impact() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Test large trade (should have significant impact)\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(100.0))\n            .unwrap();\n\n        // Large trades should have higher price impact\n        assert!(result.price_impact_percent > dec!(5.0)); // More than 5% impact\n    }\n\n    #[test]\n    fn test_insufficient_liquidity() {\n        let reserves = TokenReserves::new(dec!(100.0), dec!(200.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Try to trade more than available liquidity\n        let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(1000.0));\n\n        // For constant product AMM, very large trades are still possible but with extreme price impact\n        // Let's check that the result has very high price impact instead\n        if let Ok(impact) = result {\n            assert!(impact.price_impact_percent > dec!(50.0)); // Very high impact\n        } else {\n            // If it does error, that's also acceptable behavior\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_amm_pool() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool =\n            ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Test concurrent reads\n        let pool_clone = pool.clone();\n        let handle = std::thread::spawn(move || {\n            for _ in 0..100 {\n                let _ = pool_clone.implied_mid();\n                let _ = pool_clone.calculate_price_impact(TokenIndex::Token0, dec!(1.0));\n            }\n        });\n\n        // Concurrent reads from main thread\n        for _ in 0..100 {\n            let _ = pool.get_reserves();\n            let _ = pool.get_fee_tier();\n        }\n\n        handle.join().unwrap();\n\n        // Verify state is consistent\n        assert_eq!(pool.implied_mid(), Price(dec!(2.0)));\n    }\n\n    #[test]\n    fn test_pool_state_update() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool =\n            ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Update pool state\n        let new_reserves = TokenReserves::new(dec!(1100.0), dec!(1900.0));\n        let update =\n            AMMPoolUpdate::new(chrono::Utc::now(), new_reserves.clone(), None, FeeTier(25));\n\n        pool.update_state(update).unwrap();\n\n        // Verify state was updated\n        assert_eq!(pool.get_reserves(), new_reserves);\n        assert_eq!(pool.get_fee_tier(), FeeTier(25));\n\n        // Price should have changed\n        let new_price = dec!(1900.0) / dec!(1100.0);\n        assert_eq!(pool.implied_mid(), Price(new_price));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":32}},{"line":40,"address":[],"length":0,"stats":{"Line":32}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":228}},{"line":72,"address":[],"length":0,"stats":{"Line":228}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":224}},{"line":79,"address":[],"length":0,"stats":{"Line":226}},{"line":80,"address":[],"length":0,"stats":{"Line":452}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":208}},{"line":93,"address":[],"length":0,"stats":{"Line":208}},{"line":95,"address":[],"length":0,"stats":{"Line":208}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":208}},{"line":109,"address":[],"length":0,"stats":{"Line":624}},{"line":110,"address":[],"length":0,"stats":{"Line":208}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":624}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":24}},{"line":228,"address":[],"length":0,"stats":{"Line":120}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":8}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":228}},{"line":254,"address":[],"length":0,"stats":{"Line":456}},{"line":261,"address":[],"length":0,"stats":{"Line":202}},{"line":266,"address":[],"length":0,"stats":{"Line":606}},{"line":269,"address":[],"length":0,"stats":{"Line":404}},{"line":273,"address":[],"length":0,"stats":{"Line":16}},{"line":274,"address":[],"length":0,"stats":{"Line":32}},{"line":275,"address":[],"length":0,"stats":{"Line":32}},{"line":276,"address":[],"length":0,"stats":{"Line":16}},{"line":277,"address":[],"length":0,"stats":{"Line":16}},{"line":282,"address":[],"length":0,"stats":{"Line":8}},{"line":283,"address":[],"length":0,"stats":{"Line":16}},{"line":291,"address":[],"length":0,"stats":{"Line":216}},{"line":292,"address":[],"length":0,"stats":{"Line":432}},{"line":293,"address":[],"length":0,"stats":{"Line":432}},{"line":294,"address":[],"length":0,"stats":{"Line":216}},{"line":295,"address":[],"length":0,"stats":{"Line":216}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":206}},{"line":309,"address":[],"length":0,"stats":{"Line":412}},{"line":310,"address":[],"length":0,"stats":{"Line":412}},{"line":311,"address":[],"length":0,"stats":{"Line":206}},{"line":312,"address":[],"length":0,"stats":{"Line":206}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":8}}],"covered":61,"coverable":83},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","arbitrage.rs"],"content":"use crate::domain::{amm_pool::*, order_book::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Arbitrage opportunity between two venues\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct ArbitrageOpportunity {\n    /// Venue where the asset should be bought\n    pub buy_venue: Venue,\n    /// Venue where the asset should be sold\n    pub sell_venue: Venue,\n    /// Price to buy at\n    pub buy_price: Price,\n    /// Price to sell at\n    pub sell_price: Price,\n    /// Maximum quantity that can be traded\n    pub max_quantity: Quantity,\n    /// Profit percentage\n    pub profit_percent: Decimal,\n    /// Estimated profit amount\n    pub estimated_profit: Decimal,\n}\n\nimpl ArbitrageOpportunity {\n    /// Creates a new arbitrage opportunity\n    pub fn new(\n        buy_venue: Venue,\n        sell_venue: Venue,\n        buy_price: Price,\n        sell_price: Price,\n        max_quantity: Quantity,\n    ) -> Self {\n        let profit_per_unit = sell_price.0 - buy_price.0;\n        let estimated_profit = profit_per_unit * max_quantity.0;\n        let profit_percent = if !buy_price.is_zero() {\n            (profit_per_unit / buy_price.0) * Decimal::from(100)\n        } else {\n            Decimal::ZERO\n        };\n\n        Self {\n            buy_venue,\n            sell_venue,\n            buy_price,\n            sell_price,\n            max_quantity,\n            profit_percent,\n            estimated_profit,\n        }\n    }\n}\n\n/// Trading venue identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Venue {\n    /// Order book venue with symbol\n    OrderBook(Symbol),\n    /// AMM pool venue with address\n    AMM(PoolAddress),\n}\n\nimpl fmt::Display for Venue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Venue::OrderBook(symbol) => write!(f, \"OrderBook({})\", symbol),\n            Venue::AMM(address) => write!(f, \"AMM({})\", address),\n        }\n    }\n}\n\n/// Arbitrage detector with configurable profit thresholds\n#[derive(Debug)]\npub struct ArbitrageDetector {\n    /// Minimum profit percentage to consider an opportunity viable (in basis points)\n    min_profit_bps: u32,\n    /// Maximum slippage tolerance (in basis points)\n    max_slippage_bps: u32,\n    /// Minimum trade size to consider\n    min_trade_size: Decimal,\n}\n\nimpl ArbitrageDetector {\n    /// Create new arbitrage detector\n    /// min_profit_bps: minimum profit in basis points (e.g., 10 = 0.1%)\n    pub fn new(min_profit_bps: u32) -> Self {\n        Self {\n            min_profit_bps,\n            max_slippage_bps: 50,               // 0.5% default max slippage\n            min_trade_size: Decimal::from(100), // Default minimum trade size\n        }\n    }\n\n    /// Create detector with custom parameters\n    pub fn with_params(\n        min_profit_bps: u32,\n        max_slippage_bps: u32,\n        min_trade_size: Decimal,\n    ) -> Self {\n        Self {\n            min_profit_bps,\n            max_slippage_bps,\n            min_trade_size,\n        }\n    }\n\n    /// Check for arbitrage opportunities between order book and AMM pool\n    pub fn check_arbitrage(\n        &self,\n        order_book: &ThreadSafeOrderBook,\n        amm_pool: &ThreadSafeAMMPool,\n    ) -> Option<ArbitrageOpportunity> {\n        let ob_symbol = order_book.symbol();\n        let pool_address = amm_pool.get_address();\n\n        // Get order book prices\n        let ob_best_bid = order_book.best_bid()?;\n        let ob_best_ask = order_book.best_ask()?;\n\n        // Get AMM implied price\n        let amm_mid = amm_pool.implied_mid();\n\n        // Check both directions of arbitrage\n\n        // Direction 1: Buy from AMM, sell to order book\n        if let Some(opp1) = self.check_amm_to_orderbook(\n            amm_pool,\n            order_book,\n            amm_mid,\n            ob_best_bid,\n            &pool_address,\n            &ob_symbol,\n        ) {\n            return Some(opp1);\n        }\n\n        // Direction 2: Buy from order book, sell to AMM\n        if let Some(opp2) = self.check_orderbook_to_amm(\n            order_book,\n            amm_pool,\n            ob_best_ask,\n            amm_mid,\n            &ob_symbol,\n            &pool_address,\n        ) {\n            return Some(opp2);\n        }\n\n        None\n    }\n\n    /// Check arbitrage: buy from AMM, sell to order book\n    fn check_amm_to_orderbook(\n        &self,\n        amm_pool: &ThreadSafeAMMPool,\n        order_book: &ThreadSafeOrderBook,\n        amm_price: Price,\n        ob_best_bid: Price,\n        pool_address: &PoolAddress,\n        ob_symbol: &Symbol,\n    ) -> Option<ArbitrageOpportunity> {\n        // Check if order book bid is higher than AMM price (profitable to buy from AMM, sell to OB)\n        if ob_best_bid.0 <= amm_price.0 {\n            return None;\n        }\n\n        let profit_per_unit = ob_best_bid.0 - amm_price.0;\n        let profit_percent = (profit_per_unit / amm_price.0) * Decimal::from(10000); // Convert to basis points\n\n        if profit_percent < Decimal::from(self.min_profit_bps) {\n            return None;\n        }\n\n        // Calculate maximum tradeable quantity considering:\n        // 1. Order book liquidity at best bid\n        // 2. AMM price impact\n        let ob_liquidity = order_book.quantity_at_price(Side::Bid, ob_best_bid);\n        let max_amm_trade = self.calculate_max_amm_trade(amm_pool, amm_price);\n\n        let max_quantity = Quantity(ob_liquidity.0.min(max_amm_trade.0).max(self.min_trade_size));\n\n        if max_quantity.0 < self.min_trade_size {\n            return None;\n        }\n\n        Some(ArbitrageOpportunity::new(\n            Venue::AMM(pool_address.clone()),\n            Venue::OrderBook(ob_symbol.clone()),\n            amm_price,\n            ob_best_bid,\n            max_quantity,\n        ))\n    }\n\n    /// Check arbitrage: buy from order book, sell to AMM\n    fn check_orderbook_to_amm(\n        &self,\n        order_book: &ThreadSafeOrderBook,\n        amm_pool: &ThreadSafeAMMPool,\n        ob_best_ask: Price,\n        amm_price: Price,\n        ob_symbol: &Symbol,\n        pool_address: &PoolAddress,\n    ) -> Option<ArbitrageOpportunity> {\n        // Check if AMM price is higher than order book ask (profitable to buy from OB, sell to AMM)\n        if amm_price.0 <= ob_best_ask.0 {\n            return None;\n        }\n\n        let profit_per_unit = amm_price.0 - ob_best_ask.0;\n        let profit_percent = (profit_per_unit / ob_best_ask.0) * Decimal::from(10000); // Convert to basis points\n\n        if profit_percent < Decimal::from(self.min_profit_bps) {\n            return None;\n        }\n\n        // Calculate maximum tradeable quantity\n        let ob_liquidity = order_book.quantity_at_price(Side::Ask, ob_best_ask);\n        let max_amm_trade = self.calculate_max_amm_trade(amm_pool, amm_price);\n\n        let max_quantity = Quantity(ob_liquidity.0.min(max_amm_trade.0).max(self.min_trade_size));\n\n        if max_quantity.0 < self.min_trade_size {\n            return None;\n        }\n\n        Some(ArbitrageOpportunity::new(\n            Venue::OrderBook(ob_symbol.clone()),\n            Venue::AMM(pool_address.clone()),\n            ob_best_ask,\n            amm_price,\n            max_quantity,\n        ))\n    }\n\n    /// Calculate maximum trade size for AMM considering slippage tolerance\n    fn calculate_max_amm_trade(\n        &self,\n        amm_pool: &ThreadSafeAMMPool,\n        _current_price: Price,\n    ) -> Quantity {\n        let max_slippage_decimal = Decimal::from(self.max_slippage_bps) / Decimal::from(10000);\n        let reserves = amm_pool.get_reserves();\n\n        // For constant product AMM, calculate max trade size that keeps slippage under threshold\n        // This is a simplified calculation - in production would need more sophisticated modeling\n        let max_trade_estimate = reserves.token0 * max_slippage_decimal;\n\n        Quantity(max_trade_estimate.max(self.min_trade_size))\n    }\n\n    /// Check multiple order books against multiple AMM pools\n    pub fn scan_opportunities(\n        &self,\n        order_books: &[ThreadSafeOrderBook],\n        amm_pools: &[ThreadSafeAMMPool],\n    ) -> Vec<ArbitrageOpportunity> {\n        let mut opportunities = Vec::new();\n\n        for order_book in order_books {\n            for amm_pool in amm_pools {\n                if let Some(opportunity) = self.check_arbitrage(order_book, amm_pool) {\n                    opportunities.push(opportunity);\n                }\n            }\n        }\n\n        // Sort by profit percentage (descending)\n        opportunities.sort_by(|a, b| b.profit_percent.cmp(&a.profit_percent));\n\n        opportunities\n    }\n\n    /// Get minimum profit threshold in basis points\n    pub fn min_profit_bps(&self) -> u32 {\n        self.min_profit_bps\n    }\n\n    /// Get maximum slippage tolerance in basis points\n    pub fn max_slippage_bps(&self) -> u32 {\n        self.max_slippage_bps\n    }\n\n    /// Get minimum trade size\n    pub fn min_trade_size(&self) -> Decimal {\n        self.min_trade_size\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{events::OrderBookSnapshot, types::TokenReserves};\n    use rust_decimal_macros::dec;\n\n    fn create_test_order_book() -> ThreadSafeOrderBook {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .bids\n            .insert(Price(dec!(1999.0)), Quantity(dec!(5.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2002.0)), Quantity(dec!(12.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n        book\n    }\n\n    fn create_test_amm_pool(price_ratio: Decimal) -> ThreadSafeAMMPool {\n        // Create pool with specific price ratio (token1/token0)\n        let token0_reserve = dec!(1000.0);\n        let token1_reserve = token0_reserve * price_ratio;\n        let reserves = TokenReserves::new(token0_reserve, token1_reserve);\n\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30))\n    }\n\n    #[test]\n    fn test_arbitrage_detection_amm_to_orderbook() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with lower price (1950) than order book best bid (2000)\n        let amm_pool = create_test_amm_pool(dec!(1950.0));\n\n        let opportunity = detector.check_arbitrage(&order_book, &amm_pool);\n\n        assert!(opportunity.is_some());\n        let opp = opportunity.unwrap();\n\n        assert_eq!(opp.buy_venue, Venue::AMM(PoolAddress(\"0x123\".to_string())));\n        assert_eq!(\n            opp.sell_venue,\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()))\n        );\n        assert_eq!(opp.buy_price, Price(dec!(1950.0)));\n        assert_eq!(opp.sell_price, Price(dec!(2000.0)));\n        assert!(opp.profit_percent > dec!(0.0));\n    }\n\n    #[test]\n    fn test_arbitrage_detection_orderbook_to_amm() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with higher price (2050) than order book best ask (2001)\n        let amm_pool = create_test_amm_pool(dec!(2050.0));\n\n        let opportunity = detector.check_arbitrage(&order_book, &amm_pool);\n\n        assert!(opportunity.is_some());\n        let opp = opportunity.unwrap();\n\n        assert_eq!(\n            opp.buy_venue,\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()))\n        );\n        assert_eq!(opp.sell_venue, Venue::AMM(PoolAddress(\"0x123\".to_string())));\n        assert_eq!(opp.buy_price, Price(dec!(2001.0)));\n        assert_eq!(opp.sell_price, Price(dec!(2050.0)));\n        assert!(opp.profit_percent > dec!(0.0));\n    }\n\n    #[test]\n    fn test_no_arbitrage_opportunity() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with price within the spread (2000.5)\n        let amm_pool = create_test_amm_pool(dec!(2000.5));\n\n        let opportunity = detector.check_arbitrage(&order_book, &amm_pool);\n\n        assert!(opportunity.is_none());\n    }\n\n    #[test]\n    fn test_insufficient_profit_threshold() {\n        let detector = ArbitrageDetector::new(500); // 5% minimum profit (very high)\n        let order_book = create_test_order_book();\n\n        // Create AMM with small arbitrage opportunity\n        let amm_pool = create_test_amm_pool(dec!(1990.0));\n\n        let opportunity = detector.check_arbitrage(&order_book, &amm_pool);\n\n        // Should be None because profit is below 5% threshold\n        assert!(opportunity.is_none());\n    }\n\n    #[test]\n    fn test_scan_multiple_opportunities() {\n        let detector = ArbitrageDetector::new(10);\n\n        let order_books = vec![create_test_order_book()];\n\n        let amm_pools = vec![\n            create_test_amm_pool(dec!(1950.0)), // Should create arbitrage opportunity\n            create_test_amm_pool(dec!(2000.5)), // No opportunity (within spread)\n            create_test_amm_pool(dec!(2050.0)), // Should create arbitrage opportunity\n        ];\n\n        let opportunities = detector.scan_opportunities(&order_books, &amm_pools);\n\n        // Should find 2 opportunities\n        assert_eq!(opportunities.len(), 2);\n\n        // Should be sorted by profit percentage (descending)\n        assert!(opportunities[0].profit_percent >= opportunities[1].profit_percent);\n    }\n\n    #[test]\n    fn test_arbitrage_opportunity_calculations() {\n        let opp = ArbitrageOpportunity::new(\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n            Venue::AMM(PoolAddress(\"0x123\".to_string())),\n            Price(dec!(2000.0)),\n            Price(dec!(2020.0)),\n            Quantity(dec!(10.0)),\n        );\n\n        assert_eq!(opp.estimated_profit, dec!(200.0)); // (2020 - 2000) * 10\n        assert_eq!(opp.profit_percent, dec!(1.0)); // (20 / 2000) * 100 = 1%\n    }\n\n    #[test]\n    fn test_detector_configuration() {\n        let detector = ArbitrageDetector::with_params(\n            25,         // 0.25% min profit\n            100,        // 1% max slippage\n            dec!(50.0), // min trade size\n        );\n\n        assert_eq!(detector.min_profit_bps(), 25);\n        assert_eq!(detector.max_slippage_bps(), 100);\n        assert_eq!(detector.min_trade_size(), dec!(50.0));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":24}},{"line":35,"address":[],"length":0,"stats":{"Line":24}},{"line":36,"address":[],"length":0,"stats":{"Line":24}},{"line":37,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":16}},{"line":113,"address":[],"length":0,"stats":{"Line":48}},{"line":114,"address":[],"length":0,"stats":{"Line":48}},{"line":117,"address":[],"length":0,"stats":{"Line":48}},{"line":118,"address":[],"length":0,"stats":{"Line":16}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":34}},{"line":139,"address":[],"length":0,"stats":{"Line":20}},{"line":140,"address":[],"length":0,"stats":{"Line":20}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":20}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":16}},{"line":163,"address":[],"length":0,"stats":{"Line":16}},{"line":164,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":10}},{"line":206,"address":[],"length":0,"stats":{"Line":10}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":10}},{"line":242,"address":[],"length":0,"stats":{"Line":30}},{"line":243,"address":[],"length":0,"stats":{"Line":30}},{"line":247,"address":[],"length":0,"stats":{"Line":20}},{"line":249,"address":[],"length":0,"stats":{"Line":20}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":14}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":2}}],"covered":47,"coverable":55},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","events.rs"],"content":"use crate::domain::types::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeMap;\n\n/// Price level in an order book\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceLevel {\n    /// Price at this level\n    pub price: Price,\n    /// Quantity available at this price\n    pub quantity: Quantity,\n}\n\nimpl PriceLevel {\n    /// Creates a new price level with the given price and quantity\n    pub fn new(price: Price, quantity: Quantity) -> Self {\n        Self { price, quantity }\n    }\n}\n\n/// Price level update for order book deltas\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceLevelUpdate {\n    /// Order side (bid or ask)\n    pub side: Side,\n    /// Price level\n    pub price: Price,\n    /// Quantity at this price level\n    pub quantity: Quantity,\n    /// Action to perform (update or delete)\n    pub action: UpdateAction,\n}\n\nimpl PriceLevelUpdate {\n    /// Creates a new price level update\n    pub fn new(side: Side, price: Price, quantity: Quantity, action: UpdateAction) -> Self {\n        Self {\n            side,\n            price,\n            quantity,\n            action,\n        }\n    }\n\n    /// Creates an update action for the given side, price, and quantity\n    pub fn update(side: Side, price: Price, quantity: Quantity) -> Self {\n        Self::new(side, price, quantity, UpdateAction::Update)\n    }\n\n    /// Creates a delete action for the given side and price\n    pub fn delete(side: Side, price: Price) -> Self {\n        Self::new(side, price, Quantity::zero(), UpdateAction::Delete)\n    }\n}\n\n/// Complete order book snapshot with full state\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct OrderBookSnapshot {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the snapshot\n    pub timestamp: Timestamp,\n    /// Bid levels (price -> quantity)\n    pub bids: BTreeMap<Price, Quantity>,\n    /// Ask levels (price -> quantity)\n    pub asks: BTreeMap<Price, Quantity>,\n}\n\nimpl OrderBookSnapshot {\n    /// Creates a new empty order book snapshot\n    pub fn new(sequence: SequenceNumber, timestamp: Timestamp) -> Self {\n        Self {\n            sequence,\n            timestamp,\n            bids: BTreeMap::new(),\n            asks: BTreeMap::new(),\n        }\n    }\n\n    /// Creates a new order book snapshot with the given levels\n    pub fn with_levels(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        bids: BTreeMap<Price, Quantity>,\n        asks: BTreeMap<Price, Quantity>,\n    ) -> Self {\n        Self {\n            sequence,\n            timestamp,\n            bids,\n            asks,\n        }\n    }\n\n    /// Get the best bid (highest price on bid side)\n    pub fn best_bid(&self) -> Option<&Price> {\n        self.bids.keys().next_back()\n    }\n\n    /// Get the best ask (lowest price on ask side)\n    pub fn best_ask(&self) -> Option<&Price> {\n        self.asks.keys().next()\n    }\n\n    /// Get the mid price if both sides have liquidity\n    pub fn mid_price(&self) -> Option<Price> {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) => Some(Price((bid.0 + ask.0) / rust_decimal::Decimal::from(2))),\n            _ => None,\n        }\n    }\n\n    /// Get the spread between best bid and ask\n    pub fn spread(&self) -> Option<Price> {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) => Some(Price(ask.0 - bid.0)),\n            _ => None,\n        }\n    }\n}\n\n/// Incremental order book delta with incremental updates\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct OrderBookDelta {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the delta\n    pub timestamp: Timestamp,\n    /// List of price level updates\n    pub updates: Vec<PriceLevelUpdate>,\n}\n\nimpl OrderBookDelta {\n    /// Creates a new empty order book delta\n    pub fn new(sequence: SequenceNumber, timestamp: Timestamp) -> Self {\n        Self {\n            sequence,\n            timestamp,\n            updates: Vec::new(),\n        }\n    }\n\n    /// Creates a new order book delta with the given updates\n    pub fn with_updates(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        updates: Vec<PriceLevelUpdate>,\n    ) -> Self {\n        Self {\n            sequence,\n            timestamp,\n            updates,\n        }\n    }\n\n    /// Adds a price level update to this delta\n    pub fn add_update(&mut self, update: PriceLevelUpdate) {\n        self.updates.push(update);\n    }\n}\n\n/// Trade execution event\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Trade {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the trade\n    pub timestamp: Timestamp,\n    /// Trade price\n    pub price: Price,\n    /// Trade quantity\n    pub quantity: Quantity,\n    /// Taker side of the trade\n    pub side: Side,\n}\n\nimpl Trade {\n    /// Creates a new trade event\n    pub fn new(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        price: Price,\n        quantity: Quantity,\n        side: Side,\n    ) -> Self {\n        Self {\n            sequence,\n            timestamp,\n            price,\n            quantity,\n            side,\n        }\n    }\n}\n\n/// AMM pool state update\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct AMMPoolUpdate {\n    /// Timestamp of the update\n    pub timestamp: Timestamp,\n    /// Updated token reserves\n    pub reserves: TokenReserves,\n    /// Updated square root price (for V3 pools)\n    pub sqrt_price: Option<SqrtPriceX96>,\n    /// Pool fee tier\n    pub fee_tier: FeeTier,\n}\n\nimpl AMMPoolUpdate {\n    /// Creates a new AMM pool update\n    pub fn new(\n        timestamp: Timestamp,\n        reserves: TokenReserves,\n        sqrt_price: Option<SqrtPriceX96>,\n        fee_tier: FeeTier,\n    ) -> Self {\n        Self {\n            timestamp,\n            reserves,\n            sqrt_price,\n            fee_tier,\n        }\n    }\n\n    /// Calculate implied mid price from reserves (Uniswap V2 style)\n    pub fn implied_mid_from_reserves(&self) -> Price {\n        if self.reserves.token0.is_zero() {\n            return Price::zero();\n        }\n        Price(self.reserves.token1 / self.reserves.token0)\n    }\n\n    /// Get implied mid price (prefer sqrt_price if available, otherwise use reserves)\n    pub fn implied_mid(&self) -> Price {\n        match self.sqrt_price {\n            Some(sqrt_price) => sqrt_price.to_price(),\n            None => self.implied_mid_from_reserves(),\n        }\n    }\n}\n\n/// Market events that can be processed by the system\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum MarketEvent {\n    /// Order book snapshot\n    OrderBookSnapshot(Symbol, OrderBookSnapshot),\n    /// Order book delta update\n    OrderBookDelta(Symbol, OrderBookDelta),\n    /// Trade execution\n    Trade(Symbol, Trade),\n    /// AMM pool update\n    AMMUpdate(PoolAddress, AMMPoolUpdate),\n}\n\nimpl MarketEvent {\n    /// Returns the timestamp of this market event\n    pub fn timestamp(&self) -> Timestamp {\n        match self {\n            MarketEvent::OrderBookSnapshot(_, snapshot) => snapshot.timestamp,\n            MarketEvent::OrderBookDelta(_, delta) => delta.timestamp,\n            MarketEvent::Trade(_, trade) => trade.timestamp,\n            MarketEvent::AMMUpdate(_, update) => update.timestamp,\n        }\n    }\n\n    /// Returns the sequence number if available\n    pub fn sequence(&self) -> Option<SequenceNumber> {\n        match self {\n            MarketEvent::OrderBookSnapshot(_, snapshot) => Some(snapshot.sequence),\n            MarketEvent::OrderBookDelta(_, delta) => Some(delta.sequence),\n            MarketEvent::Trade(_, trade) => Some(trade.sequence),\n            MarketEvent::AMMUpdate(_, _) => None, // AMM updates don't have sequence numbers\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_order_book_snapshot_best_prices() {\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n\n        // Add some bid levels\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n\n        // Add some ask levels\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(12.0)));\n\n        assert_eq!(snapshot.best_bid(), Some(&Price(dec!(100.0))));\n        assert_eq!(snapshot.best_ask(), Some(&Price(dec!(100.5))));\n        assert_eq!(snapshot.mid_price(), Some(Price(dec!(100.25))));\n        assert_eq!(snapshot.spread(), Some(Price(dec!(0.5))));\n    }\n\n    #[test]\n    fn test_amm_pool_implied_price() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n\n        let implied_price = update.implied_mid_from_reserves();\n        assert_eq!(implied_price, Price(dec!(2.0))); // 2000 / 1000 = 2.0\n    }\n\n    #[test]\n    fn test_price_level_update_creation() {\n        let update = PriceLevelUpdate::update(Side::Bid, Price(dec!(100.0)), Quantity(dec!(5.0)));\n\n        assert_eq!(update.side, Side::Bid);\n        assert_eq!(update.price, Price(dec!(100.0)));\n        assert_eq!(update.quantity, Quantity(dec!(5.0)));\n        assert_eq!(update.action, UpdateAction::Update);\n\n        let delete = PriceLevelUpdate::delete(Side::Ask, Price(dec!(101.0)));\n        assert_eq!(delete.action, UpdateAction::Delete);\n        assert!(delete.quantity.is_zero());\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":20}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":40}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":43}},{"line":75,"address":[],"length":0,"stats":{"Line":43}},{"line":76,"address":[],"length":0,"stats":{"Line":43}},{"line":81,"address":[],"length":0,"stats":{"Line":204}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":12}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":12}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":48},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","market_data.rs"],"content":"use crate::domain::{amm_pool::*, events::*, order_book::*, types::*};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// Market data manager that holds all order books and AMM pools\n#[derive(Debug)]\npub struct MarketDataManager {\n    /// Thread-safe order books indexed by symbol\n    pub orderbooks: Arc<RwLock<HashMap<Symbol, ThreadSafeOrderBook>>>,\n    /// Thread-safe AMM pools indexed by address\n    pub amm_pools: Arc<RwLock<HashMap<PoolAddress, ThreadSafeAMMPool>>>,\n}\n\nimpl MarketDataManager {\n    /// Creates a new market data manager\n    pub fn new() -> Self {\n        Self {\n            orderbooks: Arc::new(RwLock::new(HashMap::new())),\n            amm_pools: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Process a market event\n    pub fn process_event(&self, event: MarketEvent) -> TradingResult<()> {\n        match event {\n            MarketEvent::OrderBookSnapshot(symbol, snapshot) => {\n                self.apply_orderbook_snapshot(symbol, snapshot)\n            }\n            MarketEvent::OrderBookDelta(symbol, delta) => {\n                self.apply_orderbook_delta(symbol, &delta)\n            }\n            MarketEvent::Trade(symbol, trade) => self.process_trade(symbol, trade),\n            MarketEvent::AMMUpdate(address, update) => self.process_amm_update(address, update),\n        }\n    }\n\n    /// Apply order book snapshot\n    pub fn apply_orderbook_snapshot(\n        &self,\n        symbol: Symbol,\n        snapshot: OrderBookSnapshot,\n    ) -> TradingResult<()> {\n        let mut books = self\n            .orderbooks\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        if let Some(book) = books.get(&symbol) {\n            book.apply_snapshot(snapshot)?\n        } else {\n            // Create new order book if it doesn't exist\n            let new_book = ThreadSafeOrderBook::new(symbol.clone());\n            new_book.apply_snapshot(snapshot)?;\n            books.insert(symbol, new_book);\n        }\n        Ok(())\n    }\n\n    /// Apply order book delta update\n    pub fn apply_orderbook_delta(\n        &self,\n        symbol: Symbol,\n        delta: &OrderBookDelta,\n    ) -> TradingResult<()> {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        if let Some(book) = books.get(&symbol) {\n            book.apply_delta(delta)?\n        } else {\n            return Err(TradingError::ParseError(format!(\n                \"No order book found for symbol: {}\",\n                symbol\n            )));\n        }\n        Ok(())\n    }\n\n    /// Process trade (for now, just log it - could be used for analytics)\n    fn process_trade(&self, _symbol: Symbol, _trade: Trade) -> TradingResult<()> {\n        // In a full implementation, this would update trade statistics,\n        // volume metrics, etc.\n        Ok(())\n    }\n\n    /// Process AMM pool update\n    fn process_amm_update(&self, address: PoolAddress, update: AMMPoolUpdate) -> TradingResult<()> {\n        let mut pools = self\n            .amm_pools\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        match pools.get(&address) {\n            Some(pool) => {\n                pool.update_state(update)?;\n            }\n            None => {\n                // Create new pool - assume V2 style if no sqrt_price, V3 if sqrt_price exists\n                let pool = match update.sqrt_price {\n                    Some(sqrt_price) => ThreadSafeAMMPool::new_v3(\n                        address.clone(),\n                        update.reserves,\n                        sqrt_price,\n                        update.fee_tier,\n                    ),\n                    None => {\n                        ThreadSafeAMMPool::new_v2(address.clone(), update.reserves, update.fee_tier)\n                    }\n                };\n                pools.insert(address, pool);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get order book for symbol\n    pub fn get_orderbook(&self, symbol: &Symbol) -> Option<ThreadSafeOrderBook> {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        books.get(symbol).cloned()\n    }\n\n    /// Get AMM pool for address\n    pub fn get_amm_pool(&self, address: &PoolAddress) -> Option<ThreadSafeAMMPool> {\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        pools.get(address).cloned()\n    }\n\n    /// Add new AMM pool\n    pub fn add_amm_pool(&self, address: PoolAddress, pool: ThreadSafeAMMPool) {\n        let mut pools = self\n            .amm_pools\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        pools.insert(address, pool);\n    }\n\n    /// Get all order book symbols\n    pub fn get_orderbook_symbols(&self) -> Vec<Symbol> {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        books.keys().cloned().collect()\n    }\n\n    /// Get all AMM pool addresses\n    pub fn get_amm_pool_addresses(&self) -> Vec<PoolAddress> {\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        pools.keys().cloned().collect()\n    }\n\n    /// Get market metrics for all instruments\n    pub fn get_market_metrics(&self) -> MarketMetrics {\n        let mut metrics = MarketMetrics::new();\n\n        // Collect order book metrics\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        for (symbol, book) in books.iter() {\n            if let (Some(bid), Some(ask)) = (book.best_bid(), book.best_ask()) {\n                let spread = ask.0 - bid.0;\n                let mid_price = (bid.0 + ask.0) / rust_decimal::Decimal::from(2);\n\n                metrics.orderbook_metrics.insert(\n                    symbol.clone(),\n                    OrderBookMetrics {\n                        symbol: symbol.clone(),\n                        best_bid: bid,\n                        best_ask: ask,\n                        mid_price: Price(mid_price),\n                        spread,\n                        last_update: book.last_update(),\n                    },\n                );\n            }\n        }\n\n        // Collect AMM pool metrics\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        for (address, pool) in pools.iter() {\n            metrics.amm_metrics.insert(\n                address.clone(),\n                AMMMetrics {\n                    address: address.clone(),\n                    pool_type: pool.pool_type(),\n                    implied_mid: pool.implied_mid(),\n                    reserves: pool.get_reserves(),\n                    fee_tier: pool.get_fee_tier(),\n                    last_update: pool.last_update(),\n                },\n            );\n        }\n\n        metrics.timestamp = chrono::Utc::now();\n        metrics\n    }\n}\n\nimpl Default for MarketDataManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Market metrics aggregated across all instruments\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MarketMetrics {\n    /// Timestamp when metrics were collected\n    pub timestamp: Timestamp,\n    /// Order book metrics by symbol\n    pub orderbook_metrics: HashMap<Symbol, OrderBookMetrics>,\n    /// AMM pool metrics by pool address\n    pub amm_metrics: HashMap<PoolAddress, AMMMetrics>,\n}\n\nimpl MarketMetrics {\n    /// Creates new market metrics with current timestamp\n    pub fn new() -> Self {\n        Self {\n            timestamp: chrono::Utc::now(),\n            orderbook_metrics: HashMap::new(),\n            amm_metrics: HashMap::new(),\n        }\n    }\n}\n\nimpl Default for MarketMetrics {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Order book metrics for a specific symbol\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBookMetrics {\n    /// Trading symbol\n    pub symbol: Symbol,\n    /// Best bid price\n    pub best_bid: Price,\n    /// Best ask price\n    pub best_ask: Price,\n    /// Mid price (average of best bid and ask)\n    pub mid_price: Price,\n    /// Bid-ask spread\n    pub spread: rust_decimal::Decimal,\n    /// Timestamp of last update\n    pub last_update: Timestamp,\n}\n\n/// AMM pool metrics\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AMMMetrics {\n    /// Pool address\n    pub address: PoolAddress,\n    /// Type of AMM pool (V2/V3)\n    pub pool_type: AMMPoolType,\n    /// Implied mid price from reserves\n    pub implied_mid: Price,\n    /// Token reserves in the pool\n    pub reserves: TokenReserves,\n    /// Fee tier for the pool\n    pub fee_tier: FeeTier,\n    /// Timestamp of last update\n    pub last_update: Timestamp,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_market_data_manager_creation() {\n        let manager = MarketDataManager::new();\n        assert!(manager.get_orderbook_symbols().is_empty());\n        assert!(manager.get_amm_pool_addresses().is_empty());\n    }\n\n    #[test]\n    fn test_orderbook_snapshot_processing() {\n        let manager = MarketDataManager::new();\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        let book = manager.get_orderbook(&symbol).unwrap();\n        assert_eq!(book.best_bid(), Some(Price(dec!(2000.0))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(2001.0))));\n    }\n\n    #[test]\n    fn test_orderbook_delta_processing() {\n        let manager = MarketDataManager::new();\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        // First, create initial snapshot\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        // Then apply delta\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(1999.0)),\n                Quantity(dec!(5.0)),\n            )],\n        );\n\n        let event = MarketEvent::OrderBookDelta(symbol.clone(), delta);\n        manager.process_event(event).unwrap();\n\n        let book = manager.get_orderbook(&symbol).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(1999.0))),\n            Quantity(dec!(5.0))\n        );\n    }\n\n    #[test]\n    fn test_amm_update_processing() {\n        let manager = MarketDataManager::new();\n        let address = PoolAddress(\"0x123\".to_string());\n\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n\n        let event = MarketEvent::AMMUpdate(address.clone(), update);\n        manager.process_event(event).unwrap();\n\n        let pool = manager.get_amm_pool(&address).unwrap();\n        assert_eq!(pool.implied_mid(), Price(dec!(2.0)));\n        assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n    }\n\n    #[test]\n    fn test_market_metrics_collection() {\n        let manager = MarketDataManager::new();\n\n        // Add order book\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        // Add AMM pool\n        let address = PoolAddress(\"0x123\".to_string());\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n        let event = MarketEvent::AMMUpdate(address.clone(), update);\n        manager.process_event(event).unwrap();\n\n        // Get metrics\n        let metrics = manager.get_market_metrics();\n\n        assert_eq!(metrics.orderbook_metrics.len(), 1);\n        assert_eq!(metrics.amm_metrics.len(), 1);\n\n        let ob_metrics = metrics.orderbook_metrics.get(&symbol).unwrap();\n        assert_eq!(ob_metrics.best_bid, Price(dec!(2000.0)));\n        assert_eq!(ob_metrics.best_ask, Price(dec!(2001.0)));\n        assert_eq!(ob_metrics.mid_price, Price(dec!(2000.5)));\n\n        let amm_metrics = metrics.amm_metrics.get(&address).unwrap();\n        assert_eq!(amm_metrics.implied_mid, Price(dec!(2.0)));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":18}},{"line":20,"address":[],"length":0,"stats":{"Line":72}},{"line":21,"address":[],"length":0,"stats":{"Line":36}},{"line":26,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":30}},{"line":28,"address":[],"length":0,"stats":{"Line":16}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":12}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":16}},{"line":45,"address":[],"length":0,"stats":{"Line":32}},{"line":46,"address":[],"length":0,"stats":{"Line":16}},{"line":49,"address":[],"length":0,"stats":{"Line":32}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":64}},{"line":54,"address":[],"length":0,"stats":{"Line":48}},{"line":55,"address":[],"length":0,"stats":{"Line":16}},{"line":57,"address":[],"length":0,"stats":{"Line":16}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":24}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":48}},{"line":118,"address":[],"length":0,"stats":{"Line":36}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":16}},{"line":124,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":16}},{"line":139,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":16}},{"line":154,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":16}},{"line":175,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}}],"covered":60,"coverable":75},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","mod.rs"],"content":"//! Domain layer containing core business logic and entities\n//!\n//! This module contains the core domain entities and business logic for the quantitative\n//! trading system, including order books, AMM pools, arbitrage detection, and market events.\n\n/// AMM pool implementations and utilities\npub mod amm_pool;\n/// Arbitrage detection and opportunity analysis\npub mod arbitrage;\n/// Market events and data structures\npub mod events;\n/// Market data management and aggregation\npub mod market_data;\n/// Order book implementations\npub mod order_book;\n/// Core types and primitives\npub mod types;\n\npub use events::*;\npub use market_data::*;\npub use types::*;\n\npub use amm_pool::{AMMPool, AMMPoolType, PriceImpactResult, ThreadSafeAMMPool, TokenIndex};\npub use arbitrage::{ArbitrageDetector, ArbitrageOpportunity, Venue};\npub use order_book::{OrderBookL2, ThreadSafeOrderBook};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","order_book.rs"],"content":"use crate::domain::{events::*, types::*};\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// Thread-safe L2 order book implementation\n/// Uses BTreeMap for automatic price sorting and O(log n) operations\n#[derive(Debug)]\npub struct OrderBookL2 {\n    symbol: Symbol,\n    /// Bids sorted by price (descending - highest first)\n    bids: BTreeMap<Price, Quantity>,\n    /// Asks sorted by price (ascending - lowest first)  \n    asks: BTreeMap<Price, Quantity>,\n    /// Last processed sequence number for idempotent replay\n    last_sequence: SequenceNumber,\n    /// Timestamp of last update\n    last_update: Timestamp,\n}\n\nimpl OrderBookL2 {\n    /// Creates a new order book for the given symbol\n    pub fn new(symbol: Symbol) -> Self {\n        Self {\n            symbol,\n            bids: BTreeMap::new(),\n            asks: BTreeMap::new(),\n            last_sequence: SequenceNumber(0),\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Apply a complete snapshot, replacing all existing data\n    pub fn apply_snapshot(&mut self, snapshot: OrderBookSnapshot) -> TradingResult<()> {\n        // Validate sequence number progression\n        if snapshot.sequence.0 <= self.last_sequence.0 {\n            return Err(TradingError::SequenceOutOfOrder {\n                expected: self.last_sequence.0 + 1,\n                actual: snapshot.sequence.0,\n            });\n        }\n\n        self.bids = snapshot.bids;\n        self.asks = snapshot.asks;\n        self.last_sequence = snapshot.sequence;\n        self.last_update = snapshot.timestamp;\n\n        Ok(())\n    }\n\n    /// Apply incremental delta updates\n    pub fn apply_delta(&mut self, delta: OrderBookDelta) -> TradingResult<()> {\n        // Validate sequence number progression for idempotent replay\n        if delta.sequence.0 <= self.last_sequence.0 {\n            // Skip if we've already processed this sequence\n            return Ok(());\n        }\n\n        if delta.sequence.0 != self.last_sequence.0 + 1 {\n            return Err(TradingError::SequenceOutOfOrder {\n                expected: self.last_sequence.0 + 1,\n                actual: delta.sequence.0,\n            });\n        }\n\n        // Apply each update in the delta\n        for update in delta.updates {\n            self.apply_price_level_update(update)?;\n        }\n\n        self.last_sequence = delta.sequence;\n        self.last_update = delta.timestamp;\n\n        Ok(())\n    }\n\n    /// Apply a single price level update\n    fn apply_price_level_update(&mut self, update: PriceLevelUpdate) -> TradingResult<()> {\n        let levels = match update.side {\n            Side::Bid => &mut self.bids,\n            Side::Ask => &mut self.asks,\n        };\n\n        match update.action {\n            UpdateAction::Update => {\n                if update.quantity.is_zero() {\n                    levels.remove(&update.price);\n                } else {\n                    levels.insert(update.price, update.quantity);\n                }\n            }\n            UpdateAction::Delete => {\n                levels.remove(&update.price);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get atomic snapshot without blocking writers\n    pub fn get_snapshot(&self) -> OrderBookSnapshot {\n        OrderBookSnapshot::with_levels(\n            self.last_sequence,\n            self.last_update,\n            self.bids.clone(),\n            self.asks.clone(),\n        )\n    }\n\n    /// Get best bid price (highest bid)\n    pub fn best_bid(&self) -> Option<Price> {\n        self.bids.keys().next_back().copied()\n    }\n\n    /// Get best ask price (lowest ask)\n    pub fn best_ask(&self) -> Option<Price> {\n        self.asks.keys().next().copied()\n    }\n\n    /// Get mid price if both sides have liquidity\n    pub fn mid_price(&self) -> Option<Price> {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) => Some(Price((bid.0 + ask.0) / rust_decimal::Decimal::from(2))),\n            _ => None,\n        }\n    }\n\n    /// Get spread between best bid and ask\n    pub fn spread(&self) -> Option<Price> {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) => Some(Price(ask.0 - bid.0)),\n            _ => None,\n        }\n    }\n\n    /// Get quantity at specific price level\n    pub fn quantity_at_price(&self, side: Side, price: Price) -> Quantity {\n        let levels = match side {\n            Side::Bid => &self.bids,\n            Side::Ask => &self.asks,\n        };\n\n        levels.get(&price).copied().unwrap_or(Quantity::zero())\n    }\n\n    /// Get depth (total quantity) up to a certain price\n    pub fn depth_to_price(&self, side: Side, max_price: Price) -> Quantity {\n        let levels = match side {\n            Side::Bid => &self.bids,\n            Side::Ask => &self.asks,\n        };\n\n        let mut total = rust_decimal::Decimal::ZERO;\n\n        match side {\n            Side::Bid => {\n                // For bids, sum all levels >= max_price (since we want depth at or above this price)\n                for (_price, quantity) in levels.range(max_price..) {\n                    total += quantity.0;\n                }\n            }\n            Side::Ask => {\n                // For asks, sum all levels <= max_price (since we want depth at or below this price)\n                for (_price, quantity) in levels.range(..=max_price) {\n                    total += quantity.0;\n                }\n            }\n        }\n\n        Quantity(total)\n    }\n\n    /// Get the symbol for this order book\n    pub fn symbol(&self) -> &Symbol {\n        &self.symbol\n    }\n\n    /// Get last processed sequence number\n    pub fn last_sequence(&self) -> SequenceNumber {\n        self.last_sequence\n    }\n\n    /// Get timestamp of last update\n    pub fn last_update(&self) -> Timestamp {\n        self.last_update\n    }\n}\n\n/// Thread-safe wrapper around OrderBookL2\n#[derive(Debug, Clone)]\npub struct ThreadSafeOrderBook {\n    inner: Arc<RwLock<OrderBookL2>>,\n}\n\nimpl ThreadSafeOrderBook {\n    /// Creates a new thread-safe order book for the given symbol\n    pub fn new(symbol: Symbol) -> Self {\n        Self {\n            inner: Arc::new(RwLock::new(OrderBookL2::new(symbol))),\n        }\n    }\n\n    /// Apply snapshot with write lock\n    pub fn apply_snapshot(&self, snapshot: OrderBookSnapshot) -> TradingResult<()> {\n        let mut book = self\n            .inner\n            .write()\n            .map_err(|_| TradingError::LockError(\"Failed to acquire write lock\".to_string()))?;\n        book.apply_snapshot(snapshot)\n    }\n\n    /// Apply a delta update to the order book\n    pub fn apply_delta(&self, delta: &OrderBookDelta) -> TradingResult<()> {\n        let mut book = self\n            .inner\n            .write()\n            .map_err(|_| TradingError::LockError(\"Failed to acquire write lock\".to_string()))?;\n        book.apply_delta(delta.clone())\n    }\n\n    /// Get a snapshot of the current order book state\n    pub fn get_snapshot(&self) -> OrderBookSnapshot {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .get_snapshot()\n    }\n\n    /// Get the best bid price\n    pub fn best_bid(&self) -> Option<Price> {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .best_bid()\n    }\n\n    /// Get the best ask price\n    pub fn best_ask(&self) -> Option<Price> {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .best_ask()\n    }\n\n    /// Get the mid price (average of best bid and ask)\n    pub fn mid_price(&self) -> Option<Price> {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .mid_price()\n    }\n\n    /// Get the spread (difference between best ask and bid)\n    pub fn spread(&self) -> Option<Price> {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .spread()\n    }\n\n    /// Get quantity available at a specific price level\n    pub fn quantity_at_price(&self, side: Side, price: Price) -> Quantity {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .quantity_at_price(side, price)\n    }\n\n    /// Get total depth up to a maximum price\n    pub fn depth_to_price(&self, side: Side, max_price: Price) -> Quantity {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .depth_to_price(side, max_price)\n    }\n\n    /// Get the symbol for this order book\n    pub fn symbol(&self) -> Symbol {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .symbol()\n            .clone()\n    }\n\n    /// Get the last sequence number\n    pub fn last_sequence(&self) -> SequenceNumber {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_sequence()\n    }\n\n    /// Get the last update timestamp\n    pub fn last_update(&self) -> Timestamp {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_update()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n    use std::thread;\n    use std::time::Duration;\n\n    #[test]\n    fn test_order_book_snapshot_application() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(12.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.0))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(100.5))));\n        assert_eq!(book.mid_price(), Some(Price(dec!(100.25))));\n    }\n\n    #[test]\n    fn test_order_book_delta_application() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Apply initial snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Apply delta update\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(100.5)),\n                Quantity(dec!(15.0)),\n            )],\n        );\n\n        book.apply_delta(delta).unwrap();\n\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.5))));\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.5))),\n            Quantity(dec!(15.0))\n        );\n    }\n\n    #[test]\n    fn test_idempotent_replay() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        book.apply_snapshot(snapshot).unwrap();\n\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(100.0)),\n                Quantity(dec!(10.0)),\n            )],\n        );\n\n        // Apply delta first time\n        book.apply_delta(delta.clone()).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.0))),\n            Quantity(dec!(10.0))\n        );\n\n        // Apply same delta again - should be idempotent\n        book.apply_delta(delta).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.0))),\n            Quantity(dec!(10.0))\n        );\n    }\n\n    #[test]\n    fn test_sequence_validation() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Try to apply delta with wrong sequence number\n        let delta = OrderBookDelta::new(SequenceNumber(5), chrono::Utc::now()); // Should be 2\n\n        let result = book.apply_delta(delta);\n        assert!(result.is_err());\n\n        if let Err(TradingError::SequenceOutOfOrder { expected, actual }) = result {\n            assert_eq!(expected, 2);\n            assert_eq!(actual, 5);\n        } else {\n            panic!(\"Expected SequenceOutOfOrder error\");\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_order_book() {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Apply initial snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test concurrent reads\n        let book_clone = book.clone();\n        let handle = thread::spawn(move || {\n            for _ in 0..100 {\n                let _ = book_clone.best_bid();\n                let _ = book_clone.get_snapshot();\n                thread::sleep(Duration::from_micros(1));\n            }\n        });\n\n        // Concurrent reads from main thread\n        for _ in 0..100 {\n            let _ = book.best_ask();\n            let _ = book.mid_price();\n            thread::sleep(Duration::from_micros(1));\n        }\n\n        handle.join().unwrap();\n\n        // Verify state is still consistent\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.0))));\n    }\n\n    #[test]\n    fn test_depth_calculation() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n        snapshot.bids.insert(Price(dec!(99.0)), Quantity(dec!(8.0)));\n\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(12.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(7.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test bid depth\n        let bid_depth = book.depth_to_price(Side::Bid, Price(dec!(99.5)));\n        assert_eq!(bid_depth, Quantity(dec!(15.0))); // 10.0 + 5.0\n\n        // Test ask depth\n        let ask_depth = book.depth_to_price(Side::Ask, Price(dec!(101.0)));\n        assert_eq!(ask_depth, Quantity(dec!(19.0))); // 12.0 + 7.0\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":43}},{"line":26,"address":[],"length":0,"stats":{"Line":86}},{"line":27,"address":[],"length":0,"stats":{"Line":86}},{"line":28,"address":[],"length":0,"stats":{"Line":43}},{"line":29,"address":[],"length":0,"stats":{"Line":43}},{"line":34,"address":[],"length":0,"stats":{"Line":43}},{"line":36,"address":[],"length":0,"stats":{"Line":43}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":54,"address":[],"length":0,"stats":{"Line":14}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":30}},{"line":68,"address":[],"length":0,"stats":{"Line":30}},{"line":71,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":20}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":10}},{"line":101,"address":[],"length":0,"stats":{"Line":200}},{"line":103,"address":[],"length":0,"stats":{"Line":200}},{"line":104,"address":[],"length":0,"stats":{"Line":200}},{"line":105,"address":[],"length":0,"stats":{"Line":400}},{"line":106,"address":[],"length":0,"stats":{"Line":400}},{"line":111,"address":[],"length":0,"stats":{"Line":442}},{"line":112,"address":[],"length":0,"stats":{"Line":1326}},{"line":116,"address":[],"length":0,"stats":{"Line":438}},{"line":117,"address":[],"length":0,"stats":{"Line":1314}},{"line":121,"address":[],"length":0,"stats":{"Line":207}},{"line":122,"address":[],"length":0,"stats":{"Line":828}},{"line":123,"address":[],"length":0,"stats":{"Line":7}},{"line":124,"address":[],"length":0,"stats":{"Line":200}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":8}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":18}},{"line":138,"address":[],"length":0,"stats":{"Line":36}},{"line":139,"address":[],"length":0,"stats":{"Line":14}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":108}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":16}},{"line":175,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":33}},{"line":199,"address":[],"length":0,"stats":{"Line":99}},{"line":204,"address":[],"length":0,"stats":{"Line":33}},{"line":205,"address":[],"length":0,"stats":{"Line":66}},{"line":206,"address":[],"length":0,"stats":{"Line":33}},{"line":208,"address":[],"length":0,"stats":{"Line":33}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":12}},{"line":215,"address":[],"length":0,"stats":{"Line":6}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":200}},{"line":223,"address":[],"length":0,"stats":{"Line":400}},{"line":230,"address":[],"length":0,"stats":{"Line":229}},{"line":231,"address":[],"length":0,"stats":{"Line":458}},{"line":238,"address":[],"length":0,"stats":{"Line":227}},{"line":239,"address":[],"length":0,"stats":{"Line":454}},{"line":246,"address":[],"length":0,"stats":{"Line":205}},{"line":247,"address":[],"length":0,"stats":{"Line":410}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":12}},{"line":263,"address":[],"length":0,"stats":{"Line":36}},{"line":266,"address":[],"length":0,"stats":{"Line":24}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":16}},{"line":279,"address":[],"length":0,"stats":{"Line":32}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":4}},{"line":296,"address":[],"length":0,"stats":{"Line":8}}],"covered":88,"coverable":99},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","types.rs"],"content":"use rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Trading symbol identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Symbol(pub String);\n\nimpl fmt::Display for Symbol {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Price with decimal precision to avoid floating-point errors\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct Price(pub Decimal);\n\nimpl Price {\n    /// Creates a zero price\n    pub fn zero() -> Self {\n        Price(Decimal::ZERO)\n    }\n\n    /// Returns true if the price is zero\n    pub fn is_zero(&self) -> bool {\n        self.0.is_zero()\n    }\n}\n\nimpl fmt::Display for Price {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Quantity with decimal precision\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct Quantity(pub Decimal);\n\nimpl Quantity {\n    /// Creates a zero quantity\n    pub fn zero() -> Self {\n        Quantity(Decimal::ZERO)\n    }\n\n    /// Returns true if the quantity is zero\n    pub fn is_zero(&self) -> bool {\n        self.0.is_zero()\n    }\n}\n\nimpl fmt::Display for Quantity {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Order side (bid or ask)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Side {\n    /// Bid (buy) side\n    Bid,\n    /// Ask (sell) side\n    Ask,\n}\n\nimpl fmt::Display for Side {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Side::Bid => write!(f, \"BID\"),\n            Side::Ask => write!(f, \"ASK\"),\n        }\n    }\n}\n\n/// Sequence number for idempotent message processing\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct SequenceNumber(pub u64);\n\nimpl fmt::Display for SequenceNumber {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Update action for price level changes\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum UpdateAction {\n    /// Add or update a price level\n    Update,\n    /// Remove a price level\n    Delete,\n}\n\n/// AMM pool address identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct PoolAddress(pub String);\n\nimpl fmt::Display for PoolAddress {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Token reserves in an AMM pool\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct TokenReserves {\n    /// Reserve amount for token0\n    pub token0: Decimal,\n    /// Reserve amount for token1\n    pub token1: Decimal,\n}\n\nimpl TokenReserves {\n    /// Creates new token reserves with the given amounts\n    pub fn new(token0: Decimal, token1: Decimal) -> Self {\n        Self { token0, token1 }\n    }\n}\n\n/// Square root price for Uniswap V3 style pools\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub struct SqrtPriceX96(pub u128);\n\nimpl SqrtPriceX96 {\n    /// Convert sqrtPriceX96 to regular price\n    pub fn to_price(&self) -> Price {\n        // sqrtPriceX96 = sqrt(price) * 2^96\n        // So price = (sqrtPriceX96 / 2^96)^2\n\n        // Use a safer conversion that handles large numbers better\n        if self.0 == 0 {\n            return Price(Decimal::ZERO);\n        }\n\n        // Convert to f64 for calculation, then back to Decimal\n        let sqrt_price_f64 = self.0 as f64 / (2u128.pow(96) as f64);\n        let price_f64 = sqrt_price_f64 * sqrt_price_f64;\n\n        // Convert back to Decimal safely\n        match Decimal::try_from(price_f64) {\n            Ok(price) => Price(price),\n            Err(_) => Price(Decimal::ZERO), // Fallback for conversion errors\n        }\n    }\n}\n\n/// Fee tier for AMM pools (in basis points)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct FeeTier(pub u32);\n\nimpl FeeTier {\n    /// Convert to decimal (e.g., 30 basis points = 0.003)\n    pub fn to_decimal(&self) -> Decimal {\n        Decimal::from(self.0) / Decimal::from(10000u32)\n    }\n}\n\n/// Timestamp for market events\npub type Timestamp = chrono::DateTime<chrono::Utc>;\n\n/// Trading system errors\n#[derive(Debug, thiserror::Error)]\npub enum TradingError {\n    /// Invalid price value\n    #[error(\"Invalid price: {0}\")]\n    /// Invalid price provided\n    InvalidPrice(String),\n\n    /// Invalid quantity value\n    #[error(\"Invalid quantity: {0}\")]\n    /// Invalid quantity provided\n    InvalidQuantity(String),\n\n    /// Sequence number out of order\n    #[error(\"Sequence out of order: expected {expected}, got {actual}\")]\n    /// Sequence number is out of expected order\n    SequenceOutOfOrder {\n        /// Expected sequence number\n        expected: u64,\n        /// Actual sequence number received\n        actual: u64,\n    },\n\n    /// Insufficient liquidity for trade\n    #[error(\"Insufficient liquidity: {0}\")]\n    /// Insufficient liquidity available for the requested trade\n    InsufficientLiquidity(Decimal),\n\n    /// Parse error\n    #[error(\"Parse error: {0}\")]\n    /// Error parsing data\n    ParseError(String),\n\n    /// IO error\n    #[error(\"IO error: {0}\")]\n    /// Input/output error\n    IoError(#[from] std::io::Error),\n\n    /// Lock error\n    #[error(\"Lock error: {0}\")]\n    /// Error acquiring lock\n    LockError(String),\n\n    /// JSON error\n    #[error(\"JSON error: {0}\")]\n    /// JSON serialization/deserialization error\n    JsonError(#[from] serde_json::Error),\n}\n\n/// Result type for trading operations\npub type TradingResult<T> = Result<T, TradingError>;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_price_ordering() {\n        let p1 = Price(dec!(100.50));\n        let p2 = Price(dec!(100.51));\n        assert!(p1 < p2);\n    }\n\n    #[test]\n    fn test_quantity_operations() {\n        let q1 = Quantity(dec!(10.5));\n        let q2 = Quantity(dec!(5.25));\n        assert!(q1 > q2);\n        assert!(!q1.is_zero());\n        assert!(Quantity::zero().is_zero());\n    }\n\n    #[test]\n    fn test_fee_tier_conversion() {\n        let fee = FeeTier(30); // 30 basis points\n        assert_eq!(fee.to_decimal(), dec!(0.003));\n    }\n\n    #[test]\n    fn test_sqrt_price_conversion() {\n        // Test with a simple case where sqrtPriceX96 represents sqrt(1) = 1\n        let sqrt_price = SqrtPriceX96(2u128.pow(96)); // This represents sqrt(1)\n        let price = sqrt_price.to_price();\n        // Should be approximately 1.0, allowing for some precision loss\n        assert!((price.0 - dec!(1.0)).abs() < dec!(0.1));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":24}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":24}},{"line":44,"address":[],"length":0,"stats":{"Line":24}},{"line":48,"address":[],"length":0,"stats":{"Line":18}},{"line":49,"address":[],"length":0,"stats":{"Line":36}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":42}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":210}},{"line":156,"address":[],"length":0,"stats":{"Line":420}}],"covered":12,"coverable":30},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","ingestion","mod.rs"],"content":"//! Stream ingestion utilities for real-time market data processing\n//!\n//! This module provides components for ingesting and processing real-time market data streams\n//! with comprehensive statistics tracking and error handling.\n\n/// Stream ingestion with statistics and error handling\npub mod stream_ingester;\n\npub use stream_ingester::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","ingestion","stream_ingester.rs"],"content":"use crate::domain::{events::*, market_data::*};\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{error, info};\n\n/// Stream ingester that processes market events concurrently\npub struct StreamIngester {\n    /// Channel receiver for incoming market events\n    receiver: mpsc::Receiver<MarketEvent>,\n    /// Market data manager to process events\n    manager: Arc<MarketDataManager>,\n    /// Buffer size for backpressure handling\n    buffer_size: usize,\n}\n\nimpl StreamIngester {\n    /// Create new stream ingester\n    pub fn new(receiver: mpsc::Receiver<MarketEvent>, manager: Arc<MarketDataManager>) -> Self {\n        Self {\n            receiver,\n            manager,\n            buffer_size: 1000, // Default buffer size\n        }\n    }\n\n    /// Create stream ingester with custom buffer size\n    pub fn with_buffer_size(\n        receiver: mpsc::Receiver<MarketEvent>,\n        manager: Arc<MarketDataManager>,\n        buffer_size: usize,\n    ) -> Self {\n        Self {\n            receiver,\n            manager,\n            buffer_size,\n        }\n    }\n\n    /// Run the ingestion loop\n    pub async fn run(&mut self) {\n        info!(\n            \"Starting stream ingester with buffer size: {}\",\n            self.buffer_size\n        );\n\n        let mut event_count = 0u64;\n        let mut error_count = 0u64;\n\n        while let Some(event) = self.receiver.recv().await {\n            event_count += 1;\n\n            // Process the event\n            if let Err(e) = self.manager.process_event(event.clone()) {\n                error_count += 1;\n                error!(\"Failed to process event: {:?}, error: {}\", event, e);\n\n                // Log error details based on event type\n                match event {\n                    MarketEvent::OrderBookSnapshot(symbol, _) => {\n                        error!(\"Failed to process snapshot for symbol: {}\", symbol);\n                    }\n                    MarketEvent::OrderBookDelta(symbol, delta) => {\n                        error!(\n                            \"Failed to process delta for symbol: {}, seq: {}\",\n                            symbol, delta.sequence\n                        );\n                    }\n                    MarketEvent::Trade(symbol, trade) => {\n                        error!(\n                            \"Failed to process trade for symbol: {}, seq: {}\",\n                            symbol, trade.sequence\n                        );\n                    }\n                    MarketEvent::AMMUpdate(address, _) => {\n                        error!(\"Failed to process AMM update for pool: {}\", address);\n                    }\n                }\n            }\n\n            // Log progress periodically\n            if event_count % 1000 == 0 {\n                info!(\n                    \"Processed {} events, {} errors ({}% error rate)\",\n                    event_count,\n                    error_count,\n                    (error_count as f64 / event_count as f64) * 100.0\n                );\n            }\n        }\n\n        info!(\n            \"Stream ingester finished. Total events: {}, errors: {}\",\n            event_count, error_count\n        );\n    }\n\n    /// Get current buffer size\n    pub fn buffer_size(&self) -> usize {\n        self.buffer_size\n    }\n}\n\n/// Multi-stream ingester that can handle multiple concurrent streams\npub struct MultiStreamIngester {\n    /// Multiple receivers for different data streams\n    receivers: Vec<mpsc::Receiver<MarketEvent>>,\n    /// Market data manager to process events\n    manager: Arc<MarketDataManager>,\n    /// Buffer size per stream\n    buffer_size: usize,\n}\n\nimpl MultiStreamIngester {\n    /// Create new multi-stream ingester\n    pub fn new(\n        receivers: Vec<mpsc::Receiver<MarketEvent>>,\n        manager: Arc<MarketDataManager>,\n    ) -> Self {\n        Self {\n            receivers,\n            manager,\n            buffer_size: 1000,\n        }\n    }\n\n    /// Run all streams concurrently\n    pub async fn run(self) {\n        info!(\n            \"Starting multi-stream ingester with {} streams\",\n            self.receivers.len()\n        );\n\n        let mut handles = Vec::new();\n\n        // Spawn a task for each stream\n        for (stream_id, receiver) in self.receivers.into_iter().enumerate() {\n            let manager = Arc::clone(&self.manager);\n            let buffer_size = self.buffer_size;\n\n            let handle = tokio::spawn(async move {\n                let mut ingester = StreamIngester::with_buffer_size(receiver, manager, buffer_size);\n                info!(\"Starting stream {} ingestion\", stream_id);\n                ingester.run().await;\n                info!(\"Stream {} ingestion completed\", stream_id);\n            });\n\n            handles.push(handle);\n        }\n\n        // Wait for all streams to complete\n        for (stream_id, handle) in handles.into_iter().enumerate() {\n            if let Err(e) = handle.await {\n                error!(\"Stream {} failed: {}\", stream_id, e);\n            }\n        }\n\n        info!(\"All streams completed\");\n    }\n}\n\n/// Event statistics for stream ingestion performance\n#[derive(Debug, Clone, Default)]\npub struct IngestionStats {\n    /// Total number of events processed\n    pub total_events: u64,\n    /// Number of successfully processed events\n    pub successful_events: u64,\n    /// Number of events that failed processing\n    pub failed_events: u64,\n    /// Current processing rate in events per second\n    pub events_per_second: f64,\n    /// Timestamp of the last processed event\n    pub last_event_timestamp: Option<chrono::DateTime<chrono::Utc>>,\n    /// Timestamp when ingestion started\n    pub start_time: chrono::DateTime<chrono::Utc>,\n}\n\nimpl IngestionStats {\n    /// Creates new ingestion statistics\n    pub fn new() -> Self {\n        Self {\n            start_time: chrono::Utc::now(),\n            ..Default::default()\n        }\n    }\n\n    /// Records an event and updates statistics\n    pub fn record_event(&mut self, success: bool) {\n        self.total_events += 1;\n        self.last_event_timestamp = Some(chrono::Utc::now());\n\n        if success {\n            self.successful_events += 1;\n        } else {\n            self.failed_events += 1;\n        }\n    }\n\n    /// Calculates the success rate as a percentage\n    pub fn success_rate(&self) -> f64 {\n        if self.total_events > 0 {\n            (self.successful_events as f64 / self.total_events as f64) * 100.0\n        } else {\n            0.0\n        }\n    }\n\n    /// Calculates the error rate as a percentage\n    pub fn error_rate(&self) -> f64 {\n        if self.total_events > 0 {\n            (self.failed_events as f64 / self.total_events as f64) * 100.0\n        } else {\n            0.0\n        }\n    }\n}\n\n/// Stream ingester with detailed statistics tracking\npub struct StatisticalStreamIngester {\n    receiver: mpsc::Receiver<MarketEvent>,\n    manager: Arc<MarketDataManager>,\n    stats: IngestionStats,\n    report_interval: u64,\n}\n\nimpl StatisticalStreamIngester {\n    /// Creates a new stream ingester with the given receiver and market data manager\n    pub fn new(receiver: mpsc::Receiver<MarketEvent>, manager: Arc<MarketDataManager>) -> Self {\n        Self {\n            receiver,\n            manager,\n            stats: IngestionStats::new(),\n            report_interval: 1000, // Report every 1000 events\n        }\n    }\n\n    /// Runs the statistical stream ingester, processing events and reporting statistics\n    pub async fn run(&mut self) {\n        info!(\"Starting statistical stream ingester\");\n\n        while let Some(event) = self.receiver.recv().await {\n            // Process the event\n            let success = self.manager.process_event(event.clone()).is_ok();\n            self.stats.record_event(success);\n\n            if !success {\n                error!(\"Failed to process event: {:?}\", event);\n            }\n\n            // Report statistics periodically\n            if self.stats.total_events % self.report_interval == 0 {\n                self.report_stats();\n            }\n        }\n\n        // Final report\n        self.report_stats();\n        info!(\"Statistical stream ingester finished\");\n    }\n\n    fn report_stats(&self) {\n        info!(\n            \"Stats - Total: {}, Successful: {}, Failed: {}, Success Rate: {:.2}%, Error Rate: {:.2}%\",\n            self.stats.total_events,\n            self.stats.successful_events,\n            self.stats.failed_events,\n            self.stats.success_rate(),\n            self.stats.error_rate()\n        );\n    }\n\n    /// Returns the current ingestion statistics\n    pub fn get_stats(&self) -> &IngestionStats {\n        &self.stats\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::types::*;\n    use rust_decimal_macros::dec;\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn test_stream_ingester_basic() {\n        let manager = Arc::new(MarketDataManager::new());\n        let (tx, rx) = mpsc::channel(10);\n        let mut ingester = StreamIngester::new(rx, manager.clone());\n\n        // Send a test event\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n\n        tx.send(event).await.unwrap();\n        drop(tx); // Close the channel\n\n        // Run ingester\n        ingester.run().await;\n\n        // Verify event was processed\n        assert!(manager.get_orderbook(&symbol).is_some());\n    }\n\n    #[tokio::test]\n    async fn test_multi_stream_ingester() {\n        let manager = Arc::new(MarketDataManager::new());\n\n        // Create multiple streams\n        let (tx1, rx1) = mpsc::channel(10);\n        let (tx2, rx2) = mpsc::channel(10);\n\n        let multi_ingester = MultiStreamIngester::new(vec![rx1, rx2], manager.clone());\n\n        // Send events to both streams\n        let symbol1 = Symbol(\"ETHUSDC\".to_string());\n        let symbol2 = Symbol(\"BTCUSDC\".to_string());\n\n        let snapshot1 = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let snapshot2 = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n\n        tx1.send(MarketEvent::OrderBookSnapshot(symbol1.clone(), snapshot1))\n            .await\n            .unwrap();\n        tx2.send(MarketEvent::OrderBookSnapshot(symbol2.clone(), snapshot2))\n            .await\n            .unwrap();\n\n        drop(tx1);\n        drop(tx2);\n\n        // Run multi-stream ingester\n        multi_ingester.run().await;\n\n        // Verify both events were processed\n        assert!(manager.get_orderbook(&symbol1).is_some());\n        assert!(manager.get_orderbook(&symbol2).is_some());\n    }\n\n    #[tokio::test]\n    async fn test_ingestion_stats() {\n        let manager = Arc::new(MarketDataManager::new());\n        let (tx, rx) = mpsc::channel(10);\n        let mut ingester = StatisticalStreamIngester::new(rx, manager);\n\n        // Send multiple events\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        // Snapshot\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        tx.send(MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot))\n            .await\n            .unwrap();\n\n        // Delta\n        let delta = OrderBookDelta::new(SequenceNumber(2), chrono::Utc::now());\n        tx.send(MarketEvent::OrderBookDelta(symbol.clone(), delta))\n            .await\n            .unwrap();\n\n        // Trade\n        let trade = Trade::new(\n            SequenceNumber(3),\n            chrono::Utc::now(),\n            Price(dec!(2445.0)),\n            Quantity(dec!(1.0)),\n            Side::Bid,\n        );\n        tx.send(MarketEvent::Trade(symbol, trade)).await.unwrap();\n\n        drop(tx);\n\n        // Run ingester\n        ingester.run().await;\n\n        // Check stats\n        let stats = ingester.get_stats();\n        assert_eq!(stats.total_events, 3);\n        assert_eq!(stats.successful_events, 3);\n        assert_eq!(stats.failed_events, 0);\n    }\n\n    #[test]\n    fn test_ingestion_stats_calculations() {\n        let mut stats = IngestionStats::new();\n\n        // Simulate some events\n\n        for _ in 0..8 {\n            stats.record_event(true);\n        }\n\n        // Record some failures\n        stats.record_event(false);\n        stats.record_event(false);\n\n        assert_eq!(stats.total_events, 10);\n        assert_eq!(stats.failed_events, 2);\n        assert_eq!(stats.error_rate(), 20.0); // 2/10 * 100 = 20%\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":16}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":49,"address":[],"length":0,"stats":{"Line":72}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":26}},{"line":189,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":26}},{"line":192,"address":[],"length":0,"stats":{"Line":48}},{"line":193,"address":[],"length":0,"stats":{"Line":22}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":4}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":30}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":2}}],"covered":42,"coverable":86},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","collector.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::{Arc, RwLock};\n\n/// Performance metrics collector for system performance monitoring\n#[derive(Debug, Default)]\npub struct MetricsCollector {\n    counters: Arc<RwLock<HashMap<String, AtomicU64>>>,\n    gauges: Arc<RwLock<HashMap<String, AtomicU64>>>,\n}\n\nimpl MetricsCollector {\n    /// Creates a new metrics collector\n    pub fn new() -> Self {\n        Self {\n            counters: Arc::new(RwLock::new(HashMap::new())),\n            gauges: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Increments a named counter by 1\n    pub fn increment_counter(&self, name: &str) {\n        if let Some(counter) = self.counters.read().unwrap().get(name) {\n            counter.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    /// Sets a gauge to a specific value\n    pub fn set_gauge(&self, name: &str, value: u64) {\n        if let Some(gauge) = self.gauges.read().unwrap().get(name) {\n            gauge.store(value, Ordering::Relaxed);\n        }\n    }\n\n    /// Gets the current value of a counter\n    pub fn get_counter(&self, name: &str) -> u64 {\n        self.counters\n            .read()\n            .unwrap()\n            .get(name)\n            .map(|c| c.load(Ordering::Relaxed))\n            .unwrap_or(0)\n    }\n\n    /// Gets the current value of a gauge\n    pub fn get_gauge(&self, name: &str) -> u64 {\n        self.gauges\n            .read()\n            .unwrap()\n            .get(name)\n            .map(|g| g.load(Ordering::Relaxed))\n            .unwrap_or(0)\n    }\n}\n\n/// System-wide performance metrics snapshot\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SystemMetrics {\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Total number of events processed\n    pub total_events_processed: u64,\n    /// Current events processing rate per second\n    pub events_per_second: f64,\n    /// Memory usage in megabytes\n    pub memory_usage_mb: u64,\n    /// CPU usage as a percentage\n    pub cpu_usage_percent: f64,\n    /// Number of active connections\n    pub active_connections: u64,\n}\n\nimpl SystemMetrics {\n    /// Creates a new system metrics snapshot with default values\n    pub fn new() -> Self {\n        Self {\n            uptime_seconds: 0,\n            total_events_processed: 0,\n            events_per_second: 0.0,\n            memory_usage_mb: 0,\n            cpu_usage_percent: 0.0,\n            active_connections: 0,\n        }\n    }\n}\n\nimpl Default for SystemMetrics {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_metrics_collector() {\n        let collector = MetricsCollector::new();\n\n        // Test counter operations\n        collector.increment_counter(\"test_counter\");\n        assert_eq!(collector.get_counter(\"test_counter\"), 0); // No counter registered\n\n        // Test gauge operations\n        collector.set_gauge(\"test_gauge\", 42);\n        assert_eq!(collector.get_gauge(\"test_gauge\"), 0); // No gauge registered\n\n        // Test non-existent metrics\n        assert_eq!(collector.get_counter(\"non_existent\"), 0);\n        assert_eq!(collector.get_gauge(\"non_existent\"), 0);\n    }\n\n    #[test]\n    fn test_system_metrics() {\n        let metrics = SystemMetrics::new();\n        assert_eq!(metrics.uptime_seconds, 0);\n        assert_eq!(metrics.total_events_processed, 0);\n        assert_eq!(metrics.events_per_second, 0.0);\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":18},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","exporter.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse tokio::time::{Duration, Instant};\n\n/// Metrics exporter for external monitoring systems\n#[derive(Debug, Clone)]\npub struct MetricsExporter {\n    start_time: Instant,\n    export_interval: Duration,\n}\n\nimpl MetricsExporter {\n    /// Creates a new metrics exporter with specified export interval\n    pub fn new(export_interval: Duration) -> Self {\n        Self {\n            start_time: Instant::now(),\n            export_interval,\n        }\n    }\n\n    /// Returns the uptime since exporter creation\n    pub fn uptime(&self) -> Duration {\n        self.start_time.elapsed()\n    }\n\n    /// Returns the configured export interval\n    pub fn export_interval(&self) -> Duration {\n        self.export_interval\n    }\n\n    /// Export metrics in Prometheus format\n    pub fn export_prometheus(&self, metrics: &HashMap<String, f64>) -> String {\n        let mut output = String::new();\n\n        for (name, value) in metrics {\n            output.push_str(&format!(\"# TYPE {} gauge\\n\", name));\n            output.push_str(&format!(\"{} {}\\n\", name, value));\n        }\n\n        output\n    }\n\n    /// Export metrics in JSON format\n    pub fn export_json(&self, metrics: &HashMap<String, f64>) -> Result<String, serde_json::Error> {\n        let export_data = MetricsExport {\n            timestamp: chrono::Utc::now(),\n            uptime_seconds: self.uptime().as_secs(),\n            metrics: metrics.clone(),\n        };\n\n        serde_json::to_string_pretty(&export_data)\n    }\n}\n\nimpl Default for MetricsExporter {\n    fn default() -> Self {\n        Self::new(Duration::from_secs(60))\n    }\n}\n\n/// Metrics export data structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsExport {\n    /// Timestamp when metrics were exported\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Map of metric names to values\n    pub metrics: HashMap<String, f64>,\n}\n\n/// Health status information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HealthStatus {\n    /// Overall system status\n    pub status: String,\n    /// System version\n    pub version: String,\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Timestamp of health check\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    /// Health status of individual components\n    pub components: HashMap<String, ComponentHealth>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n/// Health status of an individual system component\npub struct ComponentHealth {\n    /// Component status (healthy/unhealthy)\n    pub status: String,\n    /// Timestamp of last health check\n    pub last_check: chrono::DateTime<chrono::Utc>,\n    /// Optional details about component status\n    pub details: Option<String>,\n}\n\nimpl HealthStatus {\n    /// Creates a new health status with the given version and uptime\n    pub fn new(version: &str, uptime: Duration) -> Self {\n        Self {\n            status: \"healthy\".to_string(),\n            version: version.to_string(),\n            uptime_seconds: uptime.as_secs(),\n            timestamp: chrono::Utc::now(),\n            components: HashMap::new(),\n        }\n    }\n\n    /// Adds a component health status\n    pub fn add_component(&mut self, name: String, health: ComponentHealth) {\n        self.components.insert(name, health);\n    }\n\n    /// Returns true if all components are healthy\n    pub fn is_healthy(&self) -> bool {\n        self.status == \"healthy\" && self.components.values().all(|c| c.status == \"healthy\")\n    }\n}\n\nimpl ComponentHealth {\n    /// Creates a healthy component status\n    pub fn healthy() -> Self {\n        Self {\n            status: \"healthy\".to_string(),\n            last_check: chrono::Utc::now(),\n            details: None,\n        }\n    }\n\n    /// Creates an unhealthy component status with details\n    pub fn unhealthy(details: String) -> Self {\n        Self {\n            status: \"unhealthy\".to_string(),\n            last_check: chrono::Utc::now(),\n            details: Some(details),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_metrics_exporter() {\n        let exporter = MetricsExporter::new(Duration::from_secs(30));\n        assert_eq!(exporter.export_interval(), Duration::from_secs(30));\n        // Just verify uptime is available\n        let _uptime = exporter.uptime();\n    }\n\n    #[test]\n    fn test_prometheus_export() {\n        let exporter = MetricsExporter::default();\n        let mut metrics = HashMap::new();\n        metrics.insert(\"test_metric\".to_string(), 42.0);\n        metrics.insert(\"another_metric\".to_string(), std::f64::consts::PI);\n\n        let prometheus_output = exporter.export_prometheus(&metrics);\n        assert!(prometheus_output.contains(\"# TYPE test_metric gauge\"));\n        assert!(prometheus_output.contains(\"test_metric 42\"));\n        assert!(prometheus_output.contains(\"another_metric 3.14\"));\n    }\n\n    #[test]\n    fn test_json_export() {\n        let exporter = MetricsExporter::default();\n        let mut metrics = HashMap::new();\n        metrics.insert(\"test_metric\".to_string(), 42.0);\n\n        let json_output = exporter.export_json(&metrics).unwrap();\n        assert!(json_output.contains(\"test_metric\"));\n        assert!(json_output.contains(\"42\"));\n        assert!(json_output.contains(\"timestamp\"));\n        assert!(json_output.contains(\"uptime_seconds\"));\n    }\n\n    #[test]\n    fn test_health_status() {\n        let mut health = HealthStatus::new(\"1.0.0\", Duration::from_secs(3600));\n        assert_eq!(health.status, \"healthy\");\n        assert_eq!(health.version, \"1.0.0\");\n        assert_eq!(health.uptime_seconds, 3600);\n        assert!(health.is_healthy());\n\n        health.add_component(\"orderbook\".to_string(), ComponentHealth::healthy());\n        assert!(health.is_healthy());\n\n        health.add_component(\n            \"amm\".to_string(),\n            ComponentHealth::unhealthy(\"Connection lost\".to_string()),\n        );\n        assert!(!health.is_healthy());\n    }\n\n    #[test]\n    fn test_component_health() {\n        let healthy = ComponentHealth::healthy();\n        assert_eq!(healthy.status, \"healthy\");\n        assert!(healthy.details.is_none());\n\n        let unhealthy = ComponentHealth::unhealthy(\"Database connection failed\".to_string());\n        assert_eq!(unhealthy.status, \"unhealthy\");\n        assert_eq!(\n            unhealthy.details,\n            Some(\"Database connection failed\".to_string())\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":16}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":12}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}}],"covered":34,"coverable":34},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","mod.rs"],"content":"//! Metrics collection and export functionality\n//!\n//! This module provides comprehensive metrics collection, aggregation, and export capabilities\n//! for monitoring system performance and health.\n\n/// Metrics collection utilities\npub mod collector;\n/// Metrics export and health monitoring\npub mod exporter;\n\npub use collector::*;\npub use exporter::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","mod.rs"],"content":"//! Infrastructure layer providing data ingestion, metrics, and parsing capabilities\n//!\n//! This module contains the infrastructure components that support the domain layer,\n//! including stream ingestion, metrics collection, and data parsing utilities.\n\n/// Stream ingestion utilities for real-time market data\npub mod ingestion;\n/// Metrics collection and export functionality\npub mod metrics;\n/// Data parsing utilities for various market data formats\npub mod parsers;\n\npub use ingestion::*;\npub use parsers::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","parsers","json_parser.rs"],"content":"use crate::domain::{events::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::Deserialize;\nuse std::collections::BTreeMap;\nuse std::str::FromStr;\n\n/// Raw JSON structures for parsing the provided data files\n/// Raw order book snapshot from JSON\n#[derive(Debug, Deserialize)]\nstruct RawOrderBookSnapshot {\n    #[serde(rename = \"type\")]\n    event_type: String,\n    symbol: String,\n    seq: u64,\n    ts: String,\n    bids: Vec<Vec<String>>,\n    asks: Vec<Vec<String>>,\n}\n\n/// Raw order book delta from JSON\n#[derive(Debug, Deserialize)]\nstruct RawOrderBookDelta {\n    #[serde(rename = \"type\")]\n    event_type: String,\n    symbol: String,\n    seq: u64,\n    ts: String,\n    bids: Vec<Vec<String>>,\n    asks: Vec<Vec<String>>,\n}\n\n/// Raw AMM pool from JSON\n#[derive(Debug, Deserialize)]\nstruct RawAMMPool {\n    pool: String,\n    fee: u32,\n    ts: String,\n    reserves: RawReserves,\n    #[serde(rename = \"sqrtPriceX96\")]\n    sqrt_price_x96: Option<String>,\n}\n\n/// Raw reserves from JSON\n#[derive(Debug, Deserialize)]\nstruct RawReserves {\n    amount0: String,\n    amount1: String,\n}\n\n/// Parse order book snapshot from JSON string\npub fn parse_lob_snapshot(json_str: &str) -> TradingResult<(Symbol, OrderBookSnapshot)> {\n    let raw: RawOrderBookSnapshot = serde_json::from_str(json_str)?;\n\n    if raw.event_type != \"snapshot\" {\n        return Err(TradingError::ParseError(format!(\n            \"Expected snapshot type, got: {}\",\n            raw.event_type\n        )));\n    }\n\n    let symbol = Symbol(raw.symbol);\n    let sequence = SequenceNumber(raw.seq);\n    let timestamp = parse_timestamp(&raw.ts)?;\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n\n    // Parse bids (price, quantity pairs)\n    for bid in raw.bids {\n        if bid.len() != 2 {\n            return Err(TradingError::ParseError(\"Invalid bid format\".to_string()));\n        }\n        let price = Price(\n            Decimal::from_str(&bid[0])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid price: {}\", e)))?,\n        );\n        let quantity = Quantity(\n            Decimal::from_str(&bid[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid quantity: {}\", e)))?,\n        );\n        bids.insert(price, quantity);\n    }\n\n    // Parse asks (price, quantity pairs)\n    for ask in raw.asks {\n        if ask.len() != 2 {\n            return Err(TradingError::ParseError(\"Invalid ask format\".to_string()));\n        }\n        let price = Price(\n            Decimal::from_str(&ask[0])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask price: {}\", e)))?,\n        );\n        let quantity = Quantity(\n            Decimal::from_str(&ask[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask quantity: {}\", e)))?,\n        );\n        asks.insert(price, quantity);\n    }\n\n    let snapshot = OrderBookSnapshot::with_levels(sequence, timestamp, bids, asks);\n    Ok((symbol, snapshot))\n}\n\n/// Parse order book delta from JSON string\npub fn parse_lob_delta(json_str: &str) -> TradingResult<(Symbol, OrderBookDelta)> {\n    let raw: RawOrderBookDelta = serde_json::from_str(json_str)?;\n\n    if raw.event_type != \"delta\" {\n        return Err(TradingError::ParseError(format!(\n            \"Expected delta type, got: {}\",\n            raw.event_type\n        )));\n    }\n\n    let symbol = Symbol(raw.symbol);\n    let sequence = SequenceNumber(raw.seq);\n    let timestamp = parse_timestamp(&raw.ts)?;\n\n    let mut updates = Vec::new();\n\n    // Parse bid updates (action, price, quantity)\n    for bid in raw.bids {\n        if bid.len() != 3 {\n            return Err(TradingError::ParseError(\n                \"Invalid bid delta format\".to_string(),\n            ));\n        }\n\n        let action = match bid[0].as_str() {\n            \"u\" => UpdateAction::Update,\n            \"d\" => UpdateAction::Delete,\n            \"n\" => UpdateAction::Update, // New level is same as update\n            _ => {\n                return Err(TradingError::ParseError(format!(\n                    \"Invalid bid action: {}\",\n                    bid[0]\n                )))\n            }\n        };\n\n        let price = Price(\n            Decimal::from_str(&bid[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid price: {}\", e)))?,\n        );\n\n        let quantity =\n            if action == UpdateAction::Delete {\n                Quantity::zero()\n            } else {\n                Quantity(Decimal::from_str(&bid[2]).map_err(|e| {\n                    TradingError::ParseError(format!(\"Invalid bid quantity: {}\", e))\n                })?)\n            };\n\n        updates.push(PriceLevelUpdate::new(Side::Bid, price, quantity, action));\n    }\n\n    // Parse ask updates (action, price, quantity)\n    for ask in raw.asks {\n        if ask.len() != 3 {\n            return Err(TradingError::ParseError(\n                \"Invalid ask delta format\".to_string(),\n            ));\n        }\n\n        let action = match ask[0].as_str() {\n            \"u\" => UpdateAction::Update,\n            \"d\" => UpdateAction::Delete,\n            \"n\" => UpdateAction::Update, // New level is same as update\n            _ => {\n                return Err(TradingError::ParseError(format!(\n                    \"Invalid ask action: {}\",\n                    ask[0]\n                )))\n            }\n        };\n\n        let price = Price(\n            Decimal::from_str(&ask[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask price: {}\", e)))?,\n        );\n\n        let quantity =\n            if action == UpdateAction::Delete {\n                Quantity::zero()\n            } else {\n                Quantity(Decimal::from_str(&ask[2]).map_err(|e| {\n                    TradingError::ParseError(format!(\"Invalid ask quantity: {}\", e))\n                })?)\n            };\n\n        updates.push(PriceLevelUpdate::new(Side::Ask, price, quantity, action));\n    }\n\n    let delta = OrderBookDelta::with_updates(sequence, timestamp, updates);\n    Ok((symbol, delta))\n}\n\n/// Parse AMM pool data from JSON string\npub fn parse_amm_pool(json_str: &str) -> TradingResult<(PoolAddress, AMMPoolUpdate)> {\n    let raw: RawAMMPool = serde_json::from_str(json_str)?;\n\n    let address = PoolAddress(raw.pool);\n    let timestamp = parse_timestamp(&raw.ts)?;\n    let fee_tier = FeeTier(raw.fee);\n\n    let token0_reserve = Decimal::from_str(&raw.reserves.amount0)\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid token0 reserve: {}\", e)))?;\n    let token1_reserve = Decimal::from_str(&raw.reserves.amount1)\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid token1 reserve: {}\", e)))?;\n    let reserves = TokenReserves::new(token0_reserve, token1_reserve);\n\n    // Parse sqrt price if available\n    let sqrt_price = if let Some(sqrt_price_str) = raw.sqrt_price_x96 {\n        let sqrt_price_u128 = u128::from_str(&sqrt_price_str)\n            .map_err(|e| TradingError::ParseError(format!(\"Invalid sqrtPriceX96: {}\", e)))?;\n        Some(SqrtPriceX96(sqrt_price_u128))\n    } else {\n        None\n    };\n\n    let update = AMMPoolUpdate::new(timestamp, reserves, sqrt_price, fee_tier);\n    Ok((address, update))\n}\n\n/// Parse timestamp from ISO 8601 string\nfn parse_timestamp(ts_str: &str) -> TradingResult<Timestamp> {\n    chrono::DateTime::parse_from_rfc3339(ts_str)\n        .map(|dt| dt.with_timezone(&chrono::Utc))\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid timestamp: {}\", e)))\n}\n\n/// Load and parse order book snapshot from file\npub fn load_lob_snapshot(file_path: &str) -> TradingResult<(Symbol, OrderBookSnapshot)> {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_lob_snapshot(&content)\n}\n\n/// Load and parse order book delta from file\npub fn load_lob_delta(file_path: &str) -> TradingResult<(Symbol, OrderBookDelta)> {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_lob_delta(&content)\n}\n\n/// Load and parse AMM pool from file\npub fn load_amm_pool(file_path: &str) -> TradingResult<(PoolAddress, AMMPoolUpdate)> {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_amm_pool(&content)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_parse_lob_snapshot() {\n        let json = r#\"{\n            \"type\": \"snapshot\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1000,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"bids\": [\n                [\"2445.12\", \"3.1005\"],\n                [\"2445.11\", \"1.20\"]\n            ],\n            \"asks\": [\n                [\"2445.13\", \"2.05\"],\n                [\"2445.14\", \"1.50\"]\n            ]\n        }\"#;\n\n        let (symbol, snapshot) = parse_lob_snapshot(json).unwrap();\n\n        assert_eq!(symbol, Symbol(\"ETHUSDC\".to_string()));\n        assert_eq!(snapshot.sequence, SequenceNumber(1000));\n        assert_eq!(snapshot.bids.len(), 2);\n        assert_eq!(snapshot.asks.len(), 2);\n\n        // Check best bid and ask\n        assert_eq!(snapshot.best_bid(), Some(&Price(dec!(2445.12))));\n        assert_eq!(snapshot.best_ask(), Some(&Price(dec!(2445.13))));\n    }\n\n    #[test]\n    fn test_parse_lob_delta() {\n        let json = r#\"{\n            \"type\": \"delta\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1001,\n            \"ts\": \"2025-01-01T10:00:00.050Z\",\n            \"bids\": [\n                [\"u\", \"2445.12\", \"3.0000\"]\n            ],\n            \"asks\": [\n                [\"n\", \"2445.15\", \"1.00\"]\n            ]\n        }\"#;\n\n        let (symbol, delta) = parse_lob_delta(json).unwrap();\n\n        assert_eq!(symbol, Symbol(\"ETHUSDC\".to_string()));\n        assert_eq!(delta.sequence, SequenceNumber(1001));\n        assert_eq!(delta.updates.len(), 2);\n\n        // Check updates\n        let bid_update = &delta.updates[0];\n        assert_eq!(bid_update.side, Side::Bid);\n        assert_eq!(bid_update.price, Price(dec!(2445.12)));\n        assert_eq!(bid_update.quantity, Quantity(dec!(3.0000)));\n        assert_eq!(bid_update.action, UpdateAction::Update);\n\n        let ask_update = &delta.updates[1];\n        assert_eq!(ask_update.side, Side::Ask);\n        assert_eq!(ask_update.price, Price(dec!(2445.15)));\n        assert_eq!(ask_update.quantity, Quantity(dec!(1.00)));\n        assert_eq!(ask_update.action, UpdateAction::Update);\n    }\n\n    #[test]\n    fn test_parse_amm_pool() {\n        let json = r#\"{\n            \"pool\": \"0xPOOL\",\n            \"venue\": \"uniswap_v3\",\n            \"pair\": \"WETH/USDC\",\n            \"fee\": 5,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"reserves\": {\n                \"token0\": \"WETH\",\n                \"token1\": \"USDC\",\n                \"amount0\": \"1000.0000\",\n                \"amount1\": \"2445000.00\"\n            },\n            \"sqrtPriceX96\": \"79228162514264337593543950336\"\n        }\"#;\n\n        let (address, update) = parse_amm_pool(json).unwrap();\n\n        assert_eq!(address, PoolAddress(\"0xPOOL\".to_string()));\n        assert_eq!(update.fee_tier, FeeTier(5));\n        assert_eq!(update.reserves.token0, dec!(1000.0000));\n        assert_eq!(update.reserves.token1, dec!(2445000.00));\n        assert!(update.sqrt_price.is_some());\n\n        // Check implied price from reserves\n        let implied_price = update.implied_mid_from_reserves();\n        assert_eq!(implied_price, Price(dec!(2445.0))); // 2445000 / 1000\n    }\n\n    #[test]\n    fn test_parse_delta_delete_action() {\n        let json = r#\"{\n            \"type\": \"delta\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1002,\n            \"ts\": \"2025-01-01T10:00:00.100Z\",\n            \"bids\": [\n                [\"d\", \"2445.11\", \"0\"]\n            ],\n            \"asks\": []\n        }\"#;\n\n        let (_, delta) = parse_lob_delta(json).unwrap();\n\n        assert_eq!(delta.updates.len(), 1);\n        let update = &delta.updates[0];\n        assert_eq!(update.action, UpdateAction::Delete);\n        assert!(update.quantity.is_zero());\n    }\n\n    #[test]\n    fn test_invalid_json_format() {\n        let json = r#\"{\"invalid\": \"format\"}\"#;\n        let result = parse_lob_snapshot(json);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_decimal_parsing() {\n        let json = r#\"{\n            \"type\": \"snapshot\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1000,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"bids\": [\n                [\"invalid_price\", \"3.1005\"]\n            ],\n            \"asks\": []\n        }\"#;\n\n        let result = parse_lob_snapshot(json);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Invalid bid price\"));\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":24}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":24}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":18}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":18}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":228,"address":[],"length":0,"stats":{"Line":32}},{"line":229,"address":[],"length":0,"stats":{"Line":64}},{"line":230,"address":[],"length":0,"stats":{"Line":16}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":6}}],"covered":45,"coverable":77},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","parsers","mod.rs"],"content":"//! JSON parsing utilities for market data\n//!\n//! This module provides parsers for converting JSON market data into domain types.\n\n/// JSON parser for market data formats\npub mod json_parser;\n\npub use json_parser::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","lib.rs"],"content":"//! # Quant Trading System\n//!\n//! A high-performance, thread-safe quantitative trading system implementing:\n//! - CLOB (Central Limit Order Book) L2 order books with fast top-of-book access\n//! - AMM (Automated Market Maker) pools with price impact calculations\n//! - Real-time arbitrage detection between venues\n//! - Concurrent stream ingestion with backpressure handling\n//! - JSON parsing for market data feeds\n//!\n//! ## Architecture\n//!\n//! The system follows domain-driven design principles with clear separation of concerns:\n//!\n//! - **Domain**: Core business logic (order books, AMM pools, arbitrage detection)\n//! - **Infrastructure**: External concerns (JSON parsing, stream ingestion, metrics)\n//! - **Application**: Use cases and orchestration\n//!\n//! ## Thread Safety\n//!\n//! All data structures use `std::sync::RwLock` for concurrent access:\n//! - Multiple concurrent readers\n//! - Single writer exclusion\n//! - Atomic snapshots without blocking writers\n//!\n//! ## Performance Characteristics\n//!\n//! - **Latency**: Sub-microsecond order book operations\n//! - **Throughput**: 1M+ updates/second per symbol\n//! - **Memory**: O(n) where n = number of price levels\n//! - **Concurrency**: Lock-free reads, minimal write contention\n\npub mod domain;\npub mod infrastructure;\n\n// Re-export commonly used types for convenience\npub use domain::{\n    amm_pool::{AMMPool, AMMPoolType, PriceImpactResult, ThreadSafeAMMPool, TokenIndex},\n    arbitrage::{ArbitrageDetector, ArbitrageOpportunity, Venue},\n    events::*,\n    market_data::{MarketDataManager, MarketMetrics},\n    order_book::{OrderBookL2, ThreadSafeOrderBook},\n    types::*,\n};\n\npub use infrastructure::{\n    ingestion::{IngestionStats, MultiStreamIngester, StatisticalStreamIngester, StreamIngester},\n    parsers::{\n        load_amm_pool, load_lob_delta, load_lob_snapshot, parse_amm_pool, parse_lob_delta,\n        parse_lob_snapshot,\n    },\n};\n\n/// Main result type for the trading system\npub type Result<T> = std::result::Result<T, TradingError>;\n\n/// Version information\npub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n    use std::sync::Arc;\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn test_full_system_integration() {\n        // Initialize logging for tests\n        let _ = tracing_subscriber::fmt::try_init();\n\n        // Create market data manager\n        let manager = Arc::new(MarketDataManager::new());\n\n        // Create stream ingester\n        let (tx, rx) = mpsc::channel(1000);\n        let mut ingester = StreamIngester::new(rx, manager.clone());\n\n        // Load and send initial data\n        let snapshot_result = load_lob_snapshot(\"data/LOB_snapshot.json\");\n        if let Ok((symbol, snapshot)) = snapshot_result {\n            let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n            tx.send(event).await.unwrap();\n        }\n\n        let delta_result = load_lob_delta(\"data/LOB_delta.json\");\n        if let Ok((symbol, delta)) = delta_result {\n            let event = MarketEvent::OrderBookDelta(symbol, delta);\n            tx.send(event).await.unwrap();\n        }\n\n        let amm_result = load_amm_pool(\"data/amm_pool.json\");\n        if let Ok((address, update)) = amm_result {\n            let event = MarketEvent::AMMUpdate(address, update);\n            tx.send(event).await.unwrap();\n        }\n\n        // Close sender\n        drop(tx);\n\n        // Run ingester\n        tokio::spawn(async move {\n            ingester.run().await;\n        });\n\n        // Give some time for processing\n        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n        // Test arbitrage detection if we have both order book and AMM data\n        let symbols = manager.get_orderbook_symbols();\n        let pools = manager.get_amm_pool_addresses();\n\n        if !symbols.is_empty() && !pools.is_empty() {\n            let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n\n            if let (Some(book), Some(pool)) = (\n                manager.get_orderbook(&symbols[0]),\n                manager.get_amm_pool(&pools[0]),\n            ) {\n                let opportunity = detector.check_arbitrage(&book, &pool);\n                // Arbitrage opportunity may or may not exist depending on the data\n                println!(\"Arbitrage opportunity: {:?}\", opportunity);\n            }\n        }\n\n        // Get final metrics\n        let metrics = manager.get_market_metrics();\n        println!(\n            \"Final metrics: {} order books, {} AMM pools\",\n            metrics.orderbook_metrics.len(),\n            metrics.amm_metrics.len()\n        );\n    }\n\n    #[test]\n    fn test_order_book_operations() {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Create test snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2445.12)), Quantity(dec!(3.1005)));\n        snapshot\n            .bids\n            .insert(Price(dec!(2445.11)), Quantity(dec!(1.20)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2445.13)), Quantity(dec!(2.05)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2445.14)), Quantity(dec!(1.50)));\n\n        // Apply snapshot\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test basic operations\n        assert_eq!(book.best_bid(), Some(Price(dec!(2445.12))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(2445.13))));\n        assert_eq!(book.mid_price(), Some(Price(dec!(2445.125))));\n        assert_eq!(book.spread(), Some(Price(dec!(0.01))));\n\n        // Test depth calculation\n        let bid_depth = book.depth_to_price(Side::Bid, Price(dec!(2445.11)));\n        assert_eq!(bid_depth, Quantity(dec!(4.3005))); // 3.1005 + 1.20\n    }\n\n    #[test]\n    fn test_amm_pool_operations() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2445000.0));\n        let pool = ThreadSafeAMMPool::new_v2(\n            PoolAddress(\"0xTEST\".to_string()),\n            reserves,\n            FeeTier(30), // 0.3%\n        );\n\n        // Test basic operations\n        assert_eq!(pool.implied_mid(), Price(dec!(2445.0)));\n        assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n\n        // Test price impact calculation\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(10.0))\n            .unwrap();\n\n        // Should have some price impact and fee\n        assert!(result.price_impact_percent > dec!(0.0));\n        assert_eq!(result.fee_amount, dec!(0.03)); // 0.3% of 10.0\n        assert!(result.output_amount > dec!(0.0));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","main.rs"],"content":"//! # Quant Trading System\n//!\n//! A high-performance quantitative trading system with real-time market data processing,\n//! order book management, AMM pool integration, and arbitrage detection.\n//!\n//! This binary provides an example entry point that demonstrates the full system capabilities\n//! including market data ingestion, real-time processing, arbitrage monitoring, and metrics API.\n\nuse quant_trading_system::*;\nuse rust_decimal_macros::dec;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{error, info};\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // Initialize tracing/logging\n    tracing_subscriber::fmt::init();\n\n    info!(\" Starting Quant Trading System v{}\", VERSION);\n    info!(\" Initializing system components...\");\n\n    // Create the market data manager\n    info!(\" Creating market data manager...\");\n    let manager = Arc::new(MarketDataManager::new());\n    info!(\" Market data manager created successfully\");\n\n    // Create channels for different data streams\n    info!(\" Setting up communication channels...\");\n    let (market_tx, market_rx) = mpsc::channel::<MarketEvent>(1000);\n    info!(\" Channels created with buffer size 1000\");\n\n    // Start the stream ingester\n    info!(\" Starting stream ingester task...\");\n    let manager_clone = Arc::clone(&manager);\n    tokio::spawn(async move {\n        info!(\" Stream ingester task started\");\n        let mut ingester = StreamIngester::new(market_rx, manager_clone);\n        info!(\" Running stream ingester...\");\n        ingester.run().await;\n    });\n    info!(\" Stream ingester task spawned\");\n\n    // Load initial data from JSON files\n    info!(\" Loading initial market data from JSON files...\");\n    load_initial_data(&market_tx).await?;\n    info!(\" Initial market data loaded successfully\");\n\n    // Start real-time simulation (simulated here with periodic updates)\n    info!(\" Starting real-time simulation task...\");\n    let market_tx_clone = market_tx.clone();\n    tokio::spawn(async move {\n        info!(\" Real-time simulation task started\");\n        simulate_real_time_updates(market_tx_clone).await;\n    });\n    info!(\" Real-time simulation task spawned\");\n\n    // Start arbitrage monitoring\n    info!(\" Starting arbitrage monitoring task...\");\n    let manager_clone = Arc::clone(&manager);\n    tokio::spawn(async move {\n        info!(\" Arbitrage monitoring task started\");\n        monitor_arbitrage(manager_clone).await;\n    });\n    info!(\" Arbitrage monitoring task spawned\");\n\n    // Start metrics API server\n    info!(\" Starting metrics API server...\");\n    expose_metrics_api(manager).await;\n    info!(\" Metrics API server started\");\n\n    Ok(())\n}\n\nasync fn load_initial_data(tx: &mpsc::Sender<MarketEvent>) -> anyhow::Result<()> {\n    info!(\" Loading order book snapshot from data/LOB_snapshot.json...\");\n\n    // Load snapshot from file\n    match load_lob_snapshot(\"data/LOB_snapshot.json\") {\n        Ok((symbol, snapshot)) => {\n            info!(\"Loaded snapshot for symbol: {}\", symbol);\n            tx.send(MarketEvent::OrderBookSnapshot(symbol, snapshot))\n                .await?;\n        }\n        Err(e) => {\n            error!(\" Failed to load order book snapshot: {}\", e);\n        }\n    }\n\n    // Load delta updates\n    info!(\" Loading order book delta from data/LOB_delta.json...\");\n    match load_lob_delta(\"data/LOB_delta.json\") {\n        Ok((symbol, delta)) => {\n            info!(\n                \"Loaded delta for symbol: {}, seq: {}\",\n                symbol, delta.sequence\n            );\n            tx.send(MarketEvent::OrderBookDelta(symbol, delta)).await?;\n        }\n        Err(e) => {\n            error!(\" Failed to load order book delta: {}\", e);\n        }\n    }\n\n    // Load AMM pool state\n    info!(\" Loading AMM pool data from data/amm_pool.json...\");\n    match load_amm_pool(\"data/amm_pool.json\") {\n        Ok((address, update)) => {\n            info!(\"Loaded AMM pool for address: {}\", address);\n            tx.send(MarketEvent::AMMUpdate(address, update)).await?;\n        }\n        Err(e) => {\n            error!(\" Failed to load AMM pool: {}\", e);\n        }\n    }\n\n    info!(\"Initial data loading completed\");\n    Ok(())\n}\n\nasync fn simulate_real_time_updates(tx: mpsc::Sender<MarketEvent>) {\n    info!(\"Starting real-time market data simulation...\");\n\n    let mut interval = tokio::time::interval(tokio::time::Duration::from_millis(100));\n    let mut seq = 1001u64;\n\n    loop {\n        interval.tick().await;\n\n        // Simulate order book updates\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(seq),\n            chrono::Utc::now(),\n            vec![\n                PriceLevelUpdate::update(\n                    Side::Bid,\n                    Price(dec!(2445) + rust_decimal::Decimal::from(seq % 10)),\n                    Quantity(dec!(1) + rust_decimal::Decimal::from(seq % 5)),\n                ),\n                PriceLevelUpdate::update(\n                    Side::Ask,\n                    Price(dec!(2446) + rust_decimal::Decimal::from(seq % 10)),\n                    Quantity(dec!(1) + rust_decimal::Decimal::from(seq % 3)),\n                ),\n            ],\n        );\n\n        if tx\n            .send(MarketEvent::OrderBookDelta(\n                Symbol(\"ETHUSDC\".to_string()),\n                delta,\n            ))\n            .await\n            .is_err()\n        {\n            break; // Channel closed\n        }\n\n        // Occasionally simulate AMM pool updates\n        if seq % 50 == 0 {\n            let new_reserves = TokenReserves::new(\n                dec!(1000) + rust_decimal::Decimal::from(seq % 100),\n                dec!(2445000) + rust_decimal::Decimal::from(seq % 10000),\n            );\n\n            let amm_update =\n                AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n            if tx\n                .send(MarketEvent::AMMUpdate(\n                    PoolAddress(\"0xPOOL\".to_string()),\n                    amm_update,\n                ))\n                .await\n                .is_err()\n            {\n                break;\n            }\n        }\n\n        seq += 1;\n\n        // Stop after some time for demo purposes\n        if seq > 2000 {\n            info!(\"Simulation completed after {} updates\", seq - 1001);\n            break;\n        }\n    }\n}\n\nasync fn monitor_arbitrage(manager: Arc<MarketDataManager>) {\n    info!(\"Starting arbitrage monitoring...\");\n\n    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(1));\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    loop {\n        interval.tick().await;\n\n        // Get all order books and AMM pools\n        let symbols = manager.get_orderbook_symbols();\n        let addresses = manager.get_amm_pool_addresses();\n\n        // Check each combination for arbitrage\n        for symbol in &symbols {\n            if let Some(book) = manager.get_orderbook(symbol) {\n                for address in &addresses {\n                    if let Some(pool) = manager.get_amm_pool(address) {\n                        if let Some(opportunity) = detector.check_arbitrage(&book, &pool) {\n                            info!(\n                                \" ARBITRAGE DETECTED! Buy {} @ {}, Sell {} @ {}, Profit: {:.2}%, Max Qty: {}\",\n                                opportunity.buy_venue,\n                                opportunity.buy_price,\n                                opportunity.sell_venue,\n                                opportunity.sell_price,\n                                opportunity.profit_percent,\n                                opportunity.max_quantity\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nasync fn expose_metrics_api(manager: Arc<MarketDataManager>) {\n    use warp::Filter;\n\n    info!(\"Starting metrics API server on :8080\");\n\n    let manager = warp::any().map(move || Arc::clone(&manager));\n\n    // Metrics endpoint\n    let metrics = warp::path(\"metrics\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc<MarketDataManager>| {\n            let metrics = mgr.get_market_metrics();\n            warp::reply::json(&metrics)\n        });\n\n    // Health check endpoint\n    let health = warp::path(\"health\").and(warp::get()).map(|| {\n        warp::reply::json(&serde_json::json!({\n            \"status\": \"healthy\",\n            \"version\": VERSION,\n            \"timestamp\": chrono::Utc::now()\n        }))\n    });\n\n    // Order book endpoint\n    let orderbooks = warp::path(\"orderbooks\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc<MarketDataManager>| {\n            let symbols = mgr.get_orderbook_symbols();\n            let mut books = std::collections::HashMap::new();\n\n            for symbol in symbols {\n                if let Some(book) = mgr.get_orderbook(&symbol) {\n                    books.insert(\n                        symbol.to_string(),\n                        serde_json::json!({\n                            \"symbol\": symbol,\n                            \"best_bid\": book.best_bid(),\n                            \"best_ask\": book.best_ask(),\n                            \"mid_price\": book.mid_price(),\n                            \"spread\": book.spread(),\n                            \"last_update\": book.last_update()\n                        }),\n                    );\n                }\n            }\n\n            warp::reply::json(&books)\n        });\n\n    // AMM pools endpoint\n    let pools = warp::path(\"pools\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc<MarketDataManager>| {\n            let addresses = mgr.get_amm_pool_addresses();\n            let mut pool_data = std::collections::HashMap::new();\n\n            for address in addresses {\n                if let Some(pool) = mgr.get_amm_pool(&address) {\n                    pool_data.insert(\n                        address.to_string(),\n                        serde_json::json!({\n                            \"address\": address,\n                            \"pool_type\": pool.pool_type(),\n                            \"implied_mid\": pool.implied_mid(),\n                            \"reserves\": pool.get_reserves(),\n                            \"fee_tier\": pool.get_fee_tier(),\n                            \"last_update\": pool.last_update()\n                        }),\n                    );\n                }\n            }\n\n            warp::reply::json(&pool_data)\n        });\n\n    let routes = metrics\n        .or(health)\n        .or(orderbooks)\n        .or(pools)\n        .with(warp::cors().allow_any_origin());\n\n    info!(\"Metrics API endpoints available:\");\n    info!(\"  GET /health - Health check\");\n    info!(\"  GET /metrics - Complete market metrics\");\n    info!(\"  GET /orderbooks - Order book data\");\n    info!(\"  GET /pools - AMM pool data\");\n\n    warp::serve(routes).run(([127, 0, 0, 1], 8080)).await;\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":174},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","amm_tests.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","arbitrage_tests.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","concurrency_tests.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","integration_tests.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","orderbook_tests.rs"],"content":"\n","traces":[],"covered":0,"coverable":0}],"coverage":56.28140703517588,"covered":448,"coverable":796}