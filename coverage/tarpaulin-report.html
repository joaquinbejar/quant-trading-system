<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","amm_bench.rs"],"content":"fn main() {\n    println!(\"AMM benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","concurrency_bench.rs"],"content":"fn main() {\n    println!(\"Concurrency benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","ingestion_bench.rs"],"content":"fn main() {\n    println!(\"Ingestion benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","orderbook_bench.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse quant_trading_system::*;\nuse rust_decimal_macros::dec;\nuse std::hint::black_box;\n\nfn benchmark_orderbook_operations(c: \u0026mut Criterion) {\n    let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Setup initial state\n    let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n    for i in 0..1000 {\n        let price = dec!(2000.0) + rust_decimal::Decimal::from(i);\n        snapshot.bids.insert(Price(price), Quantity(dec!(1.0)));\n        snapshot\n            .asks\n            .insert(Price(price + dec!(1.0)), Quantity(dec!(1.0)));\n    }\n    book.apply_snapshot(snapshot).unwrap();\n\n    c.bench_function(\"orderbook_best_bid\", |b| {\n        b.iter(|| black_box(book.best_bid()))\n    });\n\n    c.bench_function(\"orderbook_best_ask\", |b| {\n        b.iter(|| black_box(book.best_ask()))\n    });\n\n    c.bench_function(\"orderbook_mid_price\", |b| {\n        b.iter(|| black_box(book.mid_price()))\n    });\n}\n\ncriterion_group!(benches, benchmark_orderbook_operations);\ncriterion_main!(benches);\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":11,"address":[],"length":0,"stats":{"Line":2001}},{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":5}}],"covered":11,"coverable":11},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","arbitrage_bot.rs"],"content":"fn main() {\n    println!(\"Arbitrage bot example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","basic_usage.rs"],"content":"fn main() {\n    println!(\"Basic usage example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","data_replay.rs"],"content":"fn main() {\n    println!(\"Data replay example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","market_maker.rs"],"content":"fn main() {\n    println!(\"Market maker example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","amm_pool.rs"],"content":"use crate::domain::{events::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// AMM pool types supported by the system\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum AMMPoolType {\n    /// Uniswap V2 style constant product (x * y = k)\n    ConstantProduct,\n    /// Uniswap V3 style concentrated liquidity\n    ConcentratedLiquidity,\n}\n\n/// Core AMM pool implementation supporting both V2 and V3 mechanics\n#[derive(Debug)]\npub struct AMMPool {\n    address: PoolAddress,\n    pool_type: AMMPoolType,\n    /// Token reserves (for V2) or virtual reserves (for V3)\n    reserves: TokenReserves,\n    /// Square root price for V3 pools\n    sqrt_price: Option\u003cSqrtPriceX96\u003e,\n    /// Fee tier in basis points\n    fee_tier: FeeTier,\n    /// Last update timestamp\n    last_update: Timestamp,\n}\n\nimpl AMMPool {\n    /// Creates a new Uniswap V2 style AMM pool\n    pub fn new_v2(address: PoolAddress, reserves: TokenReserves, fee_tier: FeeTier) -\u003e Self {\n        Self {\n            address,\n            pool_type: AMMPoolType::ConstantProduct,\n            reserves,\n            sqrt_price: None,\n            fee_tier,\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Creates a new Uniswap V3 style AMM pool with sqrt price\n    pub fn new_v3(\n        address: PoolAddress,\n        reserves: TokenReserves,\n        sqrt_price: SqrtPriceX96,\n        fee_tier: FeeTier,\n    ) -\u003e Self {\n        Self {\n            address,\n            pool_type: AMMPoolType::ConcentratedLiquidity,\n            reserves,\n            sqrt_price: Some(sqrt_price),\n            fee_tier,\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Update pool state\n    pub fn update_state(\u0026mut self, update: AMMPoolUpdate) -\u003e TradingResult\u003c()\u003e {\n        self.reserves = update.reserves;\n        self.sqrt_price = update.sqrt_price;\n        self.fee_tier = update.fee_tier;\n        self.last_update = update.timestamp;\n        Ok(())\n    }\n\n    /// Get current implied mid price\n    pub fn implied_mid(\u0026self) -\u003e Price {\n        match self.sqrt_price {\n            Some(sqrt_price) =\u003e sqrt_price.to_price(),\n            None =\u003e self.implied_mid_from_reserves(),\n        }\n    }\n\n    /// Calculate implied mid price from reserves (V2 style)\n    pub fn implied_mid_from_reserves(\u0026self) -\u003e Price {\n        if self.reserves.token0.is_zero() {\n            return Price::zero();\n        }\n        Price(self.reserves.token1 / self.reserves.token0)\n    }\n\n    /// Calculate price impact for a given input amount\n    /// Returns (output_amount, price_impact_percent, effective_price)\n    pub fn calculate_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        match self.pool_type {\n            AMMPoolType::ConstantProduct =\u003e {\n                self.calculate_v2_price_impact(input_token, input_amount)\n            }\n            AMMPoolType::ConcentratedLiquidity =\u003e {\n                self.calculate_v3_price_impact(input_token, input_amount)\n            }\n        }\n    }\n\n    /// Calculate V2 style price impact using constant product formula\n    fn calculate_v2_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        let (reserve_in, reserve_out) = match input_token {\n            TokenIndex::Token0 =\u003e (self.reserves.token0, self.reserves.token1),\n            TokenIndex::Token1 =\u003e (self.reserves.token1, self.reserves.token0),\n        };\n\n        if reserve_in.is_zero() || reserve_out.is_zero() {\n            return Err(TradingError::InsufficientLiquidity(input_amount));\n        }\n\n        // Apply fee\n        let fee_decimal = self.fee_tier.to_decimal();\n        let input_after_fee = input_amount * (Decimal::ONE - fee_decimal);\n\n        // Constant product formula: (x + dx) * (y - dy) = x * y\n        // Solving for dy: dy = (y * dx) / (x + dx)\n        let output_amount = (reserve_out * input_after_fee) / (reserve_in + input_after_fee);\n\n        if output_amount \u003e= reserve_out {\n            return Err(TradingError::InsufficientLiquidity(input_amount));\n        }\n\n        // Calculate price impact\n        let initial_price = reserve_out / reserve_in;\n        let effective_price = output_amount / input_amount;\n        let price_impact =\n            ((initial_price - effective_price) / initial_price).abs() * Decimal::from(100);\n\n        Ok(PriceImpactResult {\n            output_amount,\n            price_impact_percent: price_impact,\n            effective_price: Price(effective_price),\n            fee_amount: input_amount * fee_decimal,\n        })\n    }\n\n    /// Calculate V3 style price impact (simplified - would need tick math in production)\n    fn calculate_v3_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        // For V3, we'll use a simplified approach similar to V2\n        // In production, this would involve complex tick math and liquidity distribution\n        self.calculate_v2_price_impact(input_token, input_amount)\n    }\n\n    /// Get pool address\n    pub fn address(\u0026self) -\u003e \u0026PoolAddress {\n        \u0026self.address\n    }\n\n    /// Get pool type\n    pub fn pool_type(\u0026self) -\u003e \u0026AMMPoolType {\n        \u0026self.pool_type\n    }\n\n    /// Get current reserves\n    pub fn get_reserves(\u0026self) -\u003e TokenReserves {\n        self.reserves.clone()\n    }\n\n    /// Get sqrt price (if available)\n    pub fn sqrt_price(\u0026self) -\u003e Option\u003cSqrtPriceX96\u003e {\n        self.sqrt_price\n    }\n\n    /// Get fee tier\n    pub fn get_fee_tier(\u0026self) -\u003e FeeTier {\n        self.fee_tier\n    }\n\n    /// Get last update timestamp\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.last_update\n    }\n\n    /// Get pool address\n    pub fn get_address(\u0026self) -\u003e PoolAddress {\n        self.address.clone()\n    }\n\n    /// Get current sqrt price (V3 only)\n    pub fn get_sqrt_price(\u0026self) -\u003e Option\u003cSqrtPriceX96\u003e {\n        self.sqrt_price\n    }\n}\n\n/// Token index for AMM operations\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum TokenIndex {\n    /// First token in the pair\n    Token0,\n    /// Second token in the pair\n    Token1,\n}\n\n/// Result of a price impact calculation\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceImpactResult {\n    /// Amount of output tokens received\n    pub output_amount: Decimal,\n    /// Price impact as a percentage\n    pub price_impact_percent: Decimal,\n    /// Effective price after impact\n    pub effective_price: Price,\n    /// Fee amount charged\n    pub fee_amount: Decimal,\n}\n\n/// Thread-safe wrapper around AMMPool\n#[derive(Debug, Clone)]\npub struct ThreadSafeAMMPool {\n    inner: Arc\u003cRwLock\u003cAMMPool\u003e\u003e,\n}\n\nimpl ThreadSafeAMMPool {\n    /// Creates a new thread-safe Uniswap V2 style AMM pool\n    pub fn new_v2(address: PoolAddress, reserves: TokenReserves, fee_tier: FeeTier) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(AMMPool::new_v2(address, reserves, fee_tier))),\n        }\n    }\n\n    /// Creates a new thread-safe Uniswap V3 style AMM pool with sqrt price\n    pub fn new_v3(\n        address: PoolAddress,\n        reserves: TokenReserves,\n        sqrt_price: SqrtPriceX96,\n        fee_tier: FeeTier,\n    ) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(AMMPool::new_v3(\n                address, reserves, sqrt_price, fee_tier,\n            ))),\n        }\n    }\n\n    /// Update pool state with write lock\n    pub fn update_state(\u0026self, update: AMMPoolUpdate) -\u003e TradingResult\u003c()\u003e {\n        let mut pool = self.inner.write().expect(\"Failed to acquire write lock\");\n        pool.update_state(update)\n    }\n\n    /// Get implied mid price with read lock\n    pub fn implied_mid(\u0026self) -\u003e Price {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .implied_mid()\n    }\n\n    /// Calculate price impact for a given trade\n    pub fn calculate_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .calculate_price_impact(input_token, input_amount)\n    }\n\n    /// Get pool address with read lock\n    pub fn get_address(\u0026self) -\u003e PoolAddress {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .address\n            .clone()\n    }\n\n    /// Get pool type with read lock\n    pub fn pool_type(\u0026self) -\u003e AMMPoolType {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .pool_type()\n            .clone()\n    }\n\n    /// Get reserves with read lock\n    pub fn get_reserves(\u0026self) -\u003e TokenReserves {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .reserves\n            .clone()\n    }\n\n    /// Get sqrt price with read lock\n    pub fn get_sqrt_price(\u0026self) -\u003e Option\u003cSqrtPriceX96\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .sqrt_price\n    }\n\n    /// Get fee tier with read lock\n    pub fn get_fee_tier(\u0026self) -\u003e FeeTier {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .fee_tier\n    }\n\n    /// Get last update timestamp with read lock\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_update()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_v2_pool_creation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        assert_eq!(pool.pool_type(), \u0026AMMPoolType::ConstantProduct);\n        assert_eq!(pool.implied_mid_from_reserves(), Price(dec!(2.0)));\n    }\n\n    #[test]\n    fn test_v3_pool_creation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let sqrt_price = SqrtPriceX96(2u128.pow(96)); // sqrt(1) = 1\n        let pool = AMMPool::new_v3(\n            PoolAddress(\"0x456\".to_string()),\n            reserves,\n            sqrt_price,\n            FeeTier(30),\n        );\n\n        assert_eq!(pool.pool_type(), \u0026AMMPoolType::ConcentratedLiquidity);\n        assert!(pool.sqrt_price().is_some());\n    }\n\n    #[test]\n    fn test_price_impact_calculation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(\n            PoolAddress(\"0x123\".to_string()),\n            reserves,\n            FeeTier(30), // 0.3%\n        );\n\n        // Test small trade (should have minimal impact)\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(10.0))\n            .unwrap();\n\n        // With 0.3% fee, input after fee = 10 * 0.997 = 9.97\n        // Output = (2000 * 9.97) / (1000 + 9.97) = 19.7406...\n        assert!(result.output_amount \u003e dec!(19.7));\n        assert!(result.output_amount \u003c dec!(19.8));\n        assert!(result.price_impact_percent \u003e dec!(0.0)); // Should have some impact\n        assert_eq!(result.fee_amount, dec!(0.03)); // 0.3% of 10\n    }\n\n    #[test]\n    fn test_large_trade_price_impact() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Test large trade (should have significant impact)\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(100.0))\n            .unwrap();\n\n        // Large trades should have higher price impact\n        assert!(result.price_impact_percent \u003e dec!(5.0)); // More than 5% impact\n    }\n\n    #[test]\n    fn test_insufficient_liquidity() {\n        let reserves = TokenReserves::new(dec!(100.0), dec!(200.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Try to trade more than available liquidity\n        let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(1000.0));\n\n        // For constant product AMM, very large trades are still possible but with extreme price impact\n        // Let's check that the result has very high price impact instead\n        if let Ok(impact) = result {\n            assert!(impact.price_impact_percent \u003e dec!(50.0)); // Very high impact\n        } else {\n            // If it does error, that's also acceptable behavior\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_amm_pool() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool =\n            ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Test concurrent reads\n        let pool_clone = pool.clone();\n        let handle = std::thread::spawn(move || {\n            for _ in 0..100 {\n                let _ = pool_clone.implied_mid();\n                let _ = pool_clone.calculate_price_impact(TokenIndex::Token0, dec!(1.0));\n            }\n        });\n\n        // Concurrent reads from main thread\n        for _ in 0..100 {\n            let _ = pool.get_reserves();\n            let _ = pool.get_fee_tier();\n        }\n\n        handle.join().unwrap();\n\n        // Verify state is consistent\n        assert_eq!(pool.implied_mid(), Price(dec!(2.0)));\n    }\n\n    #[test]\n    fn test_pool_state_update() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool =\n            ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Update pool state\n        let new_reserves = TokenReserves::new(dec!(1100.0), dec!(1900.0));\n        let update =\n            AMMPoolUpdate::new(chrono::Utc::now(), new_reserves.clone(), None, FeeTier(25));\n\n        pool.update_state(update).unwrap();\n\n        // Verify state was updated\n        assert_eq!(pool.get_reserves(), new_reserves);\n        assert_eq!(pool.get_fee_tier(), FeeTier(25));\n\n        // Price should have changed\n        let new_price = dec!(1900.0) / dec!(1100.0);\n        assert_eq!(pool.implied_mid(), Price(new_price));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":134}},{"line":40,"address":[],"length":0,"stats":{"Line":134}},{"line":45,"address":[],"length":0,"stats":{"Line":16}},{"line":55,"address":[],"length":0,"stats":{"Line":32}},{"line":57,"address":[],"length":0,"stats":{"Line":16}},{"line":62,"address":[],"length":0,"stats":{"Line":194}},{"line":63,"address":[],"length":0,"stats":{"Line":194}},{"line":64,"address":[],"length":0,"stats":{"Line":194}},{"line":65,"address":[],"length":0,"stats":{"Line":194}},{"line":66,"address":[],"length":0,"stats":{"Line":194}},{"line":67,"address":[],"length":0,"stats":{"Line":194}},{"line":71,"address":[],"length":0,"stats":{"Line":6300}},{"line":72,"address":[],"length":0,"stats":{"Line":6300}},{"line":73,"address":[],"length":0,"stats":{"Line":30}},{"line":74,"address":[],"length":0,"stats":{"Line":6290}},{"line":79,"address":[],"length":0,"stats":{"Line":6292}},{"line":80,"address":[],"length":0,"stats":{"Line":12584}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":1420}},{"line":93,"address":[],"length":0,"stats":{"Line":1420}},{"line":95,"address":[],"length":0,"stats":{"Line":1420}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":1420}},{"line":109,"address":[],"length":0,"stats":{"Line":4260}},{"line":110,"address":[],"length":0,"stats":{"Line":1420}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":4260}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":42}},{"line":162,"address":[],"length":0,"stats":{"Line":42}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":22}},{"line":182,"address":[],"length":0,"stats":{"Line":22}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":126}},{"line":228,"address":[],"length":0,"stats":{"Line":630}},{"line":233,"address":[],"length":0,"stats":{"Line":14}},{"line":240,"address":[],"length":0,"stats":{"Line":56}},{"line":247,"address":[],"length":0,"stats":{"Line":194}},{"line":248,"address":[],"length":0,"stats":{"Line":776}},{"line":249,"address":[],"length":0,"stats":{"Line":388}},{"line":253,"address":[],"length":0,"stats":{"Line":6300}},{"line":254,"address":[],"length":0,"stats":{"Line":12600}},{"line":261,"address":[],"length":0,"stats":{"Line":1414}},{"line":266,"address":[],"length":0,"stats":{"Line":4242}},{"line":269,"address":[],"length":0,"stats":{"Line":2828}},{"line":273,"address":[],"length":0,"stats":{"Line":52}},{"line":274,"address":[],"length":0,"stats":{"Line":104}},{"line":275,"address":[],"length":0,"stats":{"Line":104}},{"line":276,"address":[],"length":0,"stats":{"Line":52}},{"line":277,"address":[],"length":0,"stats":{"Line":52}},{"line":282,"address":[],"length":0,"stats":{"Line":38}},{"line":283,"address":[],"length":0,"stats":{"Line":76}},{"line":291,"address":[],"length":0,"stats":{"Line":6282}},{"line":292,"address":[],"length":0,"stats":{"Line":12564}},{"line":293,"address":[],"length":0,"stats":{"Line":12564}},{"line":294,"address":[],"length":0,"stats":{"Line":6282}},{"line":295,"address":[],"length":0,"stats":{"Line":6282}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":6230}},{"line":309,"address":[],"length":0,"stats":{"Line":12460}},{"line":310,"address":[],"length":0,"stats":{"Line":12460}},{"line":311,"address":[],"length":0,"stats":{"Line":6230}},{"line":312,"address":[],"length":0,"stats":{"Line":6230}},{"line":316,"address":[],"length":0,"stats":{"Line":22}},{"line":317,"address":[],"length":0,"stats":{"Line":44}}],"covered":62,"coverable":83},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","arbitrage.rs"],"content":"use crate::domain::{amm_pool::*, order_book::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Arbitrage opportunity between two venues\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct ArbitrageOpportunity {\n    /// Venue where the asset should be bought\n    pub buy_venue: Venue,\n    /// Venue where the asset should be sold\n    pub sell_venue: Venue,\n    /// Price to buy at\n    pub buy_price: Price,\n    /// Price to sell at\n    pub sell_price: Price,\n    /// Maximum quantity that can be traded\n    pub max_quantity: Quantity,\n    /// Profit percentage\n    pub profit_percent: Decimal,\n    /// Estimated profit amount\n    pub estimated_profit: Decimal,\n}\n\nimpl ArbitrageOpportunity {\n    /// Creates a new arbitrage opportunity\n    pub fn new(\n        buy_venue: Venue,\n        sell_venue: Venue,\n        buy_price: Price,\n        sell_price: Price,\n        max_quantity: Quantity,\n    ) -\u003e Self {\n        let profit_per_unit = sell_price.0 - buy_price.0;\n        let estimated_profit = profit_per_unit * max_quantity.0;\n        let profit_percent = if !buy_price.is_zero() {\n            (profit_per_unit / buy_price.0) * Decimal::from(100)\n        } else {\n            Decimal::ZERO\n        };\n\n        Self {\n            buy_venue,\n            sell_venue,\n            buy_price,\n            sell_price,\n            max_quantity,\n            profit_percent,\n            estimated_profit,\n        }\n    }\n}\n\n/// Trading venue identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Venue {\n    /// Order book venue with symbol\n    OrderBook(Symbol),\n    /// AMM pool venue with address\n    AMM(PoolAddress),\n}\n\nimpl fmt::Display for Venue {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Venue::OrderBook(symbol) =\u003e write!(f, \"OrderBook({})\", symbol),\n            Venue::AMM(address) =\u003e write!(f, \"AMM({})\", address),\n        }\n    }\n}\n\n/// Arbitrage detector with configurable profit thresholds\n#[derive(Debug)]\npub struct ArbitrageDetector {\n    /// Minimum profit percentage to consider an opportunity viable (in basis points)\n    min_profit_bps: u32,\n    /// Maximum slippage tolerance (in basis points)\n    max_slippage_bps: u32,\n    /// Minimum trade size to consider\n    min_trade_size: Decimal,\n}\n\nimpl ArbitrageDetector {\n    /// Create new arbitrage detector\n    /// min_profit_bps: minimum profit in basis points (e.g., 10 = 0.1%)\n    pub fn new(min_profit_bps: u32) -\u003e Self {\n        Self {\n            min_profit_bps,\n            max_slippage_bps: 50,               // 0.5% default max slippage\n            min_trade_size: Decimal::from(100), // Default minimum trade size\n        }\n    }\n\n    /// Create detector with custom parameters\n    pub fn with_params(\n        min_profit_bps: u32,\n        max_slippage_bps: u32,\n        min_trade_size: Decimal,\n    ) -\u003e Self {\n        Self {\n            min_profit_bps,\n            max_slippage_bps,\n            min_trade_size,\n        }\n    }\n\n    /// Check for arbitrage opportunities between order book and AMM pool\n    pub fn check_arbitrage(\n        \u0026self,\n        order_book: \u0026ThreadSafeOrderBook,\n        amm_pool: \u0026ThreadSafeAMMPool,\n    ) -\u003e Option\u003cArbitrageOpportunity\u003e {\n        let ob_symbol = order_book.symbol();\n        let pool_address = amm_pool.get_address();\n\n        // Get order book prices\n        let ob_best_bid = order_book.best_bid()?;\n        let ob_best_ask = order_book.best_ask()?;\n\n        // Get AMM implied price\n        let amm_mid = amm_pool.implied_mid();\n\n        // Check both directions of arbitrage\n\n        // Direction 1: Buy from AMM, sell to order book\n        if let Some(opp1) = self.check_amm_to_orderbook(\n            amm_pool,\n            order_book,\n            amm_mid,\n            ob_best_bid,\n            \u0026pool_address,\n            \u0026ob_symbol,\n        ) {\n            return Some(opp1);\n        }\n\n        // Direction 2: Buy from order book, sell to AMM\n        if let Some(opp2) = self.check_orderbook_to_amm(\n            order_book,\n            amm_pool,\n            ob_best_ask,\n            amm_mid,\n            \u0026ob_symbol,\n            \u0026pool_address,\n        ) {\n            return Some(opp2);\n        }\n\n        None\n    }\n\n    /// Check arbitrage: buy from AMM, sell to order book\n    fn check_amm_to_orderbook(\n        \u0026self,\n        amm_pool: \u0026ThreadSafeAMMPool,\n        order_book: \u0026ThreadSafeOrderBook,\n        amm_price: Price,\n        ob_best_bid: Price,\n        pool_address: \u0026PoolAddress,\n        ob_symbol: \u0026Symbol,\n    ) -\u003e Option\u003cArbitrageOpportunity\u003e {\n        // Check if order book bid is higher than AMM price (profitable to buy from AMM, sell to OB)\n        if ob_best_bid.0 \u003c= amm_price.0 {\n            return None;\n        }\n\n        let profit_per_unit = ob_best_bid.0 - amm_price.0;\n        let profit_percent = (profit_per_unit / amm_price.0) * Decimal::from(10000); // Convert to basis points\n\n        if profit_percent \u003c Decimal::from(self.min_profit_bps) {\n            return None;\n        }\n\n        // Calculate maximum tradeable quantity considering:\n        // 1. Order book liquidity at best bid\n        // 2. AMM price impact\n        let ob_liquidity = order_book.quantity_at_price(Side::Bid, ob_best_bid);\n        let max_amm_trade = self.calculate_max_amm_trade(amm_pool, amm_price);\n\n        let max_quantity = Quantity(ob_liquidity.0.min(max_amm_trade.0).max(self.min_trade_size));\n\n        if max_quantity.0 \u003c self.min_trade_size {\n            return None;\n        }\n\n        Some(ArbitrageOpportunity::new(\n            Venue::AMM(pool_address.clone()),\n            Venue::OrderBook(ob_symbol.clone()),\n            amm_price,\n            ob_best_bid,\n            max_quantity,\n        ))\n    }\n\n    /// Check arbitrage: buy from order book, sell to AMM\n    fn check_orderbook_to_amm(\n        \u0026self,\n        order_book: \u0026ThreadSafeOrderBook,\n        amm_pool: \u0026ThreadSafeAMMPool,\n        ob_best_ask: Price,\n        amm_price: Price,\n        ob_symbol: \u0026Symbol,\n        pool_address: \u0026PoolAddress,\n    ) -\u003e Option\u003cArbitrageOpportunity\u003e {\n        // Check if AMM price is higher than order book ask (profitable to buy from OB, sell to AMM)\n        if amm_price.0 \u003c= ob_best_ask.0 {\n            return None;\n        }\n\n        let profit_per_unit = amm_price.0 - ob_best_ask.0;\n        let profit_percent = (profit_per_unit / ob_best_ask.0) * Decimal::from(10000); // Convert to basis points\n\n        if profit_percent \u003c Decimal::from(self.min_profit_bps) {\n            return None;\n        }\n\n        // Calculate maximum tradeable quantity\n        let ob_liquidity = order_book.quantity_at_price(Side::Ask, ob_best_ask);\n        let max_amm_trade = self.calculate_max_amm_trade(amm_pool, amm_price);\n\n        let max_quantity = Quantity(ob_liquidity.0.min(max_amm_trade.0).max(self.min_trade_size));\n\n        if max_quantity.0 \u003c self.min_trade_size {\n            return None;\n        }\n\n        Some(ArbitrageOpportunity::new(\n            Venue::OrderBook(ob_symbol.clone()),\n            Venue::AMM(pool_address.clone()),\n            ob_best_ask,\n            amm_price,\n            max_quantity,\n        ))\n    }\n\n    /// Calculate maximum trade size for AMM considering slippage tolerance\n    fn calculate_max_amm_trade(\n        \u0026self,\n        amm_pool: \u0026ThreadSafeAMMPool,\n        _current_price: Price,\n    ) -\u003e Quantity {\n        let max_slippage_decimal = Decimal::from(self.max_slippage_bps) / Decimal::from(10000);\n        let reserves = amm_pool.get_reserves();\n\n        // For constant product AMM, calculate max trade size that keeps slippage under threshold\n        // This is a simplified calculation - in production would need more sophisticated modeling\n        let max_trade_estimate = reserves.token0 * max_slippage_decimal;\n\n        Quantity(max_trade_estimate.max(self.min_trade_size))\n    }\n\n    /// Check multiple order books against multiple AMM pools\n    pub fn scan_opportunities(\n        \u0026self,\n        order_books: \u0026[ThreadSafeOrderBook],\n        amm_pools: \u0026[ThreadSafeAMMPool],\n    ) -\u003e Vec\u003cArbitrageOpportunity\u003e {\n        let mut opportunities = Vec::new();\n\n        for order_book in order_books {\n            for amm_pool in amm_pools {\n                if let Some(opportunity) = self.check_arbitrage(order_book, amm_pool) {\n                    opportunities.push(opportunity);\n                }\n            }\n        }\n\n        // Sort by profit percentage (descending)\n        opportunities.sort_by(|a, b| b.profit_percent.cmp(\u0026a.profit_percent));\n\n        opportunities\n    }\n\n    /// Get minimum profit threshold in basis points\n    pub fn min_profit_bps(\u0026self) -\u003e u32 {\n        self.min_profit_bps\n    }\n\n    /// Get maximum slippage tolerance in basis points\n    pub fn max_slippage_bps(\u0026self) -\u003e u32 {\n        self.max_slippage_bps\n    }\n\n    /// Get minimum trade size\n    pub fn min_trade_size(\u0026self) -\u003e Decimal {\n        self.min_trade_size\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{events::OrderBookSnapshot, types::TokenReserves};\n    use rust_decimal_macros::dec;\n\n    fn create_test_order_book() -\u003e ThreadSafeOrderBook {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .bids\n            .insert(Price(dec!(1999.0)), Quantity(dec!(5.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2002.0)), Quantity(dec!(12.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n        book\n    }\n\n    fn create_test_amm_pool(price_ratio: Decimal) -\u003e ThreadSafeAMMPool {\n        // Create pool with specific price ratio (token1/token0)\n        let token0_reserve = dec!(1000.0);\n        let token1_reserve = token0_reserve * price_ratio;\n        let reserves = TokenReserves::new(token0_reserve, token1_reserve);\n\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30))\n    }\n\n    #[test]\n    fn test_arbitrage_detection_amm_to_orderbook() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with lower price (1950) than order book best bid (2000)\n        let amm_pool = create_test_amm_pool(dec!(1950.0));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        assert!(opportunity.is_some());\n        let opp = opportunity.unwrap();\n\n        assert_eq!(opp.buy_venue, Venue::AMM(PoolAddress(\"0x123\".to_string())));\n        assert_eq!(\n            opp.sell_venue,\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()))\n        );\n        assert_eq!(opp.buy_price, Price(dec!(1950.0)));\n        assert_eq!(opp.sell_price, Price(dec!(2000.0)));\n        assert!(opp.profit_percent \u003e dec!(0.0));\n    }\n\n    #[test]\n    fn test_arbitrage_detection_orderbook_to_amm() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with higher price (2050) than order book best ask (2001)\n        let amm_pool = create_test_amm_pool(dec!(2050.0));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        assert!(opportunity.is_some());\n        let opp = opportunity.unwrap();\n\n        assert_eq!(\n            opp.buy_venue,\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()))\n        );\n        assert_eq!(opp.sell_venue, Venue::AMM(PoolAddress(\"0x123\".to_string())));\n        assert_eq!(opp.buy_price, Price(dec!(2001.0)));\n        assert_eq!(opp.sell_price, Price(dec!(2050.0)));\n        assert!(opp.profit_percent \u003e dec!(0.0));\n    }\n\n    #[test]\n    fn test_no_arbitrage_opportunity() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with price within the spread (2000.5)\n        let amm_pool = create_test_amm_pool(dec!(2000.5));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        assert!(opportunity.is_none());\n    }\n\n    #[test]\n    fn test_insufficient_profit_threshold() {\n        let detector = ArbitrageDetector::new(500); // 5% minimum profit (very high)\n        let order_book = create_test_order_book();\n\n        // Create AMM with small arbitrage opportunity\n        let amm_pool = create_test_amm_pool(dec!(1990.0));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        // Should be None because profit is below 5% threshold\n        assert!(opportunity.is_none());\n    }\n\n    #[test]\n    fn test_scan_multiple_opportunities() {\n        let detector = ArbitrageDetector::new(10);\n\n        let order_books = vec![create_test_order_book()];\n\n        let amm_pools = vec![\n            create_test_amm_pool(dec!(1950.0)), // Should create arbitrage opportunity\n            create_test_amm_pool(dec!(2000.5)), // No opportunity (within spread)\n            create_test_amm_pool(dec!(2050.0)), // Should create arbitrage opportunity\n        ];\n\n        let opportunities = detector.scan_opportunities(\u0026order_books, \u0026amm_pools);\n\n        // Should find 2 opportunities\n        assert_eq!(opportunities.len(), 2);\n\n        // Should be sorted by profit percentage (descending)\n        assert!(opportunities[0].profit_percent \u003e= opportunities[1].profit_percent);\n    }\n\n    #[test]\n    fn test_arbitrage_opportunity_calculations() {\n        let opp = ArbitrageOpportunity::new(\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n            Venue::AMM(PoolAddress(\"0x123\".to_string())),\n            Price(dec!(2000.0)),\n            Price(dec!(2020.0)),\n            Quantity(dec!(10.0)),\n        );\n\n        assert_eq!(opp.estimated_profit, dec!(200.0)); // (2020 - 2000) * 10\n        assert_eq!(opp.profit_percent, dec!(1.0)); // (20 / 2000) * 100 = 1%\n    }\n\n    #[test]\n    fn test_detector_configuration() {\n        let detector = ArbitrageDetector::with_params(\n            25,         // 0.25% min profit\n            100,        // 1% max slippage\n            dec!(50.0), // min trade size\n        );\n\n        assert_eq!(detector.min_profit_bps(), 25);\n        assert_eq!(detector.max_slippage_bps(), 100);\n        assert_eq!(detector.min_trade_size(), dec!(50.0));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":42}},{"line":34,"address":[],"length":0,"stats":{"Line":84}},{"line":35,"address":[],"length":0,"stats":{"Line":84}},{"line":36,"address":[],"length":0,"stats":{"Line":84}},{"line":37,"address":[],"length":0,"stats":{"Line":36}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":6}},{"line":67,"address":[],"length":0,"stats":{"Line":24}},{"line":86,"address":[],"length":0,"stats":{"Line":42}},{"line":90,"address":[],"length":0,"stats":{"Line":42}},{"line":95,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":40}},{"line":113,"address":[],"length":0,"stats":{"Line":120}},{"line":114,"address":[],"length":0,"stats":{"Line":120}},{"line":117,"address":[],"length":0,"stats":{"Line":120}},{"line":118,"address":[],"length":0,"stats":{"Line":40}},{"line":126,"address":[],"length":0,"stats":{"Line":18}},{"line":138,"address":[],"length":0,"stats":{"Line":70}},{"line":139,"address":[],"length":0,"stats":{"Line":44}},{"line":140,"address":[],"length":0,"stats":{"Line":44}},{"line":141,"address":[],"length":0,"stats":{"Line":44}},{"line":142,"address":[],"length":0,"stats":{"Line":44}},{"line":143,"address":[],"length":0,"stats":{"Line":22}},{"line":144,"address":[],"length":0,"stats":{"Line":22}},{"line":149,"address":[],"length":0,"stats":{"Line":18}},{"line":153,"address":[],"length":0,"stats":{"Line":40}},{"line":163,"address":[],"length":0,"stats":{"Line":40}},{"line":164,"address":[],"length":0,"stats":{"Line":14}},{"line":171,"address":[],"length":0,"stats":{"Line":8}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":22}},{"line":206,"address":[],"length":0,"stats":{"Line":22}},{"line":207,"address":[],"length":0,"stats":{"Line":18}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":22}},{"line":242,"address":[],"length":0,"stats":{"Line":66}},{"line":243,"address":[],"length":0,"stats":{"Line":66}},{"line":247,"address":[],"length":0,"stats":{"Line":44}},{"line":249,"address":[],"length":0,"stats":{"Line":44}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":14}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":2}}],"covered":52,"coverable":55},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","events.rs"],"content":"use crate::domain::types::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeMap;\n\n/// Price level in an order book\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceLevel {\n    /// Price at this level\n    pub price: Price,\n    /// Quantity available at this price\n    pub quantity: Quantity,\n}\n\nimpl PriceLevel {\n    /// Creates a new price level with the given price and quantity\n    pub fn new(price: Price, quantity: Quantity) -\u003e Self {\n        Self { price, quantity }\n    }\n}\n\n/// Price level update for order book deltas\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceLevelUpdate {\n    /// Order side (bid or ask)\n    pub side: Side,\n    /// Price level\n    pub price: Price,\n    /// Quantity at this price level\n    pub quantity: Quantity,\n    /// Action to perform (update or delete)\n    pub action: UpdateAction,\n}\n\nimpl PriceLevelUpdate {\n    /// Creates a new price level update\n    pub fn new(side: Side, price: Price, quantity: Quantity, action: UpdateAction) -\u003e Self {\n        Self {\n            side,\n            price,\n            quantity,\n            action,\n        }\n    }\n\n    /// Creates an update action for the given side, price, and quantity\n    pub fn update(side: Side, price: Price, quantity: Quantity) -\u003e Self {\n        Self::new(side, price, quantity, UpdateAction::Update)\n    }\n\n    /// Creates a delete action for the given side and price\n    pub fn delete(side: Side, price: Price) -\u003e Self {\n        Self::new(side, price, Quantity::zero(), UpdateAction::Delete)\n    }\n}\n\n/// Complete order book snapshot with full state\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct OrderBookSnapshot {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the snapshot\n    pub timestamp: Timestamp,\n    /// Bid levels (price -\u003e quantity)\n    pub bids: BTreeMap\u003cPrice, Quantity\u003e,\n    /// Ask levels (price -\u003e quantity)\n    pub asks: BTreeMap\u003cPrice, Quantity\u003e,\n}\n\nimpl OrderBookSnapshot {\n    /// Creates a new empty order book snapshot\n    pub fn new(sequence: SequenceNumber, timestamp: Timestamp) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            bids: BTreeMap::new(),\n            asks: BTreeMap::new(),\n        }\n    }\n\n    /// Creates a new order book snapshot with the given levels\n    pub fn with_levels(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        bids: BTreeMap\u003cPrice, Quantity\u003e,\n        asks: BTreeMap\u003cPrice, Quantity\u003e,\n    ) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            bids,\n            asks,\n        }\n    }\n\n    /// Get the best bid (highest price on bid side)\n    pub fn best_bid(\u0026self) -\u003e Option\u003c\u0026Price\u003e {\n        self.bids.keys().next_back()\n    }\n\n    /// Get the best ask (lowest price on ask side)\n    pub fn best_ask(\u0026self) -\u003e Option\u003c\u0026Price\u003e {\n        self.asks.keys().next()\n    }\n\n    /// Get the mid price if both sides have liquidity\n    pub fn mid_price(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price((bid.0 + ask.0) / rust_decimal::Decimal::from(2))),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get the spread between best bid and ask\n    pub fn spread(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price(ask.0 - bid.0)),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// Incremental order book delta with incremental updates\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct OrderBookDelta {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the delta\n    pub timestamp: Timestamp,\n    /// List of price level updates\n    pub updates: Vec\u003cPriceLevelUpdate\u003e,\n}\n\nimpl OrderBookDelta {\n    /// Creates a new empty order book delta\n    pub fn new(sequence: SequenceNumber, timestamp: Timestamp) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            updates: Vec::new(),\n        }\n    }\n\n    /// Creates a new order book delta with the given updates\n    pub fn with_updates(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        updates: Vec\u003cPriceLevelUpdate\u003e,\n    ) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            updates,\n        }\n    }\n\n    /// Adds a price level update to this delta\n    pub fn add_update(\u0026mut self, update: PriceLevelUpdate) {\n        self.updates.push(update);\n    }\n}\n\n/// Trade execution event\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Trade {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the trade\n    pub timestamp: Timestamp,\n    /// Trade price\n    pub price: Price,\n    /// Trade quantity\n    pub quantity: Quantity,\n    /// Taker side of the trade\n    pub side: Side,\n}\n\nimpl Trade {\n    /// Creates a new trade event\n    pub fn new(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        price: Price,\n        quantity: Quantity,\n        side: Side,\n    ) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            price,\n            quantity,\n            side,\n        }\n    }\n}\n\n/// AMM pool state update\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct AMMPoolUpdate {\n    /// Timestamp of the update\n    pub timestamp: Timestamp,\n    /// Updated token reserves\n    pub reserves: TokenReserves,\n    /// Updated square root price (for V3 pools)\n    pub sqrt_price: Option\u003cSqrtPriceX96\u003e,\n    /// Pool fee tier\n    pub fee_tier: FeeTier,\n}\n\nimpl AMMPoolUpdate {\n    /// Creates a new AMM pool update\n    pub fn new(\n        timestamp: Timestamp,\n        reserves: TokenReserves,\n        sqrt_price: Option\u003cSqrtPriceX96\u003e,\n        fee_tier: FeeTier,\n    ) -\u003e Self {\n        Self {\n            timestamp,\n            reserves,\n            sqrt_price,\n            fee_tier,\n        }\n    }\n\n    /// Calculate implied mid price from reserves (Uniswap V2 style)\n    pub fn implied_mid_from_reserves(\u0026self) -\u003e Price {\n        if self.reserves.token0.is_zero() {\n            return Price::zero();\n        }\n        Price(self.reserves.token1 / self.reserves.token0)\n    }\n\n    /// Get implied mid price (prefer sqrt_price if available, otherwise use reserves)\n    pub fn implied_mid(\u0026self) -\u003e Price {\n        match self.sqrt_price {\n            Some(sqrt_price) =\u003e sqrt_price.to_price(),\n            None =\u003e self.implied_mid_from_reserves(),\n        }\n    }\n}\n\n/// Market events that can be processed by the system\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum MarketEvent {\n    /// Order book snapshot\n    OrderBookSnapshot(Symbol, OrderBookSnapshot),\n    /// Order book delta update\n    OrderBookDelta(Symbol, OrderBookDelta),\n    /// Trade execution\n    Trade(Symbol, Trade),\n    /// AMM pool update\n    AMMUpdate(PoolAddress, AMMPoolUpdate),\n}\n\nimpl MarketEvent {\n    /// Returns the timestamp of this market event\n    pub fn timestamp(\u0026self) -\u003e Timestamp {\n        match self {\n            MarketEvent::OrderBookSnapshot(_, snapshot) =\u003e snapshot.timestamp,\n            MarketEvent::OrderBookDelta(_, delta) =\u003e delta.timestamp,\n            MarketEvent::Trade(_, trade) =\u003e trade.timestamp,\n            MarketEvent::AMMUpdate(_, update) =\u003e update.timestamp,\n        }\n    }\n\n    /// Returns the sequence number if available\n    pub fn sequence(\u0026self) -\u003e Option\u003cSequenceNumber\u003e {\n        match self {\n            MarketEvent::OrderBookSnapshot(_, snapshot) =\u003e Some(snapshot.sequence),\n            MarketEvent::OrderBookDelta(_, delta) =\u003e Some(delta.sequence),\n            MarketEvent::Trade(_, trade) =\u003e Some(trade.sequence),\n            MarketEvent::AMMUpdate(_, _) =\u003e None, // AMM updates don't have sequence numbers\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_order_book_snapshot_best_prices() {\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n\n        // Add some bid levels\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n\n        // Add some ask levels\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(12.0)));\n\n        assert_eq!(snapshot.best_bid(), Some(\u0026Price(dec!(100.0))));\n        assert_eq!(snapshot.best_ask(), Some(\u0026Price(dec!(100.5))));\n        assert_eq!(snapshot.mid_price(), Some(Price(dec!(100.25))));\n        assert_eq!(snapshot.spread(), Some(Price(dec!(0.5))));\n    }\n\n    #[test]\n    fn test_amm_pool_implied_price() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n\n        let implied_price = update.implied_mid_from_reserves();\n        assert_eq!(implied_price, Price(dec!(2.0))); // 2000 / 1000 = 2.0\n    }\n\n    #[test]\n    fn test_price_level_update_creation() {\n        let update = PriceLevelUpdate::update(Side::Bid, Price(dec!(100.0)), Quantity(dec!(5.0)));\n\n        assert_eq!(update.side, Side::Bid);\n        assert_eq!(update.price, Price(dec!(100.0)));\n        assert_eq!(update.quantity, Quantity(dec!(5.0)));\n        assert_eq!(update.action, UpdateAction::Update);\n\n        let delete = PriceLevelUpdate::delete(Side::Ask, Price(dec!(101.0)));\n        assert_eq!(delete.action, UpdateAction::Delete);\n        assert!(delete.quantity.is_zero());\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":1250}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":40}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":43}},{"line":75,"address":[],"length":0,"stats":{"Line":43}},{"line":76,"address":[],"length":0,"stats":{"Line":43}},{"line":81,"address":[],"length":0,"stats":{"Line":432}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":1248}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":204}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":48},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","market_data.rs"],"content":"use crate::domain::{amm_pool::*, events::*, order_book::*, types::*};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// Market data manager that holds all order books and AMM pools\n#[derive(Debug)]\npub struct MarketDataManager {\n    /// Thread-safe order books indexed by symbol\n    pub orderbooks: Arc\u003cRwLock\u003cHashMap\u003cSymbol, ThreadSafeOrderBook\u003e\u003e\u003e,\n    /// Thread-safe AMM pools indexed by address\n    pub amm_pools: Arc\u003cRwLock\u003cHashMap\u003cPoolAddress, ThreadSafeAMMPool\u003e\u003e\u003e,\n}\n\nimpl MarketDataManager {\n    /// Creates a new market data manager\n    pub fn new() -\u003e Self {\n        Self {\n            orderbooks: Arc::new(RwLock::new(HashMap::new())),\n            amm_pools: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Process a market event\n    pub fn process_event(\u0026self, event: MarketEvent) -\u003e TradingResult\u003c()\u003e {\n        match event {\n            MarketEvent::OrderBookSnapshot(symbol, snapshot) =\u003e {\n                self.apply_orderbook_snapshot(symbol, snapshot)\n            }\n            MarketEvent::OrderBookDelta(symbol, delta) =\u003e {\n                self.apply_orderbook_delta(symbol, \u0026delta)\n            }\n            MarketEvent::Trade(symbol, trade) =\u003e self.process_trade(symbol, trade),\n            MarketEvent::AMMUpdate(address, update) =\u003e self.process_amm_update(address, update),\n        }\n    }\n\n    /// Apply order book snapshot\n    pub fn apply_orderbook_snapshot(\n        \u0026self,\n        symbol: Symbol,\n        snapshot: OrderBookSnapshot,\n    ) -\u003e TradingResult\u003c()\u003e {\n        let mut books = self\n            .orderbooks\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        if let Some(book) = books.get(\u0026symbol) {\n            book.apply_snapshot(snapshot)?\n        } else {\n            // Create new order book if it doesn't exist\n            let new_book = ThreadSafeOrderBook::new(symbol.clone());\n            new_book.apply_snapshot(snapshot)?;\n            books.insert(symbol, new_book);\n        }\n        Ok(())\n    }\n\n    /// Apply order book delta update\n    pub fn apply_orderbook_delta(\n        \u0026self,\n        symbol: Symbol,\n        delta: \u0026OrderBookDelta,\n    ) -\u003e TradingResult\u003c()\u003e {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        if let Some(book) = books.get(\u0026symbol) {\n            book.apply_delta(delta)?\n        } else {\n            return Err(TradingError::ParseError(format!(\n                \"No order book found for symbol: {}\",\n                symbol\n            )));\n        }\n        Ok(())\n    }\n\n    /// Process trade (for now, just log it - could be used for analytics)\n    fn process_trade(\u0026self, _symbol: Symbol, _trade: Trade) -\u003e TradingResult\u003c()\u003e {\n        // In a full implementation, this would update trade statistics,\n        // volume metrics, etc.\n        Ok(())\n    }\n\n    /// Process AMM pool update\n    fn process_amm_update(\u0026self, address: PoolAddress, update: AMMPoolUpdate) -\u003e TradingResult\u003c()\u003e {\n        let mut pools = self\n            .amm_pools\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        match pools.get(\u0026address) {\n            Some(pool) =\u003e {\n                pool.update_state(update)?;\n            }\n            None =\u003e {\n                // Create new pool - assume V2 style if no sqrt_price, V3 if sqrt_price exists\n                let pool = match update.sqrt_price {\n                    Some(sqrt_price) =\u003e ThreadSafeAMMPool::new_v3(\n                        address.clone(),\n                        update.reserves,\n                        sqrt_price,\n                        update.fee_tier,\n                    ),\n                    None =\u003e {\n                        ThreadSafeAMMPool::new_v2(address.clone(), update.reserves, update.fee_tier)\n                    }\n                };\n                pools.insert(address, pool);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get order book for symbol\n    pub fn get_orderbook(\u0026self, symbol: \u0026Symbol) -\u003e Option\u003cThreadSafeOrderBook\u003e {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        books.get(symbol).cloned()\n    }\n\n    /// Get AMM pool for address\n    pub fn get_amm_pool(\u0026self, address: \u0026PoolAddress) -\u003e Option\u003cThreadSafeAMMPool\u003e {\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        pools.get(address).cloned()\n    }\n\n    /// Add new AMM pool\n    pub fn add_amm_pool(\u0026self, address: PoolAddress, pool: ThreadSafeAMMPool) {\n        let mut pools = self\n            .amm_pools\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        pools.insert(address, pool);\n    }\n\n    /// Get all order book symbols\n    pub fn get_orderbook_symbols(\u0026self) -\u003e Vec\u003cSymbol\u003e {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        books.keys().cloned().collect()\n    }\n\n    /// Get all AMM pool addresses\n    pub fn get_amm_pool_addresses(\u0026self) -\u003e Vec\u003cPoolAddress\u003e {\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        pools.keys().cloned().collect()\n    }\n\n    /// Get market metrics for all instruments\n    pub fn get_market_metrics(\u0026self) -\u003e MarketMetrics {\n        let mut metrics = MarketMetrics::new();\n\n        // Collect order book metrics\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        for (symbol, book) in books.iter() {\n            if let (Some(bid), Some(ask)) = (book.best_bid(), book.best_ask()) {\n                let spread = ask.0 - bid.0;\n                let mid_price = (bid.0 + ask.0) / rust_decimal::Decimal::from(2);\n\n                metrics.orderbook_metrics.insert(\n                    symbol.clone(),\n                    OrderBookMetrics {\n                        symbol: symbol.clone(),\n                        best_bid: bid,\n                        best_ask: ask,\n                        mid_price: Price(mid_price),\n                        spread,\n                        last_update: book.last_update(),\n                    },\n                );\n            }\n        }\n\n        // Collect AMM pool metrics\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        for (address, pool) in pools.iter() {\n            metrics.amm_metrics.insert(\n                address.clone(),\n                AMMMetrics {\n                    address: address.clone(),\n                    pool_type: pool.pool_type(),\n                    implied_mid: pool.implied_mid(),\n                    reserves: pool.get_reserves(),\n                    fee_tier: pool.get_fee_tier(),\n                    last_update: pool.last_update(),\n                },\n            );\n        }\n\n        metrics.timestamp = chrono::Utc::now();\n        metrics\n    }\n}\n\nimpl Default for MarketDataManager {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Market metrics aggregated across all instruments\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MarketMetrics {\n    /// Timestamp when metrics were collected\n    pub timestamp: Timestamp,\n    /// Order book metrics by symbol\n    pub orderbook_metrics: HashMap\u003cSymbol, OrderBookMetrics\u003e,\n    /// AMM pool metrics by pool address\n    pub amm_metrics: HashMap\u003cPoolAddress, AMMMetrics\u003e,\n}\n\nimpl MarketMetrics {\n    /// Creates new market metrics with current timestamp\n    pub fn new() -\u003e Self {\n        Self {\n            timestamp: chrono::Utc::now(),\n            orderbook_metrics: HashMap::new(),\n            amm_metrics: HashMap::new(),\n        }\n    }\n}\n\nimpl Default for MarketMetrics {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Order book metrics for a specific symbol\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBookMetrics {\n    /// Trading symbol\n    pub symbol: Symbol,\n    /// Best bid price\n    pub best_bid: Price,\n    /// Best ask price\n    pub best_ask: Price,\n    /// Mid price (average of best bid and ask)\n    pub mid_price: Price,\n    /// Bid-ask spread\n    pub spread: rust_decimal::Decimal,\n    /// Timestamp of last update\n    pub last_update: Timestamp,\n}\n\n/// AMM pool metrics\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AMMMetrics {\n    /// Pool address\n    pub address: PoolAddress,\n    /// Type of AMM pool (V2/V3)\n    pub pool_type: AMMPoolType,\n    /// Implied mid price from reserves\n    pub implied_mid: Price,\n    /// Token reserves in the pool\n    pub reserves: TokenReserves,\n    /// Fee tier for the pool\n    pub fee_tier: FeeTier,\n    /// Timestamp of last update\n    pub last_update: Timestamp,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_market_data_manager_creation() {\n        let manager = MarketDataManager::new();\n        assert!(manager.get_orderbook_symbols().is_empty());\n        assert!(manager.get_amm_pool_addresses().is_empty());\n    }\n\n    #[test]\n    fn test_orderbook_snapshot_processing() {\n        let manager = MarketDataManager::new();\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        let book = manager.get_orderbook(\u0026symbol).unwrap();\n        assert_eq!(book.best_bid(), Some(Price(dec!(2000.0))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(2001.0))));\n    }\n\n    #[test]\n    fn test_orderbook_delta_processing() {\n        let manager = MarketDataManager::new();\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        // First, create initial snapshot\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        // Then apply delta\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(1999.0)),\n                Quantity(dec!(5.0)),\n            )],\n        );\n\n        let event = MarketEvent::OrderBookDelta(symbol.clone(), delta);\n        manager.process_event(event).unwrap();\n\n        let book = manager.get_orderbook(\u0026symbol).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(1999.0))),\n            Quantity(dec!(5.0))\n        );\n    }\n\n    #[test]\n    fn test_amm_update_processing() {\n        let manager = MarketDataManager::new();\n        let address = PoolAddress(\"0x123\".to_string());\n\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n\n        let event = MarketEvent::AMMUpdate(address.clone(), update);\n        manager.process_event(event).unwrap();\n\n        let pool = manager.get_amm_pool(\u0026address).unwrap();\n        assert_eq!(pool.implied_mid(), Price(dec!(2.0)));\n        assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n    }\n\n    #[test]\n    fn test_market_metrics_collection() {\n        let manager = MarketDataManager::new();\n\n        // Add order book\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        // Add AMM pool\n        let address = PoolAddress(\"0x123\".to_string());\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n        let event = MarketEvent::AMMUpdate(address.clone(), update);\n        manager.process_event(event).unwrap();\n\n        // Get metrics\n        let metrics = manager.get_market_metrics();\n\n        assert_eq!(metrics.orderbook_metrics.len(), 1);\n        assert_eq!(metrics.amm_metrics.len(), 1);\n\n        let ob_metrics = metrics.orderbook_metrics.get(\u0026symbol).unwrap();\n        assert_eq!(ob_metrics.best_bid, Price(dec!(2000.0)));\n        assert_eq!(ob_metrics.best_ask, Price(dec!(2001.0)));\n        assert_eq!(ob_metrics.mid_price, Price(dec!(2000.5)));\n\n        let amm_metrics = metrics.amm_metrics.get(\u0026address).unwrap();\n        assert_eq!(amm_metrics.implied_mid, Price(dec!(2.0)));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":72}},{"line":20,"address":[],"length":0,"stats":{"Line":288}},{"line":21,"address":[],"length":0,"stats":{"Line":144}},{"line":26,"address":[],"length":0,"stats":{"Line":768}},{"line":27,"address":[],"length":0,"stats":{"Line":768}},{"line":28,"address":[],"length":0,"stats":{"Line":148}},{"line":31,"address":[],"length":0,"stats":{"Line":1224}},{"line":32,"address":[],"length":0,"stats":{"Line":2448}},{"line":34,"address":[],"length":0,"stats":{"Line":12}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":148}},{"line":45,"address":[],"length":0,"stats":{"Line":296}},{"line":46,"address":[],"length":0,"stats":{"Line":148}},{"line":49,"address":[],"length":0,"stats":{"Line":302}},{"line":50,"address":[],"length":0,"stats":{"Line":6}},{"line":53,"address":[],"length":0,"stats":{"Line":568}},{"line":54,"address":[],"length":0,"stats":{"Line":426}},{"line":55,"address":[],"length":0,"stats":{"Line":142}},{"line":57,"address":[],"length":0,"stats":{"Line":142}},{"line":61,"address":[],"length":0,"stats":{"Line":612}},{"line":66,"address":[],"length":0,"stats":{"Line":2448}},{"line":67,"address":[],"length":0,"stats":{"Line":1836}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":612}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":1542}},{"line":117,"address":[],"length":0,"stats":{"Line":6168}},{"line":118,"address":[],"length":0,"stats":{"Line":4626}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":16}},{"line":124,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":30}},{"line":129,"address":[],"length":0,"stats":{"Line":60}},{"line":130,"address":[],"length":0,"stats":{"Line":30}},{"line":133,"address":[],"length":0,"stats":{"Line":90}},{"line":137,"address":[],"length":0,"stats":{"Line":1510}},{"line":138,"address":[],"length":0,"stats":{"Line":6040}},{"line":139,"address":[],"length":0,"stats":{"Line":4530}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":1210}},{"line":150,"address":[],"length":0,"stats":{"Line":2420}},{"line":153,"address":[],"length":0,"stats":{"Line":4840}},{"line":154,"address":[],"length":0,"stats":{"Line":3654}},{"line":155,"address":[],"length":0,"stats":{"Line":1234}},{"line":174,"address":[],"length":0,"stats":{"Line":4840}},{"line":175,"address":[],"length":0,"stats":{"Line":2442}},{"line":189,"address":[],"length":0,"stats":{"Line":1210}},{"line":190,"address":[],"length":0,"stats":{"Line":1210}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":1210}},{"line":215,"address":[],"length":0,"stats":{"Line":2420}},{"line":216,"address":[],"length":0,"stats":{"Line":1210}},{"line":217,"address":[],"length":0,"stats":{"Line":1210}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}}],"covered":65,"coverable":75},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","mod.rs"],"content":"//! Domain layer containing core business logic and entities\n//!\n//! This module contains the core domain entities and business logic for the quantitative\n//! trading system, including order books, AMM pools, arbitrage detection, and market events.\n\n/// AMM pool implementations and utilities\npub mod amm_pool;\n/// Arbitrage detection and opportunity analysis\npub mod arbitrage;\n/// Market events and data structures\npub mod events;\n/// Market data management and aggregation\npub mod market_data;\n/// Order book implementations\npub mod order_book;\n/// Core types and primitives\npub mod types;\n\npub use events::*;\npub use market_data::*;\npub use types::*;\n\npub use amm_pool::{AMMPool, AMMPoolType, PriceImpactResult, ThreadSafeAMMPool, TokenIndex};\npub use arbitrage::{ArbitrageDetector, ArbitrageOpportunity, Venue};\npub use order_book::{OrderBookL2, ThreadSafeOrderBook};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","order_book.rs"],"content":"use crate::domain::{events::*, types::*};\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// Thread-safe L2 order book implementation\n/// Uses BTreeMap for automatic price sorting and O(log n) operations\n#[derive(Debug)]\npub struct OrderBookL2 {\n    symbol: Symbol,\n    /// Bids sorted by price (descending - highest first)\n    bids: BTreeMap\u003cPrice, Quantity\u003e,\n    /// Asks sorted by price (ascending - lowest first)  \n    asks: BTreeMap\u003cPrice, Quantity\u003e,\n    /// Last processed sequence number for idempotent replay\n    last_sequence: SequenceNumber,\n    /// Timestamp of last update\n    last_update: Timestamp,\n}\n\nimpl OrderBookL2 {\n    /// Creates a new order book for the given symbol\n    pub fn new(symbol: Symbol) -\u003e Self {\n        Self {\n            symbol,\n            bids: BTreeMap::new(),\n            asks: BTreeMap::new(),\n            last_sequence: SequenceNumber(0),\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Apply a complete snapshot, replacing all existing data\n    pub fn apply_snapshot(\u0026mut self, snapshot: OrderBookSnapshot) -\u003e TradingResult\u003c()\u003e {\n        // Validate sequence number progression\n        if snapshot.sequence.0 \u003c= self.last_sequence.0 {\n            return Err(TradingError::SequenceOutOfOrder {\n                expected: self.last_sequence.0 + 1,\n                actual: snapshot.sequence.0,\n            });\n        }\n\n        self.bids = snapshot.bids;\n        self.asks = snapshot.asks;\n        self.last_sequence = snapshot.sequence;\n        self.last_update = snapshot.timestamp;\n\n        Ok(())\n    }\n\n    /// Apply incremental delta updates\n    pub fn apply_delta(\u0026mut self, delta: OrderBookDelta) -\u003e TradingResult\u003c()\u003e {\n        // Validate sequence number progression for idempotent replay\n        if delta.sequence.0 \u003c= self.last_sequence.0 {\n            // Skip if we've already processed this sequence\n            return Ok(());\n        }\n\n        if delta.sequence.0 != self.last_sequence.0 + 1 {\n            return Err(TradingError::SequenceOutOfOrder {\n                expected: self.last_sequence.0 + 1,\n                actual: delta.sequence.0,\n            });\n        }\n\n        // Apply each update in the delta\n        for update in delta.updates {\n            self.apply_price_level_update(update)?;\n        }\n\n        self.last_sequence = delta.sequence;\n        self.last_update = delta.timestamp;\n\n        Ok(())\n    }\n\n    /// Apply a single price level update\n    fn apply_price_level_update(\u0026mut self, update: PriceLevelUpdate) -\u003e TradingResult\u003c()\u003e {\n        let levels = match update.side {\n            Side::Bid =\u003e \u0026mut self.bids,\n            Side::Ask =\u003e \u0026mut self.asks,\n        };\n\n        match update.action {\n            UpdateAction::Update =\u003e {\n                if update.quantity.is_zero() {\n                    levels.remove(\u0026update.price);\n                } else {\n                    levels.insert(update.price, update.quantity);\n                }\n            }\n            UpdateAction::Delete =\u003e {\n                levels.remove(\u0026update.price);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get atomic snapshot without blocking writers\n    pub fn get_snapshot(\u0026self) -\u003e OrderBookSnapshot {\n        OrderBookSnapshot::with_levels(\n            self.last_sequence,\n            self.last_update,\n            self.bids.clone(),\n            self.asks.clone(),\n        )\n    }\n\n    /// Get best bid price (highest bid)\n    pub fn best_bid(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.bids.keys().next_back().copied()\n    }\n\n    /// Get best ask price (lowest ask)\n    pub fn best_ask(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.asks.keys().next().copied()\n    }\n\n    /// Get mid price if both sides have liquidity\n    pub fn mid_price(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price((bid.0 + ask.0) / rust_decimal::Decimal::from(2))),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get spread between best bid and ask\n    pub fn spread(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price(ask.0 - bid.0)),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get quantity at specific price level\n    pub fn quantity_at_price(\u0026self, side: Side, price: Price) -\u003e Quantity {\n        let levels = match side {\n            Side::Bid =\u003e \u0026self.bids,\n            Side::Ask =\u003e \u0026self.asks,\n        };\n\n        levels.get(\u0026price).copied().unwrap_or(Quantity::zero())\n    }\n\n    /// Get depth (total quantity) up to a certain price\n    pub fn depth_to_price(\u0026self, side: Side, max_price: Price) -\u003e Quantity {\n        let levels = match side {\n            Side::Bid =\u003e \u0026self.bids,\n            Side::Ask =\u003e \u0026self.asks,\n        };\n\n        let mut total = rust_decimal::Decimal::ZERO;\n\n        match side {\n            Side::Bid =\u003e {\n                // For bids, sum all levels \u003e= max_price (since we want depth at or above this price)\n                for (_price, quantity) in levels.range(max_price..) {\n                    total += quantity.0;\n                }\n            }\n            Side::Ask =\u003e {\n                // For asks, sum all levels \u003c= max_price (since we want depth at or below this price)\n                for (_price, quantity) in levels.range(..=max_price) {\n                    total += quantity.0;\n                }\n            }\n        }\n\n        Quantity(total)\n    }\n\n    /// Get the symbol for this order book\n    pub fn symbol(\u0026self) -\u003e \u0026Symbol {\n        \u0026self.symbol\n    }\n\n    /// Get last processed sequence number\n    pub fn last_sequence(\u0026self) -\u003e SequenceNumber {\n        self.last_sequence\n    }\n\n    /// Get timestamp of last update\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.last_update\n    }\n}\n\n/// Thread-safe wrapper around OrderBookL2\n#[derive(Debug, Clone)]\npub struct ThreadSafeOrderBook {\n    inner: Arc\u003cRwLock\u003cOrderBookL2\u003e\u003e,\n}\n\nimpl ThreadSafeOrderBook {\n    /// Creates a new thread-safe order book for the given symbol\n    pub fn new(symbol: Symbol) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(OrderBookL2::new(symbol))),\n        }\n    }\n\n    /// Apply snapshot with write lock\n    pub fn apply_snapshot(\u0026self, snapshot: OrderBookSnapshot) -\u003e TradingResult\u003c()\u003e {\n        let mut book = self\n            .inner\n            .write()\n            .map_err(|_| TradingError::LockError(\"Failed to acquire write lock\".to_string()))?;\n        book.apply_snapshot(snapshot)\n    }\n\n    /// Apply a delta update to the order book\n    pub fn apply_delta(\u0026self, delta: \u0026OrderBookDelta) -\u003e TradingResult\u003c()\u003e {\n        let mut book = self\n            .inner\n            .write()\n            .map_err(|_| TradingError::LockError(\"Failed to acquire write lock\".to_string()))?;\n        book.apply_delta(delta.clone())\n    }\n\n    /// Get a snapshot of the current order book state\n    pub fn get_snapshot(\u0026self) -\u003e OrderBookSnapshot {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .get_snapshot()\n    }\n\n    /// Get the best bid price\n    pub fn best_bid(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .best_bid()\n    }\n\n    /// Get the best ask price\n    pub fn best_ask(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .best_ask()\n    }\n\n    /// Get the mid price (average of best bid and ask)\n    pub fn mid_price(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .mid_price()\n    }\n\n    /// Get the spread (difference between best ask and bid)\n    pub fn spread(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .spread()\n    }\n\n    /// Get quantity available at a specific price level\n    pub fn quantity_at_price(\u0026self, side: Side, price: Price) -\u003e Quantity {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .quantity_at_price(side, price)\n    }\n\n    /// Get total depth up to a maximum price\n    pub fn depth_to_price(\u0026self, side: Side, max_price: Price) -\u003e Quantity {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .depth_to_price(side, max_price)\n    }\n\n    /// Get the symbol for this order book\n    pub fn symbol(\u0026self) -\u003e Symbol {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .symbol()\n            .clone()\n    }\n\n    /// Get the last sequence number\n    pub fn last_sequence(\u0026self) -\u003e SequenceNumber {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_sequence()\n    }\n\n    /// Get the last update timestamp\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_update()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n    use std::thread;\n    use std::time::Duration;\n\n    #[test]\n    fn test_order_book_snapshot_application() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(12.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.0))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(100.5))));\n        assert_eq!(book.mid_price(), Some(Price(dec!(100.25))));\n    }\n\n    #[test]\n    fn test_order_book_delta_application() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Apply initial snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Apply delta update\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(100.5)),\n                Quantity(dec!(15.0)),\n            )],\n        );\n\n        book.apply_delta(delta).unwrap();\n\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.5))));\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.5))),\n            Quantity(dec!(15.0))\n        );\n    }\n\n    #[test]\n    fn test_idempotent_replay() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        book.apply_snapshot(snapshot).unwrap();\n\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(100.0)),\n                Quantity(dec!(10.0)),\n            )],\n        );\n\n        // Apply delta first time\n        book.apply_delta(delta.clone()).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.0))),\n            Quantity(dec!(10.0))\n        );\n\n        // Apply same delta again - should be idempotent\n        book.apply_delta(delta).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.0))),\n            Quantity(dec!(10.0))\n        );\n    }\n\n    #[test]\n    fn test_sequence_validation() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Try to apply delta with wrong sequence number\n        let delta = OrderBookDelta::new(SequenceNumber(5), chrono::Utc::now()); // Should be 2\n\n        let result = book.apply_delta(delta);\n        assert!(result.is_err());\n\n        if let Err(TradingError::SequenceOutOfOrder { expected, actual }) = result {\n            assert_eq!(expected, 2);\n            assert_eq!(actual, 5);\n        } else {\n            panic!(\"Expected SequenceOutOfOrder error\");\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_order_book() {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Apply initial snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test concurrent reads\n        let book_clone = book.clone();\n        let handle = thread::spawn(move || {\n            for _ in 0..100 {\n                let _ = book_clone.best_bid();\n                let _ = book_clone.get_snapshot();\n                thread::sleep(Duration::from_micros(1));\n            }\n        });\n\n        // Concurrent reads from main thread\n        for _ in 0..100 {\n            let _ = book.best_ask();\n            let _ = book.mid_price();\n            thread::sleep(Duration::from_micros(1));\n        }\n\n        handle.join().unwrap();\n\n        // Verify state is still consistent\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.0))));\n    }\n\n    #[test]\n    fn test_depth_calculation() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n        snapshot.bids.insert(Price(dec!(99.0)), Quantity(dec!(8.0)));\n\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(12.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(7.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test bid depth\n        let bid_depth = book.depth_to_price(Side::Bid, Price(dec!(99.5)));\n        assert_eq!(bid_depth, Quantity(dec!(15.0))); // 10.0 + 5.0\n\n        // Test ask depth\n        let ask_depth = book.depth_to_price(Side::Ask, Price(dec!(101.0)));\n        assert_eq!(ask_depth, Quantity(dec!(19.0))); // 12.0 + 7.0\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":271}},{"line":26,"address":[],"length":0,"stats":{"Line":542}},{"line":27,"address":[],"length":0,"stats":{"Line":542}},{"line":28,"address":[],"length":0,"stats":{"Line":271}},{"line":29,"address":[],"length":0,"stats":{"Line":271}},{"line":34,"address":[],"length":0,"stats":{"Line":271}},{"line":36,"address":[],"length":0,"stats":{"Line":271}},{"line":37,"address":[],"length":0,"stats":{"Line":12}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":52,"address":[],"length":0,"stats":{"Line":1250}},{"line":54,"address":[],"length":0,"stats":{"Line":1250}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":488}},{"line":61,"address":[],"length":0,"stats":{"Line":488}},{"line":62,"address":[],"length":0,"stats":{"Line":488}},{"line":67,"address":[],"length":0,"stats":{"Line":2262}},{"line":68,"address":[],"length":0,"stats":{"Line":2262}},{"line":71,"address":[],"length":0,"stats":{"Line":754}},{"line":78,"address":[],"length":0,"stats":{"Line":754}},{"line":79,"address":[],"length":0,"stats":{"Line":1508}},{"line":80,"address":[],"length":0,"stats":{"Line":752}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":754}},{"line":86,"address":[],"length":0,"stats":{"Line":748}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":748}},{"line":92,"address":[],"length":0,"stats":{"Line":6}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":97,"address":[],"length":0,"stats":{"Line":754}},{"line":101,"address":[],"length":0,"stats":{"Line":200}},{"line":103,"address":[],"length":0,"stats":{"Line":200}},{"line":104,"address":[],"length":0,"stats":{"Line":200}},{"line":105,"address":[],"length":0,"stats":{"Line":400}},{"line":106,"address":[],"length":0,"stats":{"Line":400}},{"line":111,"address":[],"length":0,"stats":{"Line":9340}},{"line":112,"address":[],"length":0,"stats":{"Line":28020}},{"line":116,"address":[],"length":0,"stats":{"Line":9300}},{"line":117,"address":[],"length":0,"stats":{"Line":27900}},{"line":121,"address":[],"length":0,"stats":{"Line":225}},{"line":122,"address":[],"length":0,"stats":{"Line":900}},{"line":123,"address":[],"length":0,"stats":{"Line":13}},{"line":124,"address":[],"length":0,"stats":{"Line":212}},{"line":129,"address":[],"length":0,"stats":{"Line":26}},{"line":130,"address":[],"length":0,"stats":{"Line":104}},{"line":131,"address":[],"length":0,"stats":{"Line":14}},{"line":132,"address":[],"length":0,"stats":{"Line":12}},{"line":137,"address":[],"length":0,"stats":{"Line":84}},{"line":138,"address":[],"length":0,"stats":{"Line":168}},{"line":139,"address":[],"length":0,"stats":{"Line":62}},{"line":140,"address":[],"length":0,"stats":{"Line":22}},{"line":143,"address":[],"length":0,"stats":{"Line":504}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":46}},{"line":175,"address":[],"length":0,"stats":{"Line":46}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":1234}},{"line":185,"address":[],"length":0,"stats":{"Line":1234}},{"line":197,"address":[],"length":0,"stats":{"Line":261}},{"line":199,"address":[],"length":0,"stats":{"Line":783}},{"line":204,"address":[],"length":0,"stats":{"Line":261}},{"line":205,"address":[],"length":0,"stats":{"Line":522}},{"line":206,"address":[],"length":0,"stats":{"Line":261}},{"line":208,"address":[],"length":0,"stats":{"Line":261}},{"line":213,"address":[],"length":0,"stats":{"Line":1242}},{"line":214,"address":[],"length":0,"stats":{"Line":2484}},{"line":215,"address":[],"length":0,"stats":{"Line":1242}},{"line":217,"address":[],"length":0,"stats":{"Line":1242}},{"line":222,"address":[],"length":0,"stats":{"Line":200}},{"line":223,"address":[],"length":0,"stats":{"Line":400}},{"line":230,"address":[],"length":0,"stats":{"Line":9085}},{"line":231,"address":[],"length":0,"stats":{"Line":18170}},{"line":238,"address":[],"length":0,"stats":{"Line":9047}},{"line":239,"address":[],"length":0,"stats":{"Line":18094}},{"line":246,"address":[],"length":0,"stats":{"Line":223}},{"line":247,"address":[],"length":0,"stats":{"Line":446}},{"line":254,"address":[],"length":0,"stats":{"Line":26}},{"line":255,"address":[],"length":0,"stats":{"Line":52}},{"line":262,"address":[],"length":0,"stats":{"Line":78}},{"line":263,"address":[],"length":0,"stats":{"Line":234}},{"line":266,"address":[],"length":0,"stats":{"Line":156}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":46}},{"line":279,"address":[],"length":0,"stats":{"Line":92}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":1234}},{"line":296,"address":[],"length":0,"stats":{"Line":2468}}],"covered":94,"coverable":99},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","types.rs"],"content":"use rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Trading symbol identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Symbol(pub String);\n\nimpl fmt::Display for Symbol {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Price with decimal precision to avoid floating-point errors\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct Price(pub Decimal);\n\nimpl Price {\n    /// Creates a zero price\n    pub fn zero() -\u003e Self {\n        Price(Decimal::ZERO)\n    }\n\n    /// Returns true if the price is zero\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl fmt::Display for Price {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Quantity with decimal precision\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct Quantity(pub Decimal);\n\nimpl Quantity {\n    /// Creates a zero quantity\n    pub fn zero() -\u003e Self {\n        Quantity(Decimal::ZERO)\n    }\n\n    /// Returns true if the quantity is zero\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl fmt::Display for Quantity {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Order side (bid or ask)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Side {\n    /// Bid (buy) side\n    Bid,\n    /// Ask (sell) side\n    Ask,\n}\n\nimpl fmt::Display for Side {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Side::Bid =\u003e write!(f, \"BID\"),\n            Side::Ask =\u003e write!(f, \"ASK\"),\n        }\n    }\n}\n\n/// Sequence number for idempotent message processing\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct SequenceNumber(pub u64);\n\nimpl fmt::Display for SequenceNumber {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Update action for price level changes\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum UpdateAction {\n    /// Add or update a price level\n    Update,\n    /// Remove a price level\n    Delete,\n}\n\n/// AMM pool address identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct PoolAddress(pub String);\n\nimpl fmt::Display for PoolAddress {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Token reserves in an AMM pool\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct TokenReserves {\n    /// Reserve amount for token0\n    pub token0: Decimal,\n    /// Reserve amount for token1\n    pub token1: Decimal,\n}\n\nimpl TokenReserves {\n    /// Creates new token reserves with the given amounts\n    pub fn new(token0: Decimal, token1: Decimal) -\u003e Self {\n        Self { token0, token1 }\n    }\n}\n\n/// Square root price for Uniswap V3 style pools\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub struct SqrtPriceX96(pub u128);\n\nimpl SqrtPriceX96 {\n    /// Convert sqrtPriceX96 to regular price\n    pub fn to_price(\u0026self) -\u003e Price {\n        // sqrtPriceX96 = sqrt(price) * 2^96\n        // So price = (sqrtPriceX96 / 2^96)^2\n\n        // Use a safer conversion that handles large numbers better\n        if self.0 == 0 {\n            return Price(Decimal::ZERO);\n        }\n\n        // Convert to f64 for calculation, then back to Decimal\n        let sqrt_price_f64 = self.0 as f64 / (2u128.pow(96) as f64);\n        let price_f64 = sqrt_price_f64 * sqrt_price_f64;\n\n        // Convert back to Decimal safely\n        match Decimal::try_from(price_f64) {\n            Ok(price) =\u003e Price(price),\n            Err(_) =\u003e Price(Decimal::ZERO), // Fallback for conversion errors\n        }\n    }\n}\n\n/// Fee tier for AMM pools (in basis points)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct FeeTier(pub u32);\n\nimpl FeeTier {\n    /// Convert to decimal (e.g., 30 basis points = 0.003)\n    pub fn to_decimal(\u0026self) -\u003e Decimal {\n        Decimal::from(self.0) / Decimal::from(10000u32)\n    }\n}\n\n/// Timestamp for market events\npub type Timestamp = chrono::DateTime\u003cchrono::Utc\u003e;\n\n/// Trading system errors\n#[derive(Debug, thiserror::Error)]\npub enum TradingError {\n    /// Invalid price value\n    #[error(\"Invalid price: {0}\")]\n    /// Invalid price provided\n    InvalidPrice(String),\n\n    /// Invalid quantity value\n    #[error(\"Invalid quantity: {0}\")]\n    /// Invalid quantity provided\n    InvalidQuantity(String),\n\n    /// Sequence number out of order\n    #[error(\"Sequence out of order: expected {expected}, got {actual}\")]\n    /// Sequence number is out of expected order\n    SequenceOutOfOrder {\n        /// Expected sequence number\n        expected: u64,\n        /// Actual sequence number received\n        actual: u64,\n    },\n\n    /// Insufficient liquidity for trade\n    #[error(\"Insufficient liquidity: {0}\")]\n    /// Insufficient liquidity available for the requested trade\n    InsufficientLiquidity(Decimal),\n\n    /// Parse error\n    #[error(\"Parse error: {0}\")]\n    /// Error parsing data\n    ParseError(String),\n\n    /// IO error\n    #[error(\"IO error: {0}\")]\n    /// Input/output error\n    IoError(#[from] std::io::Error),\n\n    /// Lock error\n    #[error(\"Lock error: {0}\")]\n    /// Error acquiring lock\n    LockError(String),\n\n    /// JSON error\n    #[error(\"JSON error: {0}\")]\n    /// JSON serialization/deserialization error\n    JsonError(#[from] serde_json::Error),\n}\n\n/// Result type for trading operations\npub type TradingResult\u003cT\u003e = Result\u003cT, TradingError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_price_ordering() {\n        let p1 = Price(dec!(100.50));\n        let p2 = Price(dec!(100.51));\n        assert!(p1 \u003c p2);\n    }\n\n    #[test]\n    fn test_quantity_operations() {\n        let q1 = Quantity(dec!(10.5));\n        let q2 = Quantity(dec!(5.25));\n        assert!(q1 \u003e q2);\n        assert!(!q1.is_zero());\n        assert!(Quantity::zero().is_zero());\n    }\n\n    #[test]\n    fn test_fee_tier_conversion() {\n        let fee = FeeTier(30); // 30 basis points\n        assert_eq!(fee.to_decimal(), dec!(0.003));\n    }\n\n    #[test]\n    fn test_sqrt_price_conversion() {\n        // Test with a simple case where sqrtPriceX96 represents sqrt(1) = 1\n        let sqrt_price = SqrtPriceX96(2u128.pow(96)); // This represents sqrt(1)\n        let price = sqrt_price.to_price();\n        // Should be approximately 1.0, allowing for some precision loss\n        assert!((price.0 - dec!(1.0)).abs() \u003c dec!(0.1));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":6}},{"line":11,"address":[],"length":0,"stats":{"Line":18}},{"line":21,"address":[],"length":0,"stats":{"Line":96}},{"line":22,"address":[],"length":0,"stats":{"Line":96}},{"line":26,"address":[],"length":0,"stats":{"Line":42}},{"line":27,"address":[],"length":0,"stats":{"Line":84}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":114}},{"line":44,"address":[],"length":0,"stats":{"Line":114}},{"line":48,"address":[],"length":0,"stats":{"Line":756}},{"line":49,"address":[],"length":0,"stats":{"Line":1512}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":18}},{"line":117,"address":[],"length":0,"stats":{"Line":360}},{"line":128,"address":[],"length":0,"stats":{"Line":12}},{"line":133,"address":[],"length":0,"stats":{"Line":12}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":12}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":1434}},{"line":156,"address":[],"length":0,"stats":{"Line":2868}}],"covered":18,"coverable":30},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","ingestion","mod.rs"],"content":"//! Stream ingestion utilities for real-time market data processing\n//!\n//! This module provides components for ingesting and processing real-time market data streams\n//! with comprehensive statistics tracking and error handling.\n\n/// Stream ingestion with statistics and error handling\npub mod stream_ingester;\n\npub use stream_ingester::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","ingestion","stream_ingester.rs"],"content":"use crate::domain::{events::*, market_data::*};\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{error, info};\n\n/// Stream ingester that processes market events concurrently\npub struct StreamIngester {\n    /// Channel receiver for incoming market events\n    receiver: mpsc::Receiver\u003cMarketEvent\u003e,\n    /// Market data manager to process events\n    manager: Arc\u003cMarketDataManager\u003e,\n    /// Buffer size for backpressure handling\n    buffer_size: usize,\n}\n\nimpl StreamIngester {\n    /// Create new stream ingester\n    pub fn new(receiver: mpsc::Receiver\u003cMarketEvent\u003e, manager: Arc\u003cMarketDataManager\u003e) -\u003e Self {\n        Self {\n            receiver,\n            manager,\n            buffer_size: 1000, // Default buffer size\n        }\n    }\n\n    /// Create stream ingester with custom buffer size\n    pub fn with_buffer_size(\n        receiver: mpsc::Receiver\u003cMarketEvent\u003e,\n        manager: Arc\u003cMarketDataManager\u003e,\n        buffer_size: usize,\n    ) -\u003e Self {\n        Self {\n            receiver,\n            manager,\n            buffer_size,\n        }\n    }\n\n    /// Run the ingestion loop\n    pub async fn run(\u0026mut self) {\n        info!(\n            \"Starting stream ingester with buffer size: {}\",\n            self.buffer_size\n        );\n\n        let mut event_count = 0u64;\n        let mut error_count = 0u64;\n\n        while let Some(event) = self.receiver.recv().await {\n            event_count += 1;\n\n            // Process the event\n            if let Err(e) = self.manager.process_event(event.clone()) {\n                error_count += 1;\n                error!(\"Failed to process event: {:?}, error: {}\", event, e);\n\n                // Log error details based on event type\n                match event {\n                    MarketEvent::OrderBookSnapshot(symbol, _) =\u003e {\n                        error!(\"Failed to process snapshot for symbol: {}\", symbol);\n                    }\n                    MarketEvent::OrderBookDelta(symbol, delta) =\u003e {\n                        error!(\n                            \"Failed to process delta for symbol: {}, seq: {}\",\n                            symbol, delta.sequence\n                        );\n                    }\n                    MarketEvent::Trade(symbol, trade) =\u003e {\n                        error!(\n                            \"Failed to process trade for symbol: {}, seq: {}\",\n                            symbol, trade.sequence\n                        );\n                    }\n                    MarketEvent::AMMUpdate(address, _) =\u003e {\n                        error!(\"Failed to process AMM update for pool: {}\", address);\n                    }\n                }\n            }\n\n            // Log progress periodically\n            if event_count % 1000 == 0 {\n                info!(\n                    \"Processed {} events, {} errors ({}% error rate)\",\n                    event_count,\n                    error_count,\n                    (error_count as f64 / event_count as f64) * 100.0\n                );\n            }\n        }\n\n        info!(\n            \"Stream ingester finished. Total events: {}, errors: {}\",\n            event_count, error_count\n        );\n    }\n\n    /// Get current buffer size\n    pub fn buffer_size(\u0026self) -\u003e usize {\n        self.buffer_size\n    }\n}\n\n/// Multi-stream ingester that can handle multiple concurrent streams\npub struct MultiStreamIngester {\n    /// Multiple receivers for different data streams\n    receivers: Vec\u003cmpsc::Receiver\u003cMarketEvent\u003e\u003e,\n    /// Market data manager to process events\n    manager: Arc\u003cMarketDataManager\u003e,\n    /// Buffer size per stream\n    buffer_size: usize,\n}\n\nimpl MultiStreamIngester {\n    /// Create new multi-stream ingester\n    pub fn new(\n        receivers: Vec\u003cmpsc::Receiver\u003cMarketEvent\u003e\u003e,\n        manager: Arc\u003cMarketDataManager\u003e,\n    ) -\u003e Self {\n        Self {\n            receivers,\n            manager,\n            buffer_size: 1000,\n        }\n    }\n\n    /// Run all streams concurrently\n    pub async fn run(self) {\n        info!(\n            \"Starting multi-stream ingester with {} streams\",\n            self.receivers.len()\n        );\n\n        let mut handles = Vec::new();\n\n        // Spawn a task for each stream\n        for (stream_id, receiver) in self.receivers.into_iter().enumerate() {\n            let manager = Arc::clone(\u0026self.manager);\n            let buffer_size = self.buffer_size;\n\n            let handle = tokio::spawn(async move {\n                let mut ingester = StreamIngester::with_buffer_size(receiver, manager, buffer_size);\n                info!(\"Starting stream {} ingestion\", stream_id);\n                ingester.run().await;\n                info!(\"Stream {} ingestion completed\", stream_id);\n            });\n\n            handles.push(handle);\n        }\n\n        // Wait for all streams to complete\n        for (stream_id, handle) in handles.into_iter().enumerate() {\n            if let Err(e) = handle.await {\n                error!(\"Stream {} failed: {}\", stream_id, e);\n            }\n        }\n\n        info!(\"All streams completed\");\n    }\n}\n\n/// Event statistics for stream ingestion performance\n#[derive(Debug, Clone, Default)]\npub struct IngestionStats {\n    /// Total number of events processed\n    pub total_events: u64,\n    /// Number of successfully processed events\n    pub successful_events: u64,\n    /// Number of events that failed processing\n    pub failed_events: u64,\n    /// Current processing rate in events per second\n    pub events_per_second: f64,\n    /// Timestamp of the last processed event\n    pub last_event_timestamp: Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e,\n    /// Timestamp when ingestion started\n    pub start_time: chrono::DateTime\u003cchrono::Utc\u003e,\n}\n\nimpl IngestionStats {\n    /// Creates new ingestion statistics\n    pub fn new() -\u003e Self {\n        Self {\n            start_time: chrono::Utc::now(),\n            ..Default::default()\n        }\n    }\n\n    /// Records an event and updates statistics\n    pub fn record_event(\u0026mut self, success: bool) {\n        self.total_events += 1;\n        self.last_event_timestamp = Some(chrono::Utc::now());\n\n        if success {\n            self.successful_events += 1;\n        } else {\n            self.failed_events += 1;\n        }\n    }\n\n    /// Calculates the success rate as a percentage\n    pub fn success_rate(\u0026self) -\u003e f64 {\n        if self.total_events \u003e 0 {\n            (self.successful_events as f64 / self.total_events as f64) * 100.0\n        } else {\n            0.0\n        }\n    }\n\n    /// Calculates the error rate as a percentage\n    pub fn error_rate(\u0026self) -\u003e f64 {\n        if self.total_events \u003e 0 {\n            (self.failed_events as f64 / self.total_events as f64) * 100.0\n        } else {\n            0.0\n        }\n    }\n}\n\n/// Stream ingester with detailed statistics tracking\npub struct StatisticalStreamIngester {\n    receiver: mpsc::Receiver\u003cMarketEvent\u003e,\n    manager: Arc\u003cMarketDataManager\u003e,\n    stats: IngestionStats,\n    report_interval: u64,\n}\n\nimpl StatisticalStreamIngester {\n    /// Creates a new stream ingester with the given receiver and market data manager\n    pub fn new(receiver: mpsc::Receiver\u003cMarketEvent\u003e, manager: Arc\u003cMarketDataManager\u003e) -\u003e Self {\n        Self {\n            receiver,\n            manager,\n            stats: IngestionStats::new(),\n            report_interval: 1000, // Report every 1000 events\n        }\n    }\n\n    /// Runs the statistical stream ingester, processing events and reporting statistics\n    pub async fn run(\u0026mut self) {\n        info!(\"Starting statistical stream ingester\");\n\n        while let Some(event) = self.receiver.recv().await {\n            // Process the event\n            let success = self.manager.process_event(event.clone()).is_ok();\n            self.stats.record_event(success);\n\n            if !success {\n                error!(\"Failed to process event: {:?}\", event);\n            }\n\n            // Report statistics periodically\n            if self.stats.total_events % self.report_interval == 0 {\n                self.report_stats();\n            }\n        }\n\n        // Final report\n        self.report_stats();\n        info!(\"Statistical stream ingester finished\");\n    }\n\n    fn report_stats(\u0026self) {\n        info!(\n            \"Stats - Total: {}, Successful: {}, Failed: {}, Success Rate: {:.2}%, Error Rate: {:.2}%\",\n            self.stats.total_events,\n            self.stats.successful_events,\n            self.stats.failed_events,\n            self.stats.success_rate(),\n            self.stats.error_rate()\n        );\n    }\n\n    /// Returns the current ingestion statistics\n    pub fn get_stats(\u0026self) -\u003e \u0026IngestionStats {\n        \u0026self.stats\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::types::*;\n    use rust_decimal_macros::dec;\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn test_stream_ingester_basic() {\n        let manager = Arc::new(MarketDataManager::new());\n        let (tx, rx) = mpsc::channel(10);\n        let mut ingester = StreamIngester::new(rx, manager.clone());\n\n        // Send a test event\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n\n        tx.send(event).await.unwrap();\n        drop(tx); // Close the channel\n\n        // Run ingester\n        ingester.run().await;\n\n        // Verify event was processed\n        assert!(manager.get_orderbook(\u0026symbol).is_some());\n    }\n\n    #[tokio::test]\n    async fn test_multi_stream_ingester() {\n        let manager = Arc::new(MarketDataManager::new());\n\n        // Create multiple streams\n        let (tx1, rx1) = mpsc::channel(10);\n        let (tx2, rx2) = mpsc::channel(10);\n\n        let multi_ingester = MultiStreamIngester::new(vec![rx1, rx2], manager.clone());\n\n        // Send events to both streams\n        let symbol1 = Symbol(\"ETHUSDC\".to_string());\n        let symbol2 = Symbol(\"BTCUSDC\".to_string());\n\n        let snapshot1 = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let snapshot2 = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n\n        tx1.send(MarketEvent::OrderBookSnapshot(symbol1.clone(), snapshot1))\n            .await\n            .unwrap();\n        tx2.send(MarketEvent::OrderBookSnapshot(symbol2.clone(), snapshot2))\n            .await\n            .unwrap();\n\n        drop(tx1);\n        drop(tx2);\n\n        // Run multi-stream ingester\n        multi_ingester.run().await;\n\n        // Verify both events were processed\n        assert!(manager.get_orderbook(\u0026symbol1).is_some());\n        assert!(manager.get_orderbook(\u0026symbol2).is_some());\n    }\n\n    #[tokio::test]\n    async fn test_ingestion_stats() {\n        let manager = Arc::new(MarketDataManager::new());\n        let (tx, rx) = mpsc::channel(10);\n        let mut ingester = StatisticalStreamIngester::new(rx, manager);\n\n        // Send multiple events\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        // Snapshot\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        tx.send(MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot))\n            .await\n            .unwrap();\n\n        // Delta\n        let delta = OrderBookDelta::new(SequenceNumber(2), chrono::Utc::now());\n        tx.send(MarketEvent::OrderBookDelta(symbol.clone(), delta))\n            .await\n            .unwrap();\n\n        // Trade\n        let trade = Trade::new(\n            SequenceNumber(3),\n            chrono::Utc::now(),\n            Price(dec!(2445.0)),\n            Quantity(dec!(1.0)),\n            Side::Bid,\n        );\n        tx.send(MarketEvent::Trade(symbol, trade)).await.unwrap();\n\n        drop(tx);\n\n        // Run ingester\n        ingester.run().await;\n\n        // Check stats\n        let stats = ingester.get_stats();\n        assert_eq!(stats.total_events, 3);\n        assert_eq!(stats.successful_events, 3);\n        assert_eq!(stats.failed_events, 0);\n    }\n\n    #[test]\n    fn test_ingestion_stats_calculations() {\n        let mut stats = IngestionStats::new();\n\n        // Simulate some events\n\n        for _ in 0..8 {\n            stats.record_event(true);\n        }\n\n        // Record some failures\n        stats.record_event(false);\n        stats.record_event(false);\n\n        assert_eq!(stats.total_events, 10);\n        assert_eq!(stats.failed_events, 2);\n        assert_eq!(stats.error_rate(), 20.0); // 2/10 * 100 = 20%\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":16}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":49,"address":[],"length":0,"stats":{"Line":72}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":26}},{"line":189,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":26}},{"line":192,"address":[],"length":0,"stats":{"Line":48}},{"line":193,"address":[],"length":0,"stats":{"Line":22}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":4}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":30}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":2}}],"covered":42,"coverable":86},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","collector.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::{Arc, RwLock};\n\n/// Performance metrics collector for system performance monitoring\n#[derive(Debug, Default)]\npub struct MetricsCollector {\n    counters: Arc\u003cRwLock\u003cHashMap\u003cString, AtomicU64\u003e\u003e\u003e,\n    gauges: Arc\u003cRwLock\u003cHashMap\u003cString, AtomicU64\u003e\u003e\u003e,\n}\n\nimpl MetricsCollector {\n    /// Creates a new metrics collector\n    pub fn new() -\u003e Self {\n        Self {\n            counters: Arc::new(RwLock::new(HashMap::new())),\n            gauges: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Increments a named counter by 1\n    pub fn increment_counter(\u0026self, name: \u0026str) {\n        if let Some(counter) = self.counters.read().unwrap().get(name) {\n            counter.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    /// Sets a gauge to a specific value\n    pub fn set_gauge(\u0026self, name: \u0026str, value: u64) {\n        if let Some(gauge) = self.gauges.read().unwrap().get(name) {\n            gauge.store(value, Ordering::Relaxed);\n        }\n    }\n\n    /// Gets the current value of a counter\n    pub fn get_counter(\u0026self, name: \u0026str) -\u003e u64 {\n        self.counters\n            .read()\n            .unwrap()\n            .get(name)\n            .map(|c| c.load(Ordering::Relaxed))\n            .unwrap_or(0)\n    }\n\n    /// Gets the current value of a gauge\n    pub fn get_gauge(\u0026self, name: \u0026str) -\u003e u64 {\n        self.gauges\n            .read()\n            .unwrap()\n            .get(name)\n            .map(|g| g.load(Ordering::Relaxed))\n            .unwrap_or(0)\n    }\n}\n\n/// System-wide performance metrics snapshot\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SystemMetrics {\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Total number of events processed\n    pub total_events_processed: u64,\n    /// Current events processing rate per second\n    pub events_per_second: f64,\n    /// Memory usage in megabytes\n    pub memory_usage_mb: u64,\n    /// CPU usage as a percentage\n    pub cpu_usage_percent: f64,\n    /// Number of active connections\n    pub active_connections: u64,\n}\n\nimpl SystemMetrics {\n    /// Creates a new system metrics snapshot with default values\n    pub fn new() -\u003e Self {\n        Self {\n            uptime_seconds: 0,\n            total_events_processed: 0,\n            events_per_second: 0.0,\n            memory_usage_mb: 0,\n            cpu_usage_percent: 0.0,\n            active_connections: 0,\n        }\n    }\n}\n\nimpl Default for SystemMetrics {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_metrics_collector() {\n        let collector = MetricsCollector::new();\n\n        // Test counter operations\n        collector.increment_counter(\"test_counter\");\n        assert_eq!(collector.get_counter(\"test_counter\"), 0); // No counter registered\n\n        // Test gauge operations\n        collector.set_gauge(\"test_gauge\", 42);\n        assert_eq!(collector.get_gauge(\"test_gauge\"), 0); // No gauge registered\n\n        // Test non-existent metrics\n        assert_eq!(collector.get_counter(\"non_existent\"), 0);\n        assert_eq!(collector.get_gauge(\"non_existent\"), 0);\n    }\n\n    #[test]\n    fn test_system_metrics() {\n        let metrics = SystemMetrics::new();\n        assert_eq!(metrics.uptime_seconds, 0);\n        assert_eq!(metrics.total_events_processed, 0);\n        assert_eq!(metrics.events_per_second, 0.0);\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":18},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","exporter.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse tokio::time::{Duration, Instant};\n\n/// Metrics exporter for external monitoring systems\n#[derive(Debug, Clone)]\npub struct MetricsExporter {\n    start_time: Instant,\n    export_interval: Duration,\n}\n\nimpl MetricsExporter {\n    /// Creates a new metrics exporter with specified export interval\n    pub fn new(export_interval: Duration) -\u003e Self {\n        Self {\n            start_time: Instant::now(),\n            export_interval,\n        }\n    }\n\n    /// Returns the uptime since exporter creation\n    pub fn uptime(\u0026self) -\u003e Duration {\n        self.start_time.elapsed()\n    }\n\n    /// Returns the configured export interval\n    pub fn export_interval(\u0026self) -\u003e Duration {\n        self.export_interval\n    }\n\n    /// Export metrics in Prometheus format\n    pub fn export_prometheus(\u0026self, metrics: \u0026HashMap\u003cString, f64\u003e) -\u003e String {\n        let mut output = String::new();\n\n        for (name, value) in metrics {\n            output.push_str(\u0026format!(\"# TYPE {} gauge\\n\", name));\n            output.push_str(\u0026format!(\"{} {}\\n\", name, value));\n        }\n\n        output\n    }\n\n    /// Export metrics in JSON format\n    pub fn export_json(\u0026self, metrics: \u0026HashMap\u003cString, f64\u003e) -\u003e Result\u003cString, serde_json::Error\u003e {\n        let export_data = MetricsExport {\n            timestamp: chrono::Utc::now(),\n            uptime_seconds: self.uptime().as_secs(),\n            metrics: metrics.clone(),\n        };\n\n        serde_json::to_string_pretty(\u0026export_data)\n    }\n}\n\nimpl Default for MetricsExporter {\n    fn default() -\u003e Self {\n        Self::new(Duration::from_secs(60))\n    }\n}\n\n/// Metrics export data structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsExport {\n    /// Timestamp when metrics were exported\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Map of metric names to values\n    pub metrics: HashMap\u003cString, f64\u003e,\n}\n\n/// Health status information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HealthStatus {\n    /// Overall system status\n    pub status: String,\n    /// System version\n    pub version: String,\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Timestamp of health check\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    /// Health status of individual components\n    pub components: HashMap\u003cString, ComponentHealth\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n/// Health status of an individual system component\npub struct ComponentHealth {\n    /// Component status (healthy/unhealthy)\n    pub status: String,\n    /// Timestamp of last health check\n    pub last_check: chrono::DateTime\u003cchrono::Utc\u003e,\n    /// Optional details about component status\n    pub details: Option\u003cString\u003e,\n}\n\nimpl HealthStatus {\n    /// Creates a new health status with the given version and uptime\n    pub fn new(version: \u0026str, uptime: Duration) -\u003e Self {\n        Self {\n            status: \"healthy\".to_string(),\n            version: version.to_string(),\n            uptime_seconds: uptime.as_secs(),\n            timestamp: chrono::Utc::now(),\n            components: HashMap::new(),\n        }\n    }\n\n    /// Adds a component health status\n    pub fn add_component(\u0026mut self, name: String, health: ComponentHealth) {\n        self.components.insert(name, health);\n    }\n\n    /// Returns true if all components are healthy\n    pub fn is_healthy(\u0026self) -\u003e bool {\n        self.status == \"healthy\" \u0026\u0026 self.components.values().all(|c| c.status == \"healthy\")\n    }\n}\n\nimpl ComponentHealth {\n    /// Creates a healthy component status\n    pub fn healthy() -\u003e Self {\n        Self {\n            status: \"healthy\".to_string(),\n            last_check: chrono::Utc::now(),\n            details: None,\n        }\n    }\n\n    /// Creates an unhealthy component status with details\n    pub fn unhealthy(details: String) -\u003e Self {\n        Self {\n            status: \"unhealthy\".to_string(),\n            last_check: chrono::Utc::now(),\n            details: Some(details),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_metrics_exporter() {\n        let exporter = MetricsExporter::new(Duration::from_secs(30));\n        assert_eq!(exporter.export_interval(), Duration::from_secs(30));\n        // Just verify uptime is available\n        let _uptime = exporter.uptime();\n    }\n\n    #[test]\n    fn test_prometheus_export() {\n        let exporter = MetricsExporter::default();\n        let mut metrics = HashMap::new();\n        metrics.insert(\"test_metric\".to_string(), 42.0);\n        metrics.insert(\"another_metric\".to_string(), std::f64::consts::PI);\n\n        let prometheus_output = exporter.export_prometheus(\u0026metrics);\n        assert!(prometheus_output.contains(\"# TYPE test_metric gauge\"));\n        assert!(prometheus_output.contains(\"test_metric 42\"));\n        assert!(prometheus_output.contains(\"another_metric 3.14\"));\n    }\n\n    #[test]\n    fn test_json_export() {\n        let exporter = MetricsExporter::default();\n        let mut metrics = HashMap::new();\n        metrics.insert(\"test_metric\".to_string(), 42.0);\n\n        let json_output = exporter.export_json(\u0026metrics).unwrap();\n        assert!(json_output.contains(\"test_metric\"));\n        assert!(json_output.contains(\"42\"));\n        assert!(json_output.contains(\"timestamp\"));\n        assert!(json_output.contains(\"uptime_seconds\"));\n    }\n\n    #[test]\n    fn test_health_status() {\n        let mut health = HealthStatus::new(\"1.0.0\", Duration::from_secs(3600));\n        assert_eq!(health.status, \"healthy\");\n        assert_eq!(health.version, \"1.0.0\");\n        assert_eq!(health.uptime_seconds, 3600);\n        assert!(health.is_healthy());\n\n        health.add_component(\"orderbook\".to_string(), ComponentHealth::healthy());\n        assert!(health.is_healthy());\n\n        health.add_component(\n            \"amm\".to_string(),\n            ComponentHealth::unhealthy(\"Connection lost\".to_string()),\n        );\n        assert!(!health.is_healthy());\n    }\n\n    #[test]\n    fn test_component_health() {\n        let healthy = ComponentHealth::healthy();\n        assert_eq!(healthy.status, \"healthy\");\n        assert!(healthy.details.is_none());\n\n        let unhealthy = ComponentHealth::unhealthy(\"Database connection failed\".to_string());\n        assert_eq!(unhealthy.status, \"unhealthy\");\n        assert_eq!(\n            unhealthy.details,\n            Some(\"Database connection failed\".to_string())\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":16}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":12}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}}],"covered":34,"coverable":34},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","mod.rs"],"content":"//! Metrics collection and export functionality\n//!\n//! This module provides comprehensive metrics collection, aggregation, and export capabilities\n//! for monitoring system performance and health.\n\n/// Metrics collection utilities\npub mod collector;\n/// Metrics export and health monitoring\npub mod exporter;\n\npub use collector::*;\npub use exporter::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","mod.rs"],"content":"//! Infrastructure layer providing data ingestion, metrics, and parsing capabilities\n//!\n//! This module contains the infrastructure components that support the domain layer,\n//! including stream ingestion, metrics collection, and data parsing utilities.\n\n/// Stream ingestion utilities for real-time market data\npub mod ingestion;\n/// Metrics collection and export functionality\npub mod metrics;\n/// Data parsing utilities for various market data formats\npub mod parsers;\n\npub use ingestion::*;\npub use parsers::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","parsers","json_parser.rs"],"content":"use crate::domain::{events::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::Deserialize;\nuse std::collections::BTreeMap;\nuse std::str::FromStr;\n\n/// Raw JSON structures for parsing the provided data files\n/// Raw order book snapshot from JSON\n#[derive(Debug, Deserialize)]\nstruct RawOrderBookSnapshot {\n    #[serde(rename = \"type\")]\n    event_type: String,\n    symbol: String,\n    seq: u64,\n    ts: String,\n    bids: Vec\u003cVec\u003cString\u003e\u003e,\n    asks: Vec\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Raw order book delta from JSON\n#[derive(Debug, Deserialize)]\nstruct RawOrderBookDelta {\n    #[serde(rename = \"type\")]\n    event_type: String,\n    symbol: String,\n    seq: u64,\n    ts: String,\n    bids: Vec\u003cVec\u003cString\u003e\u003e,\n    asks: Vec\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Raw AMM pool from JSON\n#[derive(Debug, Deserialize)]\nstruct RawAMMPool {\n    pool: String,\n    fee: u32,\n    ts: String,\n    reserves: RawReserves,\n    #[serde(rename = \"sqrtPriceX96\")]\n    sqrt_price_x96: Option\u003cString\u003e,\n}\n\n/// Raw reserves from JSON\n#[derive(Debug, Deserialize)]\nstruct RawReserves {\n    amount0: String,\n    amount1: String,\n}\n\n/// Parse order book snapshot from JSON string\npub fn parse_lob_snapshot(json_str: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookSnapshot)\u003e {\n    let raw: RawOrderBookSnapshot = serde_json::from_str(json_str)?;\n\n    if raw.event_type != \"snapshot\" {\n        return Err(TradingError::ParseError(format!(\n            \"Expected snapshot type, got: {}\",\n            raw.event_type\n        )));\n    }\n\n    let symbol = Symbol(raw.symbol);\n    let sequence = SequenceNumber(raw.seq);\n    let timestamp = parse_timestamp(\u0026raw.ts)?;\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n\n    // Parse bids (price, quantity pairs)\n    for bid in raw.bids {\n        if bid.len() != 2 {\n            return Err(TradingError::ParseError(\"Invalid bid format\".to_string()));\n        }\n        let price = Price(\n            Decimal::from_str(\u0026bid[0])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid price: {}\", e)))?,\n        );\n        let quantity = Quantity(\n            Decimal::from_str(\u0026bid[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid quantity: {}\", e)))?,\n        );\n        bids.insert(price, quantity);\n    }\n\n    // Parse asks (price, quantity pairs)\n    for ask in raw.asks {\n        if ask.len() != 2 {\n            return Err(TradingError::ParseError(\"Invalid ask format\".to_string()));\n        }\n        let price = Price(\n            Decimal::from_str(\u0026ask[0])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask price: {}\", e)))?,\n        );\n        let quantity = Quantity(\n            Decimal::from_str(\u0026ask[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask quantity: {}\", e)))?,\n        );\n        asks.insert(price, quantity);\n    }\n\n    let snapshot = OrderBookSnapshot::with_levels(sequence, timestamp, bids, asks);\n    Ok((symbol, snapshot))\n}\n\n/// Parse order book delta from JSON string\npub fn parse_lob_delta(json_str: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookDelta)\u003e {\n    let raw: RawOrderBookDelta = serde_json::from_str(json_str)?;\n\n    if raw.event_type != \"delta\" {\n        return Err(TradingError::ParseError(format!(\n            \"Expected delta type, got: {}\",\n            raw.event_type\n        )));\n    }\n\n    let symbol = Symbol(raw.symbol);\n    let sequence = SequenceNumber(raw.seq);\n    let timestamp = parse_timestamp(\u0026raw.ts)?;\n\n    let mut updates = Vec::new();\n\n    // Parse bid updates (action, price, quantity)\n    for bid in raw.bids {\n        if bid.len() != 3 {\n            return Err(TradingError::ParseError(\n                \"Invalid bid delta format\".to_string(),\n            ));\n        }\n\n        let action = match bid[0].as_str() {\n            \"u\" =\u003e UpdateAction::Update,\n            \"d\" =\u003e UpdateAction::Delete,\n            \"n\" =\u003e UpdateAction::Update, // New level is same as update\n            _ =\u003e {\n                return Err(TradingError::ParseError(format!(\n                    \"Invalid bid action: {}\",\n                    bid[0]\n                )))\n            }\n        };\n\n        let price = Price(\n            Decimal::from_str(\u0026bid[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid price: {}\", e)))?,\n        );\n\n        let quantity =\n            if action == UpdateAction::Delete {\n                Quantity::zero()\n            } else {\n                Quantity(Decimal::from_str(\u0026bid[2]).map_err(|e| {\n                    TradingError::ParseError(format!(\"Invalid bid quantity: {}\", e))\n                })?)\n            };\n\n        updates.push(PriceLevelUpdate::new(Side::Bid, price, quantity, action));\n    }\n\n    // Parse ask updates (action, price, quantity)\n    for ask in raw.asks {\n        if ask.len() != 3 {\n            return Err(TradingError::ParseError(\n                \"Invalid ask delta format\".to_string(),\n            ));\n        }\n\n        let action = match ask[0].as_str() {\n            \"u\" =\u003e UpdateAction::Update,\n            \"d\" =\u003e UpdateAction::Delete,\n            \"n\" =\u003e UpdateAction::Update, // New level is same as update\n            _ =\u003e {\n                return Err(TradingError::ParseError(format!(\n                    \"Invalid ask action: {}\",\n                    ask[0]\n                )))\n            }\n        };\n\n        let price = Price(\n            Decimal::from_str(\u0026ask[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask price: {}\", e)))?,\n        );\n\n        let quantity =\n            if action == UpdateAction::Delete {\n                Quantity::zero()\n            } else {\n                Quantity(Decimal::from_str(\u0026ask[2]).map_err(|e| {\n                    TradingError::ParseError(format!(\"Invalid ask quantity: {}\", e))\n                })?)\n            };\n\n        updates.push(PriceLevelUpdate::new(Side::Ask, price, quantity, action));\n    }\n\n    let delta = OrderBookDelta::with_updates(sequence, timestamp, updates);\n    Ok((symbol, delta))\n}\n\n/// Parse AMM pool data from JSON string\npub fn parse_amm_pool(json_str: \u0026str) -\u003e TradingResult\u003c(PoolAddress, AMMPoolUpdate)\u003e {\n    let raw: RawAMMPool = serde_json::from_str(json_str)?;\n\n    let address = PoolAddress(raw.pool);\n    let timestamp = parse_timestamp(\u0026raw.ts)?;\n    let fee_tier = FeeTier(raw.fee);\n\n    let token0_reserve = Decimal::from_str(\u0026raw.reserves.amount0)\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid token0 reserve: {}\", e)))?;\n    let token1_reserve = Decimal::from_str(\u0026raw.reserves.amount1)\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid token1 reserve: {}\", e)))?;\n    let reserves = TokenReserves::new(token0_reserve, token1_reserve);\n\n    // Parse sqrt price if available\n    let sqrt_price = if let Some(sqrt_price_str) = raw.sqrt_price_x96 {\n        let sqrt_price_u128 = u128::from_str(\u0026sqrt_price_str)\n            .map_err(|e| TradingError::ParseError(format!(\"Invalid sqrtPriceX96: {}\", e)))?;\n        Some(SqrtPriceX96(sqrt_price_u128))\n    } else {\n        None\n    };\n\n    let update = AMMPoolUpdate::new(timestamp, reserves, sqrt_price, fee_tier);\n    Ok((address, update))\n}\n\n/// Parse timestamp from ISO 8601 string\nfn parse_timestamp(ts_str: \u0026str) -\u003e TradingResult\u003cTimestamp\u003e {\n    chrono::DateTime::parse_from_rfc3339(ts_str)\n        .map(|dt| dt.with_timezone(\u0026chrono::Utc))\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid timestamp: {}\", e)))\n}\n\n/// Load and parse order book snapshot from file\npub fn load_lob_snapshot(file_path: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookSnapshot)\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_lob_snapshot(\u0026content)\n}\n\n/// Load and parse order book delta from file\npub fn load_lob_delta(file_path: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookDelta)\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_lob_delta(\u0026content)\n}\n\n/// Load and parse AMM pool from file\npub fn load_amm_pool(file_path: \u0026str) -\u003e TradingResult\u003c(PoolAddress, AMMPoolUpdate)\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_amm_pool(\u0026content)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_parse_lob_snapshot() {\n        let json = r#\"{\n            \"type\": \"snapshot\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1000,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"bids\": [\n                [\"2445.12\", \"3.1005\"],\n                [\"2445.11\", \"1.20\"]\n            ],\n            \"asks\": [\n                [\"2445.13\", \"2.05\"],\n                [\"2445.14\", \"1.50\"]\n            ]\n        }\"#;\n\n        let (symbol, snapshot) = parse_lob_snapshot(json).unwrap();\n\n        assert_eq!(symbol, Symbol(\"ETHUSDC\".to_string()));\n        assert_eq!(snapshot.sequence, SequenceNumber(1000));\n        assert_eq!(snapshot.bids.len(), 2);\n        assert_eq!(snapshot.asks.len(), 2);\n\n        // Check best bid and ask\n        assert_eq!(snapshot.best_bid(), Some(\u0026Price(dec!(2445.12))));\n        assert_eq!(snapshot.best_ask(), Some(\u0026Price(dec!(2445.13))));\n    }\n\n    #[test]\n    fn test_parse_lob_delta() {\n        let json = r#\"{\n            \"type\": \"delta\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1001,\n            \"ts\": \"2025-01-01T10:00:00.050Z\",\n            \"bids\": [\n                [\"u\", \"2445.12\", \"3.0000\"]\n            ],\n            \"asks\": [\n                [\"n\", \"2445.15\", \"1.00\"]\n            ]\n        }\"#;\n\n        let (symbol, delta) = parse_lob_delta(json).unwrap();\n\n        assert_eq!(symbol, Symbol(\"ETHUSDC\".to_string()));\n        assert_eq!(delta.sequence, SequenceNumber(1001));\n        assert_eq!(delta.updates.len(), 2);\n\n        // Check updates\n        let bid_update = \u0026delta.updates[0];\n        assert_eq!(bid_update.side, Side::Bid);\n        assert_eq!(bid_update.price, Price(dec!(2445.12)));\n        assert_eq!(bid_update.quantity, Quantity(dec!(3.0000)));\n        assert_eq!(bid_update.action, UpdateAction::Update);\n\n        let ask_update = \u0026delta.updates[1];\n        assert_eq!(ask_update.side, Side::Ask);\n        assert_eq!(ask_update.price, Price(dec!(2445.15)));\n        assert_eq!(ask_update.quantity, Quantity(dec!(1.00)));\n        assert_eq!(ask_update.action, UpdateAction::Update);\n    }\n\n    #[test]\n    fn test_parse_amm_pool() {\n        let json = r#\"{\n            \"pool\": \"0xPOOL\",\n            \"venue\": \"uniswap_v3\",\n            \"pair\": \"WETH/USDC\",\n            \"fee\": 5,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"reserves\": {\n                \"token0\": \"WETH\",\n                \"token1\": \"USDC\",\n                \"amount0\": \"1000.0000\",\n                \"amount1\": \"2445000.00\"\n            },\n            \"sqrtPriceX96\": \"79228162514264337593543950336\"\n        }\"#;\n\n        let (address, update) = parse_amm_pool(json).unwrap();\n\n        assert_eq!(address, PoolAddress(\"0xPOOL\".to_string()));\n        assert_eq!(update.fee_tier, FeeTier(5));\n        assert_eq!(update.reserves.token0, dec!(1000.0000));\n        assert_eq!(update.reserves.token1, dec!(2445000.00));\n        assert!(update.sqrt_price.is_some());\n\n        // Check implied price from reserves\n        let implied_price = update.implied_mid_from_reserves();\n        assert_eq!(implied_price, Price(dec!(2445.0))); // 2445000 / 1000\n    }\n\n    #[test]\n    fn test_parse_delta_delete_action() {\n        let json = r#\"{\n            \"type\": \"delta\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1002,\n            \"ts\": \"2025-01-01T10:00:00.100Z\",\n            \"bids\": [\n                [\"d\", \"2445.11\", \"0\"]\n            ],\n            \"asks\": []\n        }\"#;\n\n        let (_, delta) = parse_lob_delta(json).unwrap();\n\n        assert_eq!(delta.updates.len(), 1);\n        let update = \u0026delta.updates[0];\n        assert_eq!(update.action, UpdateAction::Delete);\n        assert!(update.quantity.is_zero());\n    }\n\n    #[test]\n    fn test_invalid_json_format() {\n        let json = r#\"{\"invalid\": \"format\"}\"#;\n        let result = parse_lob_snapshot(json);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_decimal_parsing() {\n        let json = r#\"{\n            \"type\": \"snapshot\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1000,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"bids\": [\n                [\"invalid_price\", \"3.1005\"]\n            ],\n            \"asks\": []\n        }\"#;\n\n        let result = parse_lob_snapshot(json);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Invalid bid price\"));\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":24}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":24}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":18}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":18}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":228,"address":[],"length":0,"stats":{"Line":32}},{"line":229,"address":[],"length":0,"stats":{"Line":64}},{"line":230,"address":[],"length":0,"stats":{"Line":16}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":6}}],"covered":45,"coverable":77},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","parsers","mod.rs"],"content":"//! JSON parsing utilities for market data\n//!\n//! This module provides parsers for converting JSON market data into domain types.\n\n/// JSON parser for market data formats\npub mod json_parser;\n\npub use json_parser::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","lib.rs"],"content":"//! # Quant Trading System\n//!\n//! A high-performance, thread-safe quantitative trading system implementing:\n//! - CLOB (Central Limit Order Book) L2 order books with fast top-of-book access\n//! - AMM (Automated Market Maker) pools with price impact calculations\n//! - Real-time arbitrage detection between venues\n//! - Concurrent stream ingestion with backpressure handling\n//! - JSON parsing for market data feeds\n//!\n//! ## Architecture\n//!\n//! The system follows domain-driven design principles with clear separation of concerns:\n//!\n//! - **Domain**: Core business logic (order books, AMM pools, arbitrage detection)\n//! - **Infrastructure**: External concerns (JSON parsing, stream ingestion, metrics)\n//! - **Application**: Use cases and orchestration\n//!\n//! ## Thread Safety\n//!\n//! All data structures use `std::sync::RwLock` for concurrent access:\n//! - Multiple concurrent readers\n//! - Single writer exclusion\n//! - Atomic snapshots without blocking writers\n//!\n//! ## Performance Characteristics\n//!\n//! - **Latency**: Sub-microsecond order book operations\n//! - **Throughput**: 1M+ updates/second per symbol\n//! - **Memory**: O(n) where n = number of price levels\n//! - **Concurrency**: Lock-free reads, minimal write contention\n\npub mod domain;\npub mod infrastructure;\n\n/// Utilities for logging and metrics reporting\npub mod utils;\n\n// Re-export commonly used types for convenience\npub use domain::{\n    amm_pool::{AMMPool, AMMPoolType, PriceImpactResult, ThreadSafeAMMPool, TokenIndex},\n    arbitrage::{ArbitrageDetector, ArbitrageOpportunity, Venue},\n    events::*,\n    market_data::{MarketDataManager, MarketMetrics},\n    order_book::{OrderBookL2, ThreadSafeOrderBook},\n    types::*,\n};\n\npub use infrastructure::{\n    ingestion::{IngestionStats, MultiStreamIngester, StatisticalStreamIngester, StreamIngester},\n    parsers::{\n        load_amm_pool, load_lob_delta, load_lob_snapshot, parse_amm_pool, parse_lob_delta,\n        parse_lob_snapshot,\n    },\n};\n\n/// Main result type for the trading system\npub type Result\u003cT\u003e = std::result::Result\u003cT, TradingError\u003e;\n\n/// Version information\npub const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n    use std::sync::Arc;\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn test_full_system_integration() {\n        // Initialize logging for tests\n        let _ = tracing_subscriber::fmt::try_init();\n\n        // Create market data manager\n        let manager = Arc::new(MarketDataManager::new());\n\n        // Create stream ingester\n        let (tx, rx) = mpsc::channel(1000);\n        let mut ingester = StreamIngester::new(rx, manager.clone());\n\n        // Load and send initial data\n        let snapshot_result = load_lob_snapshot(\"data/LOB_snapshot.json\");\n        if let Ok((symbol, snapshot)) = snapshot_result {\n            let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n            tx.send(event).await.unwrap();\n        }\n\n        let delta_result = load_lob_delta(\"data/LOB_delta.json\");\n        if let Ok((symbol, delta)) = delta_result {\n            let event = MarketEvent::OrderBookDelta(symbol, delta);\n            tx.send(event).await.unwrap();\n        }\n\n        let amm_result = load_amm_pool(\"data/amm_pool.json\");\n        if let Ok((address, update)) = amm_result {\n            let event = MarketEvent::AMMUpdate(address, update);\n            tx.send(event).await.unwrap();\n        }\n\n        // Close sender\n        drop(tx);\n\n        // Run ingester\n        tokio::spawn(async move {\n            ingester.run().await;\n        });\n\n        // Give some time for processing\n        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n        // Test arbitrage detection if we have both order book and AMM data\n        let symbols = manager.get_orderbook_symbols();\n        let pools = manager.get_amm_pool_addresses();\n\n        if !symbols.is_empty() \u0026\u0026 !pools.is_empty() {\n            let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n\n            if let (Some(book), Some(pool)) = (\n                manager.get_orderbook(\u0026symbols[0]),\n                manager.get_amm_pool(\u0026pools[0]),\n            ) {\n                let opportunity = detector.check_arbitrage(\u0026book, \u0026pool);\n                // Arbitrage opportunity may or may not exist depending on the data\n                println!(\"Arbitrage opportunity: {:?}\", opportunity);\n            }\n        }\n\n        // Get final metrics\n        let metrics = manager.get_market_metrics();\n        println!(\n            \"Final metrics: {} order books, {} AMM pools\",\n            metrics.orderbook_metrics.len(),\n            metrics.amm_metrics.len()\n        );\n    }\n\n    #[test]\n    fn test_order_book_operations() {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Create test snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2445.12)), Quantity(dec!(3.1005)));\n        snapshot\n            .bids\n            .insert(Price(dec!(2445.11)), Quantity(dec!(1.20)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2445.13)), Quantity(dec!(2.05)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2445.14)), Quantity(dec!(1.50)));\n\n        // Apply snapshot\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test basic operations\n        assert_eq!(book.best_bid(), Some(Price(dec!(2445.12))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(2445.13))));\n        assert_eq!(book.mid_price(), Some(Price(dec!(2445.125))));\n        assert_eq!(book.spread(), Some(Price(dec!(0.01))));\n\n        // Test depth calculation\n        let bid_depth = book.depth_to_price(Side::Bid, Price(dec!(2445.11)));\n        assert_eq!(bid_depth, Quantity(dec!(4.3005))); // 3.1005 + 1.20\n    }\n\n    #[test]\n    fn test_amm_pool_operations() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2445000.0));\n        let pool = ThreadSafeAMMPool::new_v2(\n            PoolAddress(\"0xTEST\".to_string()),\n            reserves,\n            FeeTier(30), // 0.3%\n        );\n\n        // Test basic operations\n        assert_eq!(pool.implied_mid(), Price(dec!(2445.0)));\n        assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n\n        // Test price impact calculation\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(10.0))\n            .unwrap();\n\n        // Should have some price impact and fee\n        assert!(result.price_impact_percent \u003e dec!(0.0));\n        assert_eq!(result.fee_amount, dec!(0.03)); // 0.3% of 10.0\n        assert!(result.output_amount \u003e dec!(0.0));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","main.rs"],"content":"//! # Quant Trading System\n//!\n//! A high-performance quantitative trading system with real-time market data processing,\n//! order book management, AMM pool integration, and arbitrage detection.\n//!\n//! This binary provides an example entry point that demonstrates the full system capabilities\n//! including market data ingestion, real-time processing, arbitrage monitoring, and metrics API.\n\nuse quant_trading_system::utils::logger::setup_logger;\nuse quant_trading_system::*;\nuse rust_decimal_macros::dec;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::error;\nuse tracing::log::info;\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    // Initialize tracing/logging\n    info!(\"Initializing tracing subscriber...\");\n    setup_logger().expect(\"Failed to initialize logger\");\n    info!(\"Tracing subscriber initialized\");\n\n    info!(\"Starting Quant Trading System v{}\", VERSION);\n    info!(\"Initializing system components...\");\n\n    // Create the market data manager\n    info!(\"Creating market data manager...\");\n    let manager = Arc::new(MarketDataManager::new());\n    info!(\"Market data manager created successfully\");\n\n    // Create channels for different data streams\n    info!(\"Setting up communication channels...\");\n    let (market_tx, market_rx) = mpsc::channel::\u003cMarketEvent\u003e(1000);\n    info!(\"Channels created with buffer size 1000\");\n\n    // Start the stream ingester FIRST\n    info!(\"Starting stream ingester task...\");\n    let manager_clone = Arc::clone(\u0026manager);\n    let _ingester_handle = tokio::spawn(async move {\n        info!(\"Stream ingester task started\");\n        let mut ingester = StreamIngester::new(market_rx, manager_clone);\n        info!(\"Running stream ingester...\");\n        ingester.run().await;\n    });\n    info!(\"Stream ingester task spawned\");\n\n    // Load initial data from JSON files\n    info!(\"Loading initial market data from JSON files...\");\n    load_initial_data(\u0026market_tx).await?;\n    info!(\"Initial market data loaded successfully\");\n\n    // Give some time for events to be processed\n    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n    info!(\"Events processed, continuing with setup...\");\n\n    // Start real-time simulation (simulated here with periodic updates)\n    info!(\"Starting real-time simulation task...\");\n    let market_tx_clone = market_tx.clone();\n    tokio::spawn(async move {\n        info!(\"Real-time simulation task started\");\n        simulate_real_time_updates(market_tx_clone).await;\n    });\n    info!(\"Real-time simulation task spawned\");\n\n    // Start arbitrage monitoring\n    info!(\"Starting arbitrage monitoring task...\");\n    let manager_clone = Arc::clone(\u0026manager);\n    tokio::spawn(async move {\n        info!(\"Arbitrage monitoring task started\");\n        monitor_arbitrage(manager_clone).await;\n    });\n    info!(\"Arbitrage monitoring task spawned\");\n\n    // Start metrics API server\n    info!(\"Starting metrics API server...\");\n    expose_metrics_api(manager).await;\n    info!(\"Metrics API server started\");\n\n    Ok(())\n}\n\nasync fn load_initial_data(tx: \u0026mpsc::Sender\u003cMarketEvent\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    info!(\"Loading order book snapshot from data/LOB_snapshot.json...\");\n\n    // Load snapshot from file\n    match load_lob_snapshot(\"data/LOB_snapshot.json\") {\n        Ok((symbol, snapshot)) =\u003e {\n            info!(\"Loaded snapshot for symbol: {}\", symbol);\n            tx.send(MarketEvent::OrderBookSnapshot(symbol, snapshot))\n                .await?;\n        }\n        Err(e) =\u003e {\n            error!(\"Failed to load order book snapshot: {}\", e);\n        }\n    }\n\n    // Load delta updates\n    info!(\"Loading order book delta from data/LOB_delta.json...\");\n    match load_lob_delta(\"data/LOB_delta.json\") {\n        Ok((symbol, delta)) =\u003e {\n            info!(\n                \"Loaded delta for symbol: {}, seq: {}\",\n                symbol, delta.sequence\n            );\n            tx.send(MarketEvent::OrderBookDelta(symbol, delta)).await?;\n        }\n        Err(e) =\u003e {\n            error!(\"Failed to load order book delta: {}\", e);\n        }\n    }\n\n    // Load AMM pool state\n    info!(\"Loading AMM pool data from data/amm_pool.json...\");\n    match load_amm_pool(\"data/amm_pool.json\") {\n        Ok((address, update)) =\u003e {\n            info!(\"Loaded AMM pool for address: {}\", address);\n            tx.send(MarketEvent::AMMUpdate(address, update)).await?;\n        }\n        Err(e) =\u003e {\n            error!(\"Failed to load AMM pool: {}\", e);\n        }\n    }\n\n    info!(\"Initial data loading completed\");\n    Ok(())\n}\n\nasync fn simulate_real_time_updates(tx: mpsc::Sender\u003cMarketEvent\u003e) {\n    info!(\"Starting real-time market data simulation...\");\n\n    let mut interval = tokio::time::interval(tokio::time::Duration::from_millis(100));\n    let mut seq = 1001u64;\n\n    loop {\n        interval.tick().await;\n\n        // Simulate order book updates\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(seq),\n            chrono::Utc::now(),\n            vec![\n                PriceLevelUpdate::update(\n                    Side::Bid,\n                    Price(dec!(2445) + rust_decimal::Decimal::from(seq % 10)),\n                    Quantity(dec!(1) + rust_decimal::Decimal::from(seq % 5)),\n                ),\n                PriceLevelUpdate::update(\n                    Side::Ask,\n                    Price(dec!(2446) + rust_decimal::Decimal::from(seq % 10)),\n                    Quantity(dec!(1) + rust_decimal::Decimal::from(seq % 3)),\n                ),\n            ],\n        );\n\n        if tx\n            .send(MarketEvent::OrderBookDelta(\n                Symbol(\"ETHUSDC\".to_string()),\n                delta,\n            ))\n            .await\n            .is_err()\n        {\n            break; // Channel closed\n        }\n\n        // Occasionally simulate AMM pool updates\n        if seq % 50 == 0 {\n            let new_reserves = TokenReserves::new(\n                dec!(1000) + rust_decimal::Decimal::from(seq % 100),\n                dec!(2445000) + rust_decimal::Decimal::from(seq % 10000),\n            );\n\n            let amm_update =\n                AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n            if tx\n                .send(MarketEvent::AMMUpdate(\n                    PoolAddress(\"0xPOOL\".to_string()),\n                    amm_update,\n                ))\n                .await\n                .is_err()\n            {\n                break;\n            }\n        }\n\n        seq += 1;\n\n        // Stop after some time for demo purposes\n        if seq \u003e 2000 {\n            info!(\"Simulation completed after {} updates\", seq - 1001);\n            break;\n        }\n    }\n}\n\nasync fn monitor_arbitrage(manager: Arc\u003cMarketDataManager\u003e) {\n    info!(\"Starting arbitrage monitoring loop...\");\n\n    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(1));\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    loop {\n        interval.tick().await;\n\n        // Get all order books and AMM pools\n        let symbols = manager.get_orderbook_symbols();\n        let addresses = manager.get_amm_pool_addresses();\n\n        // Check each combination for arbitrage\n        for symbol in \u0026symbols {\n            if let Some(book) = manager.get_orderbook(symbol) {\n                for address in \u0026addresses {\n                    if let Some(pool) = manager.get_amm_pool(address) {\n                        if let Some(opportunity) = detector.check_arbitrage(\u0026book, \u0026pool) {\n                            info!(\n                                \"ARBITRAGE DETECTED! Buy {} @ {:.2}, Sell {} @ {:.2}, Profit: {:.2}%, Max Qty: {}\",\n                                opportunity.buy_venue,\n                                opportunity.buy_price,\n                                opportunity.sell_venue,\n                                opportunity.sell_price,\n                                opportunity.profit_percent,\n                                opportunity.max_quantity\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nasync fn expose_metrics_api(manager: Arc\u003cMarketDataManager\u003e) {\n    info!(\"Starting metrics API server on port 3030...\");\n    info!(\"Setting up API routes...\");\n\n    use warp::Filter;\n\n    let manager = warp::any().map(move || Arc::clone(\u0026manager));\n\n    // Metrics endpoint\n    let metrics = warp::path(\"metrics\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc\u003cMarketDataManager\u003e| {\n            let metrics = mgr.get_market_metrics();\n            warp::reply::json(\u0026metrics)\n        });\n\n    // Health check endpoint\n    let _health = warp::path(\"health\").and(warp::get()).map(|| {\n        warp::reply::json(\u0026serde_json::json!({\n            \"status\": \"healthy\",\n            \"version\": VERSION,\n            \"timestamp\": chrono::Utc::now()\n        }))\n    });\n\n    // Order book endpoint\n    let orderbooks = warp::path(\"orderbooks\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc\u003cMarketDataManager\u003e| {\n            let symbols = mgr.get_orderbook_symbols();\n            let mut books = std::collections::HashMap::new();\n\n            for symbol in symbols {\n                if let Some(book) = mgr.get_orderbook(\u0026symbol) {\n                    books.insert(\n                        symbol.to_string(),\n                        serde_json::json!({\n                            \"symbol\": symbol,\n                            \"best_bid\": book.best_bid(),\n                            \"best_ask\": book.best_ask(),\n                            \"mid_price\": book.mid_price(),\n                            \"spread\": book.spread(),\n                            \"last_update\": book.last_update()\n                        }),\n                    );\n                }\n            }\n\n            warp::reply::json(\u0026books)\n        });\n\n    // AMM pools endpoint\n    let pools = warp::path(\"pools\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc\u003cMarketDataManager\u003e| {\n            let addresses = mgr.get_amm_pool_addresses();\n            let mut pool_data = std::collections::HashMap::new();\n\n            for address in addresses {\n                if let Some(pool) = mgr.get_amm_pool(\u0026address) {\n                    pool_data.insert(\n                        address.to_string(),\n                        serde_json::json!({\n                            \"address\": address,\n                            \"pool_type\": pool.pool_type(),\n                            \"implied_mid\": pool.implied_mid(),\n                            \"reserves\": pool.get_reserves(),\n                            \"fee_tier\": pool.get_fee_tier(),\n                            \"last_update\": pool.last_update()\n                        }),\n                    );\n                }\n            }\n\n            warp::reply::json(\u0026pool_data)\n        });\n\n    let routes = metrics\n        .or(orderbooks)\n        .or(pools)\n        .with(warp::cors().allow_any_origin());\n\n    info!(\"API routes configured successfully\");\n    info!(\"API server ready at http://localhost:3030\");\n    info!(\"Available endpoints:\");\n    info!(\"  GET /metrics - System metrics\");\n    info!(\"  GET /orderbooks - Order book data\");\n    info!(\"  GET /pools - AMM pool data\");\n    info!(\"Server starting on 127.0.0.1:3030...\");\n\n    warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":181},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","utils","logger.rs"],"content":"use std::env;\nuse std::sync::Once;\nuse tracing::Level;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\nstatic INIT: Once = Once::new();\n\n/// Sets up the logger with optional OpenTelemetry integration\n///\n/// Environment variables:\n/// - LOGLEVEL: Sets the log level (DEBUG, INFO, WARN, ERROR, TRACE)\n/// - ENABLE_TRACING: Enable OpenTelemetry tracing (true/false) - requires the \"opentelemetry\" feature\n/// - TRACING_ENDPOINT: OpenTelemetry endpoint (default: http://localhost:4317)\n/// - SERVICE_NAME: Service name for tracing (default: rust-app)\npub fn setup_logger() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    INIT.call_once(|| {\n        let log_level = env::var(\"LOGLEVEL\")\n            .unwrap_or_else(|_| \"INFO\".to_string())\n            .to_uppercase();\n\n        let level = match log_level.as_str() {\n            \"DEBUG\" =\u003e Level::DEBUG,\n            \"ERROR\" =\u003e Level::ERROR,\n            \"WARN\" =\u003e Level::WARN,\n            \"TRACE\" =\u003e Level::TRACE,\n            _ =\u003e Level::INFO,\n        };\n\n        let enable_tracing =\n            env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n\n        // Create the registry with fmt layer\n        let registry = tracing_subscriber::registry()\n            .with(\n                tracing_subscriber::fmt::layer()\n                    .with_target(false)\n                    .with_thread_ids(true),\n            )\n            .with(tracing_subscriber::EnvFilter::from_default_env().add_directive(level.into()));\n\n        {\n            registry.init();\n            if enable_tracing {\n                tracing::warn!(\"OpenTelemetry tracing requested but feature not enabled\");\n                tracing::warn!(\"Add the 'opentelemetry' feature to your Cargo.toml to enable it\");\n            }\n        }\n\n        tracing::debug!(\"Log level set to: {}\", level);\n    });\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::Mutex;\n\n    // Mutex to ensure tests run sequentially since they modify global state\n    static TEST_MUTEX: Mutex\u003c()\u003e = Mutex::new(());\n\n    /// Helper function to reset the Once static for testing\n    /// Note: This is a workaround since Once cannot be reset in standard library\n    fn with_clean_env\u003cF\u003e(env_vars: Vec\u003c(\u0026str, \u0026str)\u003e, test_fn: F)\n    where\n        F: FnOnce(),\n    {\n        let _guard = TEST_MUTEX.lock().unwrap();\n\n        // Store original values\n        let original_values: Vec\u003c_\u003e = env_vars\n            .iter()\n            .map(|(key, _)| (*key, env::var(key).ok()))\n            .collect();\n\n        // Set test values\n        for (key, value) in \u0026env_vars {\n            env::set_var(key, value);\n        }\n\n        // Run test\n        test_fn();\n\n        // Restore original values\n        for (key, original_value) in original_values {\n            match original_value {\n                Some(value) =\u003e env::set_var(key, value),\n                None =\u003e env::remove_var(key),\n            }\n        }\n    }\n    #[test]\n    fn test_log_level_parsing_debug() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"DEBUG\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::DEBUG);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_info() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"INFO\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::INFO);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_warn() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"WARN\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::WARN);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_error() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"ERROR\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::ERROR);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_trace() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"TRACE\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::TRACE);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_invalid_defaults_to_info() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"INVALID\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::INFO);\n        });\n    }\n\n    #[test]\n    fn test_log_level_case_insensitive() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"debug\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::DEBUG);\n        });\n    }\n\n    #[test]\n    fn test_default_log_level_when_env_not_set() {\n        with_clean_env(vec![], || {\n            env::remove_var(\"LOGLEVEL\");\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::INFO);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_true() {\n        with_clean_env(vec![(\"ENABLE_TRACING\", \"true\")], || {\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(enable_tracing);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_false() {\n        with_clean_env(vec![(\"ENABLE_TRACING\", \"false\")], || {\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(!enable_tracing);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_default_false() {\n        with_clean_env(vec![], || {\n            env::remove_var(\"ENABLE_TRACING\");\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(!enable_tracing);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_case_sensitive() {\n        with_clean_env(vec![(\"ENABLE_TRACING\", \"TRUE\")], || {\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(!enable_tracing); // Should be false because it's case-sensitive\n        });\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","utils","mod.rs"],"content":"/// Logging utilities\npub mod logger;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","amm_tests.rs"],"content":"use quant_trading_system::domain::{amm_pool::*, types::*};\nuse quant_trading_system::AMMPoolUpdate;\nuse rust_decimal_macros::dec;\n\n#[test]\nfn test_amm_pool_v2_creation() {\n    let address = PoolAddress(\"0x123\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address.clone(), reserves, fee_tier);\n\n    assert_eq!(pool.get_address(), address);\n    assert_eq!(pool.get_reserves().token0, dec!(1000.0));\n    assert_eq!(pool.get_reserves().token1, dec!(2000.0));\n    assert_eq!(pool.get_fee_tier(), fee_tier);\n    assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n}\n\n#[test]\nfn test_amm_pool_v3_creation() {\n    let address = PoolAddress(\"0x456\".to_string());\n    let reserves = TokenReserves::new(dec!(500.0), dec!(1500.0));\n    let sqrt_price = SqrtPriceX96(2u128.pow(96) * 2); // sqrt(4) * 2^96\n    let fee_tier = FeeTier(5);\n\n    let pool = ThreadSafeAMMPool::new_v3(address.clone(), reserves, sqrt_price, fee_tier);\n\n    assert_eq!(pool.get_address(), address);\n    assert_eq!(pool.pool_type(), AMMPoolType::ConcentratedLiquidity);\n}\n\n#[test]\nfn test_implied_mid_price_v2() {\n    let address = PoolAddress(\"0x789\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n    let mid_price = pool.implied_mid();\n\n    // Price should be token1/token0 = 2000/1000 = 2.0\n    assert_eq!(mid_price, Price(dec!(2.0)));\n}\n\n#[test]\nfn test_implied_mid_price_v3_with_sqrt_price() {\n    let address = PoolAddress(\"0xABC\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let sqrt_price = SqrtPriceX96(2u128.pow(96)); // sqrt(1) * 2^96 = price of 1\n    let fee_tier = FeeTier(5);\n\n    let pool = ThreadSafeAMMPool::new_v3(address, reserves, sqrt_price, fee_tier);\n    let mid_price = pool.implied_mid();\n\n    // Should use sqrt_price, not reserves\n    assert!((mid_price.0 - dec!(1.0)).abs() \u003c dec!(0.1));\n}\n\n#[test]\nfn test_price_impact_calculation() {\n    let address = PoolAddress(\"0xDEF\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n\n    // Test small trade impact\n    let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(10.0));\n    assert!(result.is_ok());\n\n    let impact = result.unwrap();\n    assert!(impact.output_amount \u003e dec!(0.0));\n    assert!(impact.price_impact_percent \u003e= dec!(0.0));\n    assert!(impact.fee_amount \u003e dec!(0.0));\n}\n\n#[test]\nfn test_amm_pool_state_update() {\n    let address = PoolAddress(\"0x111\".to_string());\n    let initial_reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, initial_reserves, fee_tier);\n\n    // Update reserves\n    let new_reserves = TokenReserves::new(dec!(1100.0), dec!(1900.0));\n    let update = AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, fee_tier);\n\n    let result = pool.update_state(update);\n    assert!(result.is_ok());\n\n    // Verify updated state\n    assert_eq!(pool.get_reserves().token0, dec!(1100.0));\n    assert_eq!(pool.get_reserves().token1, dec!(1900.0));\n}\n\n#[test]\nfn test_zero_reserves_handling() {\n    let address = PoolAddress(\"0x222\".to_string());\n    let reserves = TokenReserves::new(dec!(0.0), dec!(1000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n    let mid_price = pool.implied_mid();\n\n    // Should return zero price when token0 reserve is zero\n    assert_eq!(mid_price, Price::zero());\n}\n\n#[test]\nfn test_large_trade_price_impact() {\n    let address = PoolAddress(\"0x333\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n\n    // Test large trade (50% of pool)\n    let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(500.0));\n    assert!(result.is_ok());\n\n    let impact = result.unwrap();\n    // Large trades should have significant price impact\n    assert!(impact.price_impact_percent \u003e dec!(10.0));\n}\n\n#[test]\nfn test_fee_tier_conversion() {\n    let fee_30 = FeeTier(30); // 30 basis points = 0.3%\n    assert_eq!(fee_30.to_decimal(), dec!(0.003));\n\n    let fee_5 = FeeTier(5); // 5 basis points = 0.05%\n    assert_eq!(fee_5.to_decimal(), dec!(0.0005));\n}\n\n#[test]\nfn test_token_reserves_operations() {\n    let reserves1 = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let reserves2 = TokenReserves::new(dec!(500.0), dec!(1000.0));\n\n    assert_eq!(reserves1.token0, dec!(1000.0));\n    assert_eq!(reserves1.token1, dec!(2000.0));\n    assert_ne!(reserves1, reserves2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","arbitrage_tests.rs"],"content":"use quant_trading_system::domain::{amm_pool::*, arbitrage::*, events::*, order_book::*, types::*};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\n\n#[test]\nfn test_arbitrage_detector_creation() {\n    let _detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    // Test with custom parameters\n    let _custom_detector = ArbitrageDetector::with_params(50, 200, dec!(1.0));\n\n    // Should create successfully without panicking\n}\n\n#[test]\nfn test_arbitrage_opportunity_creation() {\n    let buy_venue = Venue::AMM(PoolAddress(\"0x123\".to_string()));\n    let sell_venue = Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()));\n    let buy_price = Price(dec!(2400.0));\n    let sell_price = Price(dec!(2450.0));\n    let max_quantity = Quantity(dec!(10.0));\n\n    let opportunity = ArbitrageOpportunity::new(\n        buy_venue.clone(),\n        sell_venue.clone(),\n        buy_price,\n        sell_price,\n        max_quantity,\n    );\n\n    assert_eq!(opportunity.buy_venue, buy_venue);\n    assert_eq!(opportunity.sell_venue, sell_venue);\n    assert_eq!(opportunity.buy_price, buy_price);\n    assert_eq!(opportunity.sell_price, sell_price);\n    assert_eq!(opportunity.max_quantity, max_quantity);\n\n    // Check profit calculation\n    let expected_profit_percent = (dec!(50.0) / dec!(2400.0)) * dec!(100);\n    assert!((opportunity.profit_percent - expected_profit_percent).abs() \u003c dec!(0.01));\n}\n\n#[test]\nfn test_no_arbitrage_when_prices_equal() {\n    let detector = ArbitrageDetector::new(10);\n\n    // Create order book with equal prices\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Create AMM pool with similar price\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool =\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n    let result = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n    assert!(result.is_none()); // No arbitrage opportunity\n}\n\n#[test]\nfn test_arbitrage_amm_to_orderbook() {\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    // Create order book with higher bid\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2450.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2451.0)), Quantity(dec!(10.0)));\n\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Create AMM pool with lower price\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool =\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n    let result = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n    assert!(result.is_some());\n\n    let opportunity = result.unwrap();\n    match opportunity.buy_venue {\n        Venue::AMM(_) =\u003e {} // AMM venue displays correctly\n        _ =\u003e panic!(\"Expected AMM as buy venue\"),\n    }\n    match opportunity.sell_venue {\n        Venue::OrderBook(_) =\u003e {} // OrderBook venue displays correctly\n        _ =\u003e panic!(\"Expected OrderBook as sell venue\"),\n    }\n}\n\n#[test]\nfn test_minimum_profit_threshold() {\n    let detector = ArbitrageDetector::new(500); // 5% min profit\n\n    // Create small price difference (1%)\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2424.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2425.0)), Quantity(dec!(10.0)));\n\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // AMM price lower by 1%\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool =\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n    let result = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n    assert!(result.is_none()); // Should not detect due to minimum threshold\n}\n\n#[test]\nfn test_profit_calculation_accuracy() {\n    let buy_price = Price(dec!(2000.0));\n    let sell_price = Price(dec!(2100.0));\n    let max_quantity = Quantity(dec!(5.0));\n\n    let opportunity = ArbitrageOpportunity::new(\n        Venue::AMM(PoolAddress(\"0x123\".to_string())),\n        Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n        buy_price,\n        sell_price,\n        max_quantity,\n    );\n\n    // Profit per unit = 2100 - 2000 = 100\n    // Profit percent = (100 / 2000) * 100 = 5%\n    // Estimated profit = 100 * 5 = 500\n\n    assert_eq!(opportunity.profit_percent, dec!(5.0));\n    assert_eq!(opportunity.estimated_profit, dec!(500.0));\n}\n\n#[test]\nfn test_zero_price_handling() {\n    let opportunity = ArbitrageOpportunity::new(\n        Venue::AMM(PoolAddress(\"0x123\".to_string())),\n        Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n        Price::zero(),\n        Price(dec!(100.0)),\n        Quantity(dec!(1.0)),\n    );\n\n    // Should handle zero buy price gracefully\n    assert_eq!(opportunity.profit_percent, dec!(0.0));\n}\n\n#[test]\nfn test_venue_display() {\n    let amm_venue = Venue::AMM(PoolAddress(\"0xABC123\".to_string()));\n    let ob_venue = Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()));\n\n    let amm_str = format!(\"{}\", amm_venue);\n    let ob_str = format!(\"{}\", ob_venue);\n\n    assert!(amm_str.contains(\"AMM\"));\n    assert!(amm_str.contains(\"0xABC123\"));\n    assert!(ob_str.contains(\"OrderBook\"));\n    assert!(ob_str.contains(\"ETHUSDC\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","concurrency_tests.rs"],"content":"use quant_trading_system::domain::{\n    amm_pool::*, events::*, market_data::*, order_book::*, types::*,\n};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\n#[test]\nfn test_concurrent_order_book_access() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let order_book_clone = order_book.clone();\n\n    // Spawn multiple threads to read from order book\n    let handles: Vec\u003c_\u003e = (0..10)\n        .map(|_| {\n            let ob = order_book_clone.clone();\n            thread::spawn(move || {\n                for _ in 0..100 {\n                    let best_bid = ob.best_bid();\n                    let best_ask = ob.best_ask();\n                    assert!(best_bid.is_some());\n                    assert!(best_ask.is_some());\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify order book is still in valid state\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n}\n\n#[test]\nfn test_concurrent_amm_pool_access() {\n    let amm_pool = ThreadSafeAMMPool::new_v2(\n        PoolAddress(\"0x123\".to_string()),\n        TokenReserves::new(dec!(1000.0), dec!(2000.0)),\n        FeeTier(30),\n    );\n\n    let pool_clone = amm_pool.clone();\n\n    // Spawn multiple threads to read from AMM pool\n    let handles: Vec\u003c_\u003e = (0..10)\n        .map(|_| {\n            let pool = pool_clone.clone();\n            thread::spawn(move || {\n                for _ in 0..100 {\n                    let mid_price = pool.implied_mid();\n                    let reserves = pool.get_reserves();\n                    let fee_tier = pool.get_fee_tier();\n\n                    assert_eq!(mid_price, Price(dec!(2.0)));\n                    assert_eq!(reserves.token0, dec!(1000.0));\n                    assert_eq!(reserves.token1, dec!(2000.0));\n                    assert_eq!(fee_tier, FeeTier(30));\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_concurrent_market_data_manager_access() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Add initial data\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n    manager.process_event(snapshot_event).unwrap();\n\n    let manager_clone = Arc::clone(\u0026manager);\n\n    // Spawn multiple threads to access market data\n    let handles: Vec\u003c_\u003e = (0..5)\n        .map(|_| {\n            let mgr = Arc::clone(\u0026manager_clone);\n            let sym = symbol.clone();\n            thread::spawn(move || {\n                for _ in 0..50 {\n                    if let Some(order_book) = mgr.get_orderbook(\u0026sym) {\n                        let best_bid = order_book.best_bid();\n                        let best_ask = order_book.best_ask();\n                        assert!(best_bid.is_some());\n                        assert!(best_ask.is_some());\n                    }\n\n                    let symbols = mgr.get_orderbook_symbols();\n                    assert!(!symbols.is_empty());\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_concurrent_order_book_updates() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let order_book_clone = order_book.clone();\n\n    // Spawn threads that apply deltas concurrently\n    let handles: Vec\u003c_\u003e = (0..5)\n        .map(|i| {\n            let ob = order_book_clone.clone();\n            thread::spawn(move || {\n                for j in 0..20 {\n                    let seq = 1001 + (i * 20) + j;\n                    let mut updates = Vec::new();\n                    updates.push(PriceLevelUpdate::new(\n                        Side::Bid,\n                        Price(dec!(2399.0) + rust_decimal::Decimal::from(j)),\n                        Quantity(dec!(1.0)),\n                        UpdateAction::Update,\n                    ));\n\n                    let delta = OrderBookDelta::with_updates(\n                        SequenceNumber(seq as u64),\n                        chrono::Utc::now(),\n                        updates,\n                    );\n\n                    let _ = ob.apply_delta(\u0026delta);\n                    thread::sleep(Duration::from_micros(10));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify order book is still in valid state\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n}\n\n#[test]\nfn test_concurrent_amm_pool_updates() {\n    let amm_pool = ThreadSafeAMMPool::new_v2(\n        PoolAddress(\"0x123\".to_string()),\n        TokenReserves::new(dec!(1000.0), dec!(2000.0)),\n        FeeTier(30),\n    );\n\n    let pool_clone = amm_pool.clone();\n\n    // Spawn threads that update pool state concurrently\n    let handles: Vec\u003c_\u003e = (0..3)\n        .map(|i| {\n            let pool = pool_clone.clone();\n            thread::spawn(move || {\n                for j in 0..10 {\n                    let new_reserves = TokenReserves::new(\n                        dec!(1000.0) + rust_decimal::Decimal::from(i * 10 + j),\n                        dec!(2000.0) + rust_decimal::Decimal::from(i * 20 + j * 2),\n                    );\n\n                    let update =\n                        AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n                    let _ = pool.update_state(update);\n                    thread::sleep(Duration::from_micros(10));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify pool is still in valid state\n    let final_reserves = amm_pool.get_reserves();\n    assert!(final_reserves.token0 \u003e dec!(0.0));\n    assert!(final_reserves.token1 \u003e dec!(0.0));\n}\n\n#[test]\nfn test_concurrent_price_impact_calculations() {\n    let amm_pool = ThreadSafeAMMPool::new_v2(\n        PoolAddress(\"0x123\".to_string()),\n        TokenReserves::new(dec!(10000.0), dec!(20000.0)),\n        FeeTier(30),\n    );\n\n    let pool_clone = amm_pool.clone();\n\n    // Spawn multiple threads calculating price impact\n    let handles: Vec\u003c_\u003e = (0..8)\n        .map(|i| {\n            let pool = pool_clone.clone();\n            thread::spawn(move || {\n                for j in 0..25 {\n                    let trade_amount = dec!(1.0) + rust_decimal::Decimal::from(i + j);\n                    let result = pool.calculate_price_impact(TokenIndex::Token0, trade_amount);\n\n                    assert!(result.is_ok());\n                    let impact = result.unwrap();\n                    assert!(impact.output_amount \u003e dec!(0.0));\n                    assert!(impact.price_impact_percent \u003e= dec!(0.0));\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_concurrent_metrics_collection() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Add some initial data\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n    manager.process_event(snapshot_event).unwrap();\n\n    let manager_clone = Arc::clone(\u0026manager);\n\n    // Spawn multiple threads collecting metrics\n    let handles: Vec\u003c_\u003e = (0..4)\n        .map(|_| {\n            let mgr = Arc::clone(\u0026manager_clone);\n            thread::spawn(move || {\n                for _ in 0..50 {\n                    let metrics = mgr.get_market_metrics();\n                    assert!(!metrics.orderbook_metrics.is_empty());\n\n                    thread::sleep(Duration::from_micros(5));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","integration_tests.rs"],"content":"use quant_trading_system::domain::{\n    amm_pool::*, arbitrage::*, events::*, market_data::*, types::*,\n};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\n\n#[tokio::test]\nasync fn test_full_market_data_processing_pipeline() {\n    let manager = Arc::new(MarketDataManager::new());\n    let (event_tx, mut event_rx) = mpsc::unbounded_channel();\n\n    // We'll process events directly without the ingester for this test\n\n    // Send order book snapshot\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n\n    event_tx.send(snapshot_event).unwrap();\n\n    // Process the event\n    if let Some(event) = event_rx.recv().await {\n        manager.process_event(event).unwrap();\n    }\n\n    // Verify order book was created and populated\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Send a delta update\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2399.5)),\n        Quantity(dec!(5.0)),\n        UpdateAction::Update,\n    )];\n\n    let delta_event = MarketEvent::OrderBookDelta(\n        symbol.clone(),\n        OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates),\n    );\n\n    event_tx.send(delta_event).unwrap();\n\n    // Process the delta\n    if let Some(event) = event_rx.recv().await {\n        manager.process_event(event).unwrap();\n    }\n\n    // Verify the update was applied\n    let updated_order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(updated_order_book.best_bid().is_some());\n    // Best bid should still be 2400.0 since 2399.5 is lower\n    assert_eq!(updated_order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n}\n\n#[tokio::test]\nasync fn test_arbitrage_detection_integration() {\n    let manager = Arc::new(MarketDataManager::new());\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    // Set up order book with higher prices\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2450.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2451.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n\n    manager.process_event(snapshot_event).unwrap();\n\n    // Set up AMM pool with lower price\n    let pool_address = PoolAddress(\"0x123\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool = ThreadSafeAMMPool::new_v2(pool_address.clone(), reserves, FeeTier(30));\n\n    manager.add_amm_pool(pool_address.clone(), amm_pool.clone());\n\n    // Check for arbitrage opportunity\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n    assert!(opportunity.is_some());\n    let opp = opportunity.unwrap();\n    assert!(opp.estimated_profit \u003e dec!(0.0));\n    // Check that we're buying from AMM (lower price) and selling to OrderBook (higher price)\n    assert_eq!(opp.buy_venue, Venue::AMM(pool_address));\n    assert_eq!(opp.sell_venue, Venue::OrderBook(symbol));\n}\n\n#[tokio::test]\nasync fn test_concurrent_event_processing() {\n    let manager = Arc::new(MarketDataManager::new());\n    let (event_tx, mut event_rx) = mpsc::unbounded_channel();\n\n    // Spawn a task to process events\n    let manager_clone = Arc::clone(\u0026manager);\n    let processing_task = tokio::spawn(async move {\n        let mut processed_count = 0;\n        while let Some(event) = event_rx.recv().await {\n            if manager_clone.process_event(event).is_ok() {\n                processed_count += 1;\n            }\n            if processed_count \u003e= 10 {\n                break;\n            }\n        }\n        processed_count\n    });\n\n    // Send multiple events concurrently\n    for i in 0..10 {\n        let symbol = Symbol(format!(\"PAIR{}\", i));\n        let mut bids = BTreeMap::new();\n        let mut asks = BTreeMap::new();\n        bids.insert(\n            Price(dec!(100.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n        asks.insert(\n            Price(dec!(101.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n\n        let snapshot_event = MarketEvent::OrderBookSnapshot(\n            symbol,\n            OrderBookSnapshot::with_levels(\n                SequenceNumber(1000 + i as u64),\n                chrono::Utc::now(),\n                bids,\n                asks,\n            ),\n        );\n\n        event_tx.send(snapshot_event).unwrap();\n    }\n\n    // Wait for processing to complete\n    let processed_count = processing_task.await.unwrap();\n    assert_eq!(processed_count, 10);\n\n    // Verify all symbols were processed\n    let symbols = manager.get_orderbook_symbols();\n    assert_eq!(symbols.len(), 10);\n}\n\n#[tokio::test]\nasync fn test_market_metrics_integration() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Add multiple order books\n    for i in 0..5 {\n        let symbol = Symbol(format!(\"PAIR{}\", i));\n        let mut bids = BTreeMap::new();\n        let mut asks = BTreeMap::new();\n        bids.insert(\n            Price(dec!(100.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n        asks.insert(\n            Price(dec!(101.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n\n        let snapshot_event = MarketEvent::OrderBookSnapshot(\n            symbol,\n            OrderBookSnapshot::with_levels(\n                SequenceNumber(1000 + i as u64),\n                chrono::Utc::now(),\n                bids,\n                asks,\n            ),\n        );\n\n        manager.process_event(snapshot_event).unwrap();\n    }\n\n    // Add AMM pools\n    for i in 0..3 {\n        let pool_address = PoolAddress(format!(\"0x{:x}\", i));\n        let reserves = TokenReserves::new(\n            dec!(1000.0) + rust_decimal::Decimal::from(i * 100),\n            dec!(2000.0) + rust_decimal::Decimal::from(i * 200),\n        );\n        let amm_pool = ThreadSafeAMMPool::new_v2(pool_address.clone(), reserves, FeeTier(30));\n\n        manager.add_amm_pool(pool_address, amm_pool);\n    }\n\n    // Get metrics\n    let metrics = manager.get_market_metrics();\n\n    assert_eq!(metrics.orderbook_metrics.len(), 5);\n    assert_eq!(metrics.amm_metrics.len(), 3);\n\n    // Verify metrics contain expected data\n    for (symbol, ob_metrics) in \u0026metrics.orderbook_metrics {\n        assert!(ob_metrics.best_bid \u003e Price::zero());\n        assert!(ob_metrics.best_ask \u003e Price::zero());\n        assert!(ob_metrics.spread \u003e dec!(0.0));\n        assert!(symbol.0.starts_with(\"PAIR\"));\n    }\n\n    for (address, amm_metrics) in \u0026metrics.amm_metrics {\n        assert!(amm_metrics.implied_mid \u003e Price::zero());\n        assert!(amm_metrics.reserves.token0 \u003e dec!(0.0));\n        assert!(amm_metrics.reserves.token1 \u003e dec!(0.0));\n        assert!(address.0.starts_with(\"0x\"));\n    }\n}\n\n#[tokio::test]\nasync fn test_error_handling_and_recovery() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Test processing invalid sequence number\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    // Send initial snapshot\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(\n            SequenceNumber(1000),\n            chrono::Utc::now(),\n            bids.clone(),\n            asks.clone(),\n        ),\n    );\n\n    manager.process_event(snapshot_event).unwrap();\n\n    // Try to send a snapshot with lower sequence number (should fail)\n    let invalid_snapshot = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(\n            SequenceNumber(999), // Lower than previous\n            chrono::Utc::now(),\n            bids,\n            asks,\n        ),\n    );\n\n    let result = manager.process_event(invalid_snapshot);\n    assert!(result.is_err());\n\n    // Verify the original order book is still intact\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n}\n\n#[tokio::test]\nasync fn test_high_frequency_updates() {\n    let manager = Arc::new(MarketDataManager::new());\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n\n    // Initialize with snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n\n    manager.process_event(snapshot_event).unwrap();\n\n    // Send rapid delta updates\n    for i in 1..=100 {\n        let updates = vec![PriceLevelUpdate::new(\n            Side::Bid,\n            Price(dec!(2400.0) + rust_decimal::Decimal::from(i) / dec!(100.0)),\n            Quantity(dec!(1.0)),\n            UpdateAction::Update,\n        )];\n\n        let delta_event = MarketEvent::OrderBookDelta(\n            symbol.clone(),\n            OrderBookDelta::with_updates(SequenceNumber(1000 + i), chrono::Utc::now(), updates),\n        );\n\n        let result = manager.process_event(delta_event);\n        assert!(result.is_ok());\n    }\n\n    // Verify final state\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(order_book.best_bid().is_some());\n    let best_bid = order_book.best_bid().unwrap();\n    // Should be the highest bid price from our updates (2400.0 + 1.0 = 2401.0)\n    assert!(best_bid.0 \u003e= dec!(2401.0));\n}\n\n#[tokio::test]\nasync fn test_amm_pool_state_updates() {\n    let manager = Arc::new(MarketDataManager::new());\n    let pool_address = PoolAddress(\"0xabc123\".to_string());\n\n    // Create initial AMM pool\n    let initial_reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let amm_pool = ThreadSafeAMMPool::new_v2(pool_address.clone(), initial_reserves, FeeTier(30));\n\n    manager.add_amm_pool(pool_address.clone(), amm_pool.clone());\n\n    // Verify initial state\n    let initial_mid = amm_pool.implied_mid();\n    assert_eq!(initial_mid, Price(dec!(2.0)));\n\n    // Update pool state\n    let new_reserves = TokenReserves::new(dec!(1100.0), dec!(2100.0));\n    let update = AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n    amm_pool.update_state(update).unwrap();\n\n    // Verify updated state\n    let updated_reserves = amm_pool.get_reserves();\n    assert_eq!(updated_reserves.token0, dec!(1100.0));\n    assert_eq!(updated_reserves.token1, dec!(2100.0));\n\n    let updated_mid = amm_pool.implied_mid();\n    assert!(updated_mid.0 \u003e dec!(1.9) \u0026\u0026 updated_mid.0 \u003c dec!(2.0));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","orderbook_tests.rs"],"content":"use quant_trading_system::domain::{events::*, order_book::*, types::*};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\n\n#[test]\nfn test_order_book_creation() {\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let order_book = ThreadSafeOrderBook::new(symbol.clone());\n\n    assert!(order_book.best_bid().is_none());\n    assert!(order_book.best_ask().is_none());\n    assert_eq!(order_book.symbol(), symbol);\n}\n\n#[test]\nfn test_order_book_snapshot_application() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    bids.insert(Price(dec!(2399.0)), Quantity(dec!(5.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(8.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(12.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n\n    let result = order_book.apply_snapshot(snapshot);\n    assert!(result.is_ok());\n\n    // Verify best prices\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Verify bid/ask quantities\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity(dec!(10.0))\n    );\n    assert_eq!(\n        order_book.quantity_at_price(Side::Ask, Price(dec!(2401.0))),\n        Quantity(dec!(8.0))\n    );\n}\n\n#[test]\nfn test_order_book_delta_updates() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Apply delta update - add new bid level\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2399.5)),\n        Quantity(dec!(5.0)),\n        UpdateAction::Update,\n    )];\n\n    let delta = OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates);\n\n    let result = order_book.apply_delta(\u0026delta);\n    assert!(result.is_ok());\n\n    // Verify the new bid level was added\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2399.5))),\n        Quantity(dec!(5.0))\n    );\n    // Best bid should still be 2400.0\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n}\n\n#[test]\nfn test_order_book_price_level_deletion() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot with multiple levels\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    bids.insert(Price(dec!(2399.0)), Quantity(dec!(5.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(8.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(12.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Delete the best bid\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2400.0)),\n        Quantity::zero(),\n        UpdateAction::Delete,\n    )];\n\n    let delta = OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates);\n\n    order_book.apply_delta(\u0026delta).unwrap();\n\n    // Best bid should now be 2399.0\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2399.0)));\n    // The deleted price level should not exist\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity::zero()\n    );\n}\n\n#[test]\nfn test_order_book_spread_calculation() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.5)), Quantity(dec!(8.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let spread = order_book.spread();\n    assert!(spread.is_some());\n    assert_eq!(spread.unwrap(), Price(dec!(1.5))); // 2401.5 - 2400.0\n}\n\n#[test]\nfn test_order_book_mid_price_calculation() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(8.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let mid_price = order_book.mid_price();\n    assert!(mid_price.is_some());\n    assert_eq!(mid_price.unwrap(), Price(dec!(2401.0))); // (2400 + 2402) / 2\n}\n\n#[test]\nfn test_order_book_sequence_validation() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot = OrderBookSnapshot::with_levels(\n        SequenceNumber(1000),\n        chrono::Utc::now(),\n        bids.clone(),\n        asks.clone(),\n    );\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Try to apply snapshot with lower sequence number (should fail)\n    let invalid_snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(999), chrono::Utc::now(), bids, asks);\n\n    let result = order_book.apply_snapshot(invalid_snapshot);\n    assert!(result.is_err());\n\n    // Try to apply delta with non-sequential sequence number (should be skipped for idempotent replay)\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2399.0)),\n        Quantity(dec!(5.0)),\n        UpdateAction::Update,\n    )];\n\n    let old_delta = OrderBookDelta::with_updates(\n        SequenceNumber(999), // Lower than current - should be skipped\n        chrono::Utc::now(),\n        updates.clone(),\n    );\n\n    let result = order_book.apply_delta(\u0026old_delta);\n    assert!(result.is_ok()); // Should succeed but be skipped\n\n    // Try to apply delta with gap in sequence number (should fail)\n    let gap_delta = OrderBookDelta::with_updates(\n        SequenceNumber(1002), // Gap in sequence - should fail\n        chrono::Utc::now(),\n        updates,\n    );\n\n    let result = order_book.apply_delta(\u0026gap_delta);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_order_book_empty_state() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Test empty order book behavior\n    assert!(order_book.best_bid().is_none());\n    assert!(order_book.best_ask().is_none());\n    assert!(order_book.mid_price().is_none());\n    assert!(order_book.spread().is_none());\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity::zero()\n    );\n    assert_eq!(\n        order_book.quantity_at_price(Side::Ask, Price(dec!(2401.0))),\n        Quantity::zero()\n    );\n}\n\n#[test]\nfn test_order_book_partial_state() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply snapshot with only bids\n    let mut bids = BTreeMap::new();\n    let asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Should have bid but no ask\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_none());\n    assert!(order_book.mid_price().is_none());\n    assert!(order_book.spread().is_none());\n}\n\n#[test]\nfn test_order_book_price_level_updates() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Update existing bid quantity\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2400.0)),\n        Quantity(dec!(15.0)), // Increased quantity\n        UpdateAction::Update,\n    )];\n\n    let delta = OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates);\n\n    order_book.apply_delta(\u0026delta).unwrap();\n\n    // Verify quantity was updated\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity(dec!(15.0))\n    );\n}\n\n#[test]\nfn test_order_book_multiple_price_levels() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Create order book with multiple price levels\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n\n    // Multiple bid levels (descending prices)\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    bids.insert(Price(dec!(2399.5)), Quantity(dec!(8.0)));\n    bids.insert(Price(dec!(2399.0)), Quantity(dec!(5.0)));\n    bids.insert(Price(dec!(2398.5)), Quantity(dec!(3.0)));\n\n    // Multiple ask levels (ascending prices)\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(7.0)));\n    asks.insert(Price(dec!(2401.5)), Quantity(dec!(9.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(12.0)));\n    asks.insert(Price(dec!(2402.5)), Quantity(dec!(15.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Verify best prices (highest bid, lowest ask)\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Verify all levels exist\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2398.5))),\n        Quantity(dec!(3.0))\n    );\n    assert_eq!(\n        order_book.quantity_at_price(Side::Ask, Price(dec!(2402.5))),\n        Quantity(dec!(15.0))\n    );\n}\n\n#[test]\nfn test_order_book_cross_spread_handling() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Create crossed order book (bid \u003e ask) - this is an invalid state but should be handled\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2402.0)), Quantity(dec!(10.0))); // Higher than ask\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0))); // Lower than bid\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n\n    // Should still apply the snapshot (system doesn't validate cross)\n    let result = order_book.apply_snapshot(snapshot);\n    assert!(result.is_ok());\n\n    // Verify the crossed state\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2402.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Spread should be negative in this case\n    let spread = order_book.spread().unwrap();\n    assert!(spread.0 \u003c dec!(0.0));\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","amm_bench.rs"],"content":"fn main() {\n    println!(\"AMM benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","concurrency_bench.rs"],"content":"fn main() {\n    println!(\"Concurrency benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","ingestion_bench.rs"],"content":"fn main() {\n    println!(\"Ingestion benchmark placeholder\");\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":1}},{"line":2,"address":[],"length":0,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","benches","orderbook_bench.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse quant_trading_system::*;\nuse rust_decimal_macros::dec;\nuse std::hint::black_box;\n\nfn benchmark_orderbook_operations(c: \u0026mut Criterion) {\n    let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Setup initial state\n    let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n    for i in 0..1000 {\n        let price = dec!(2000.0) + rust_decimal::Decimal::from(i);\n        snapshot.bids.insert(Price(price), Quantity(dec!(1.0)));\n        snapshot\n            .asks\n            .insert(Price(price + dec!(1.0)), Quantity(dec!(1.0)));\n    }\n    book.apply_snapshot(snapshot).unwrap();\n\n    c.bench_function(\"orderbook_best_bid\", |b| {\n        b.iter(|| black_box(book.best_bid()))\n    });\n\n    c.bench_function(\"orderbook_best_ask\", |b| {\n        b.iter(|| black_box(book.best_ask()))\n    });\n\n    c.bench_function(\"orderbook_mid_price\", |b| {\n        b.iter(|| black_box(book.mid_price()))\n    });\n}\n\ncriterion_group!(benches, benchmark_orderbook_operations);\ncriterion_main!(benches);\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":1}},{"line":7,"address":[],"length":0,"stats":{"Line":3}},{"line":10,"address":[],"length":0,"stats":{"Line":4}},{"line":11,"address":[],"length":0,"stats":{"Line":2001}},{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":5}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":25,"address":[],"length":0,"stats":{"Line":5}},{"line":28,"address":[],"length":0,"stats":{"Line":4}},{"line":29,"address":[],"length":0,"stats":{"Line":5}}],"covered":11,"coverable":11},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","arbitrage_bot.rs"],"content":"fn main() {\n    println!(\"Arbitrage bot example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","basic_usage.rs"],"content":"fn main() {\n    println!(\"Basic usage example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","data_replay.rs"],"content":"fn main() {\n    println!(\"Data replay example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","examples","market_maker.rs"],"content":"fn main() {\n    println!(\"Market maker example placeholder\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","amm_pool.rs"],"content":"use crate::domain::{events::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// AMM pool types supported by the system\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum AMMPoolType {\n    /// Uniswap V2 style constant product (x * y = k)\n    ConstantProduct,\n    /// Uniswap V3 style concentrated liquidity\n    ConcentratedLiquidity,\n}\n\n/// Core AMM pool implementation supporting both V2 and V3 mechanics\n#[derive(Debug)]\npub struct AMMPool {\n    address: PoolAddress,\n    pool_type: AMMPoolType,\n    /// Token reserves (for V2) or virtual reserves (for V3)\n    reserves: TokenReserves,\n    /// Square root price for V3 pools\n    sqrt_price: Option\u003cSqrtPriceX96\u003e,\n    /// Fee tier in basis points\n    fee_tier: FeeTier,\n    /// Last update timestamp\n    last_update: Timestamp,\n}\n\nimpl AMMPool {\n    /// Creates a new Uniswap V2 style AMM pool\n    pub fn new_v2(address: PoolAddress, reserves: TokenReserves, fee_tier: FeeTier) -\u003e Self {\n        Self {\n            address,\n            pool_type: AMMPoolType::ConstantProduct,\n            reserves,\n            sqrt_price: None,\n            fee_tier,\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Creates a new Uniswap V3 style AMM pool with sqrt price\n    pub fn new_v3(\n        address: PoolAddress,\n        reserves: TokenReserves,\n        sqrt_price: SqrtPriceX96,\n        fee_tier: FeeTier,\n    ) -\u003e Self {\n        Self {\n            address,\n            pool_type: AMMPoolType::ConcentratedLiquidity,\n            reserves,\n            sqrt_price: Some(sqrt_price),\n            fee_tier,\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Update pool state\n    pub fn update_state(\u0026mut self, update: AMMPoolUpdate) -\u003e TradingResult\u003c()\u003e {\n        self.reserves = update.reserves;\n        self.sqrt_price = update.sqrt_price;\n        self.fee_tier = update.fee_tier;\n        self.last_update = update.timestamp;\n        Ok(())\n    }\n\n    /// Get current implied mid price\n    pub fn implied_mid(\u0026self) -\u003e Price {\n        match self.sqrt_price {\n            Some(sqrt_price) =\u003e sqrt_price.to_price(),\n            None =\u003e self.implied_mid_from_reserves(),\n        }\n    }\n\n    /// Calculate implied mid price from reserves (V2 style)\n    pub fn implied_mid_from_reserves(\u0026self) -\u003e Price {\n        if self.reserves.token0.is_zero() {\n            return Price::zero();\n        }\n        Price(self.reserves.token1 / self.reserves.token0)\n    }\n\n    /// Calculate price impact for a given input amount\n    /// Returns (output_amount, price_impact_percent, effective_price)\n    pub fn calculate_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        match self.pool_type {\n            AMMPoolType::ConstantProduct =\u003e {\n                self.calculate_v2_price_impact(input_token, input_amount)\n            }\n            AMMPoolType::ConcentratedLiquidity =\u003e {\n                self.calculate_v3_price_impact(input_token, input_amount)\n            }\n        }\n    }\n\n    /// Calculate V2 style price impact using constant product formula\n    fn calculate_v2_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        let (reserve_in, reserve_out) = match input_token {\n            TokenIndex::Token0 =\u003e (self.reserves.token0, self.reserves.token1),\n            TokenIndex::Token1 =\u003e (self.reserves.token1, self.reserves.token0),\n        };\n\n        if reserve_in.is_zero() || reserve_out.is_zero() {\n            return Err(TradingError::InsufficientLiquidity(input_amount));\n        }\n\n        // Apply fee\n        let fee_decimal = self.fee_tier.to_decimal();\n        let input_after_fee = input_amount * (Decimal::ONE - fee_decimal);\n\n        // Constant product formula: (x + dx) * (y - dy) = x * y\n        // Solving for dy: dy = (y * dx) / (x + dx)\n        let output_amount = (reserve_out * input_after_fee) / (reserve_in + input_after_fee);\n\n        if output_amount \u003e= reserve_out {\n            return Err(TradingError::InsufficientLiquidity(input_amount));\n        }\n\n        // Calculate price impact\n        let initial_price = reserve_out / reserve_in;\n        let effective_price = output_amount / input_amount;\n        let price_impact =\n            ((initial_price - effective_price) / initial_price).abs() * Decimal::from(100);\n\n        Ok(PriceImpactResult {\n            output_amount,\n            price_impact_percent: price_impact,\n            effective_price: Price(effective_price),\n            fee_amount: input_amount * fee_decimal,\n        })\n    }\n\n    /// Calculate V3 style price impact (simplified - would need tick math in production)\n    fn calculate_v3_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        // For V3, we'll use a simplified approach similar to V2\n        // In production, this would involve complex tick math and liquidity distribution\n        self.calculate_v2_price_impact(input_token, input_amount)\n    }\n\n    /// Get pool address\n    pub fn address(\u0026self) -\u003e \u0026PoolAddress {\n        \u0026self.address\n    }\n\n    /// Get pool type\n    pub fn pool_type(\u0026self) -\u003e \u0026AMMPoolType {\n        \u0026self.pool_type\n    }\n\n    /// Get current reserves\n    pub fn get_reserves(\u0026self) -\u003e TokenReserves {\n        self.reserves.clone()\n    }\n\n    /// Get sqrt price (if available)\n    pub fn sqrt_price(\u0026self) -\u003e Option\u003cSqrtPriceX96\u003e {\n        self.sqrt_price\n    }\n\n    /// Get fee tier\n    pub fn get_fee_tier(\u0026self) -\u003e FeeTier {\n        self.fee_tier\n    }\n\n    /// Get last update timestamp\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.last_update\n    }\n\n    /// Get pool address\n    pub fn get_address(\u0026self) -\u003e PoolAddress {\n        self.address.clone()\n    }\n\n    /// Get current sqrt price (V3 only)\n    pub fn get_sqrt_price(\u0026self) -\u003e Option\u003cSqrtPriceX96\u003e {\n        self.sqrt_price\n    }\n}\n\n/// Token index for AMM operations\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum TokenIndex {\n    /// First token in the pair\n    Token0,\n    /// Second token in the pair\n    Token1,\n}\n\n/// Result of a price impact calculation\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceImpactResult {\n    /// Amount of output tokens received\n    pub output_amount: Decimal,\n    /// Price impact as a percentage\n    pub price_impact_percent: Decimal,\n    /// Effective price after impact\n    pub effective_price: Price,\n    /// Fee amount charged\n    pub fee_amount: Decimal,\n}\n\n/// Thread-safe wrapper around AMMPool\n#[derive(Debug, Clone)]\npub struct ThreadSafeAMMPool {\n    inner: Arc\u003cRwLock\u003cAMMPool\u003e\u003e,\n}\n\nimpl ThreadSafeAMMPool {\n    /// Creates a new thread-safe Uniswap V2 style AMM pool\n    pub fn new_v2(address: PoolAddress, reserves: TokenReserves, fee_tier: FeeTier) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(AMMPool::new_v2(address, reserves, fee_tier))),\n        }\n    }\n\n    /// Creates a new thread-safe Uniswap V3 style AMM pool with sqrt price\n    pub fn new_v3(\n        address: PoolAddress,\n        reserves: TokenReserves,\n        sqrt_price: SqrtPriceX96,\n        fee_tier: FeeTier,\n    ) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(AMMPool::new_v3(\n                address, reserves, sqrt_price, fee_tier,\n            ))),\n        }\n    }\n\n    /// Update pool state with write lock\n    pub fn update_state(\u0026self, update: AMMPoolUpdate) -\u003e TradingResult\u003c()\u003e {\n        let mut pool = self.inner.write().expect(\"Failed to acquire write lock\");\n        pool.update_state(update)\n    }\n\n    /// Get implied mid price with read lock\n    pub fn implied_mid(\u0026self) -\u003e Price {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .implied_mid()\n    }\n\n    /// Calculate price impact for a given trade\n    pub fn calculate_price_impact(\n        \u0026self,\n        input_token: TokenIndex,\n        input_amount: Decimal,\n    ) -\u003e TradingResult\u003cPriceImpactResult\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .calculate_price_impact(input_token, input_amount)\n    }\n\n    /// Get pool address with read lock\n    pub fn get_address(\u0026self) -\u003e PoolAddress {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .address\n            .clone()\n    }\n\n    /// Get pool type with read lock\n    pub fn pool_type(\u0026self) -\u003e AMMPoolType {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .pool_type()\n            .clone()\n    }\n\n    /// Get reserves with read lock\n    pub fn get_reserves(\u0026self) -\u003e TokenReserves {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .reserves\n            .clone()\n    }\n\n    /// Get sqrt price with read lock\n    pub fn get_sqrt_price(\u0026self) -\u003e Option\u003cSqrtPriceX96\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .sqrt_price\n    }\n\n    /// Get fee tier with read lock\n    pub fn get_fee_tier(\u0026self) -\u003e FeeTier {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .fee_tier\n    }\n\n    /// Get last update timestamp with read lock\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_update()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_v2_pool_creation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        assert_eq!(pool.pool_type(), \u0026AMMPoolType::ConstantProduct);\n        assert_eq!(pool.implied_mid_from_reserves(), Price(dec!(2.0)));\n    }\n\n    #[test]\n    fn test_v3_pool_creation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let sqrt_price = SqrtPriceX96(2u128.pow(96)); // sqrt(1) = 1\n        let pool = AMMPool::new_v3(\n            PoolAddress(\"0x456\".to_string()),\n            reserves,\n            sqrt_price,\n            FeeTier(30),\n        );\n\n        assert_eq!(pool.pool_type(), \u0026AMMPoolType::ConcentratedLiquidity);\n        assert!(pool.sqrt_price().is_some());\n    }\n\n    #[test]\n    fn test_price_impact_calculation() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(\n            PoolAddress(\"0x123\".to_string()),\n            reserves,\n            FeeTier(30), // 0.3%\n        );\n\n        // Test small trade (should have minimal impact)\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(10.0))\n            .unwrap();\n\n        // With 0.3% fee, input after fee = 10 * 0.997 = 9.97\n        // Output = (2000 * 9.97) / (1000 + 9.97) = 19.7406...\n        assert!(result.output_amount \u003e dec!(19.7));\n        assert!(result.output_amount \u003c dec!(19.8));\n        assert!(result.price_impact_percent \u003e dec!(0.0)); // Should have some impact\n        assert_eq!(result.fee_amount, dec!(0.03)); // 0.3% of 10\n    }\n\n    #[test]\n    fn test_large_trade_price_impact() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Test large trade (should have significant impact)\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(100.0))\n            .unwrap();\n\n        // Large trades should have higher price impact\n        assert!(result.price_impact_percent \u003e dec!(5.0)); // More than 5% impact\n    }\n\n    #[test]\n    fn test_insufficient_liquidity() {\n        let reserves = TokenReserves::new(dec!(100.0), dec!(200.0));\n        let pool = AMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Try to trade more than available liquidity\n        let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(1000.0));\n\n        // For constant product AMM, very large trades are still possible but with extreme price impact\n        // Let's check that the result has very high price impact instead\n        if let Ok(impact) = result {\n            assert!(impact.price_impact_percent \u003e dec!(50.0)); // Very high impact\n        } else {\n            // If it does error, that's also acceptable behavior\n            assert!(result.is_err());\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_amm_pool() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool =\n            ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Test concurrent reads\n        let pool_clone = pool.clone();\n        let handle = std::thread::spawn(move || {\n            for _ in 0..100 {\n                let _ = pool_clone.implied_mid();\n                let _ = pool_clone.calculate_price_impact(TokenIndex::Token0, dec!(1.0));\n            }\n        });\n\n        // Concurrent reads from main thread\n        for _ in 0..100 {\n            let _ = pool.get_reserves();\n            let _ = pool.get_fee_tier();\n        }\n\n        handle.join().unwrap();\n\n        // Verify state is consistent\n        assert_eq!(pool.implied_mid(), Price(dec!(2.0)));\n    }\n\n    #[test]\n    fn test_pool_state_update() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let pool =\n            ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n        // Update pool state\n        let new_reserves = TokenReserves::new(dec!(1100.0), dec!(1900.0));\n        let update =\n            AMMPoolUpdate::new(chrono::Utc::now(), new_reserves.clone(), None, FeeTier(25));\n\n        pool.update_state(update).unwrap();\n\n        // Verify state was updated\n        assert_eq!(pool.get_reserves(), new_reserves);\n        assert_eq!(pool.get_fee_tier(), FeeTier(25));\n\n        // Price should have changed\n        let new_price = dec!(1900.0) / dec!(1100.0);\n        assert_eq!(pool.implied_mid(), Price(new_price));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":32}},{"line":40,"address":[],"length":0,"stats":{"Line":32}},{"line":45,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[],"length":0,"stats":{"Line":8}},{"line":57,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":228}},{"line":72,"address":[],"length":0,"stats":{"Line":228}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[],"length":0,"stats":{"Line":224}},{"line":79,"address":[],"length":0,"stats":{"Line":226}},{"line":80,"address":[],"length":0,"stats":{"Line":452}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":208}},{"line":93,"address":[],"length":0,"stats":{"Line":208}},{"line":95,"address":[],"length":0,"stats":{"Line":208}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":208}},{"line":109,"address":[],"length":0,"stats":{"Line":624}},{"line":110,"address":[],"length":0,"stats":{"Line":208}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":624}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":12}},{"line":162,"address":[],"length":0,"stats":{"Line":12}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":24}},{"line":228,"address":[],"length":0,"stats":{"Line":120}},{"line":233,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":8}},{"line":247,"address":[],"length":0,"stats":{"Line":2}},{"line":248,"address":[],"length":0,"stats":{"Line":8}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":228}},{"line":254,"address":[],"length":0,"stats":{"Line":456}},{"line":261,"address":[],"length":0,"stats":{"Line":202}},{"line":266,"address":[],"length":0,"stats":{"Line":606}},{"line":269,"address":[],"length":0,"stats":{"Line":404}},{"line":273,"address":[],"length":0,"stats":{"Line":16}},{"line":274,"address":[],"length":0,"stats":{"Line":32}},{"line":275,"address":[],"length":0,"stats":{"Line":32}},{"line":276,"address":[],"length":0,"stats":{"Line":16}},{"line":277,"address":[],"length":0,"stats":{"Line":16}},{"line":282,"address":[],"length":0,"stats":{"Line":8}},{"line":283,"address":[],"length":0,"stats":{"Line":16}},{"line":291,"address":[],"length":0,"stats":{"Line":216}},{"line":292,"address":[],"length":0,"stats":{"Line":432}},{"line":293,"address":[],"length":0,"stats":{"Line":432}},{"line":294,"address":[],"length":0,"stats":{"Line":216}},{"line":295,"address":[],"length":0,"stats":{"Line":216}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":206}},{"line":309,"address":[],"length":0,"stats":{"Line":412}},{"line":310,"address":[],"length":0,"stats":{"Line":412}},{"line":311,"address":[],"length":0,"stats":{"Line":206}},{"line":312,"address":[],"length":0,"stats":{"Line":206}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":8}}],"covered":61,"coverable":83},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","arbitrage.rs"],"content":"use crate::domain::{amm_pool::*, order_book::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Arbitrage opportunity between two venues\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct ArbitrageOpportunity {\n    /// Venue where the asset should be bought\n    pub buy_venue: Venue,\n    /// Venue where the asset should be sold\n    pub sell_venue: Venue,\n    /// Price to buy at\n    pub buy_price: Price,\n    /// Price to sell at\n    pub sell_price: Price,\n    /// Maximum quantity that can be traded\n    pub max_quantity: Quantity,\n    /// Profit percentage\n    pub profit_percent: Decimal,\n    /// Estimated profit amount\n    pub estimated_profit: Decimal,\n}\n\nimpl ArbitrageOpportunity {\n    /// Creates a new arbitrage opportunity\n    pub fn new(\n        buy_venue: Venue,\n        sell_venue: Venue,\n        buy_price: Price,\n        sell_price: Price,\n        max_quantity: Quantity,\n    ) -\u003e Self {\n        let profit_per_unit = sell_price.0 - buy_price.0;\n        let estimated_profit = profit_per_unit * max_quantity.0;\n        let profit_percent = if !buy_price.is_zero() {\n            (profit_per_unit / buy_price.0) * Decimal::from(100)\n        } else {\n            Decimal::ZERO\n        };\n\n        Self {\n            buy_venue,\n            sell_venue,\n            buy_price,\n            sell_price,\n            max_quantity,\n            profit_percent,\n            estimated_profit,\n        }\n    }\n}\n\n/// Trading venue identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Venue {\n    /// Order book venue with symbol\n    OrderBook(Symbol),\n    /// AMM pool venue with address\n    AMM(PoolAddress),\n}\n\nimpl fmt::Display for Venue {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Venue::OrderBook(symbol) =\u003e write!(f, \"OrderBook({})\", symbol),\n            Venue::AMM(address) =\u003e write!(f, \"AMM({})\", address),\n        }\n    }\n}\n\n/// Arbitrage detector with configurable profit thresholds\n#[derive(Debug)]\npub struct ArbitrageDetector {\n    /// Minimum profit percentage to consider an opportunity viable (in basis points)\n    min_profit_bps: u32,\n    /// Maximum slippage tolerance (in basis points)\n    max_slippage_bps: u32,\n    /// Minimum trade size to consider\n    min_trade_size: Decimal,\n}\n\nimpl ArbitrageDetector {\n    /// Create new arbitrage detector\n    /// min_profit_bps: minimum profit in basis points (e.g., 10 = 0.1%)\n    pub fn new(min_profit_bps: u32) -\u003e Self {\n        Self {\n            min_profit_bps,\n            max_slippage_bps: 50,               // 0.5% default max slippage\n            min_trade_size: Decimal::from(100), // Default minimum trade size\n        }\n    }\n\n    /// Create detector with custom parameters\n    pub fn with_params(\n        min_profit_bps: u32,\n        max_slippage_bps: u32,\n        min_trade_size: Decimal,\n    ) -\u003e Self {\n        Self {\n            min_profit_bps,\n            max_slippage_bps,\n            min_trade_size,\n        }\n    }\n\n    /// Check for arbitrage opportunities between order book and AMM pool\n    pub fn check_arbitrage(\n        \u0026self,\n        order_book: \u0026ThreadSafeOrderBook,\n        amm_pool: \u0026ThreadSafeAMMPool,\n    ) -\u003e Option\u003cArbitrageOpportunity\u003e {\n        let ob_symbol = order_book.symbol();\n        let pool_address = amm_pool.get_address();\n\n        // Get order book prices\n        let ob_best_bid = order_book.best_bid()?;\n        let ob_best_ask = order_book.best_ask()?;\n\n        // Get AMM implied price\n        let amm_mid = amm_pool.implied_mid();\n\n        // Check both directions of arbitrage\n\n        // Direction 1: Buy from AMM, sell to order book\n        if let Some(opp1) = self.check_amm_to_orderbook(\n            amm_pool,\n            order_book,\n            amm_mid,\n            ob_best_bid,\n            \u0026pool_address,\n            \u0026ob_symbol,\n        ) {\n            return Some(opp1);\n        }\n\n        // Direction 2: Buy from order book, sell to AMM\n        if let Some(opp2) = self.check_orderbook_to_amm(\n            order_book,\n            amm_pool,\n            ob_best_ask,\n            amm_mid,\n            \u0026ob_symbol,\n            \u0026pool_address,\n        ) {\n            return Some(opp2);\n        }\n\n        None\n    }\n\n    /// Check arbitrage: buy from AMM, sell to order book\n    fn check_amm_to_orderbook(\n        \u0026self,\n        amm_pool: \u0026ThreadSafeAMMPool,\n        order_book: \u0026ThreadSafeOrderBook,\n        amm_price: Price,\n        ob_best_bid: Price,\n        pool_address: \u0026PoolAddress,\n        ob_symbol: \u0026Symbol,\n    ) -\u003e Option\u003cArbitrageOpportunity\u003e {\n        // Check if order book bid is higher than AMM price (profitable to buy from AMM, sell to OB)\n        if ob_best_bid.0 \u003c= amm_price.0 {\n            return None;\n        }\n\n        let profit_per_unit = ob_best_bid.0 - amm_price.0;\n        let profit_percent = (profit_per_unit / amm_price.0) * Decimal::from(10000); // Convert to basis points\n\n        if profit_percent \u003c Decimal::from(self.min_profit_bps) {\n            return None;\n        }\n\n        // Calculate maximum tradeable quantity considering:\n        // 1. Order book liquidity at best bid\n        // 2. AMM price impact\n        let ob_liquidity = order_book.quantity_at_price(Side::Bid, ob_best_bid);\n        let max_amm_trade = self.calculate_max_amm_trade(amm_pool, amm_price);\n\n        let max_quantity = Quantity(ob_liquidity.0.min(max_amm_trade.0).max(self.min_trade_size));\n\n        if max_quantity.0 \u003c self.min_trade_size {\n            return None;\n        }\n\n        Some(ArbitrageOpportunity::new(\n            Venue::AMM(pool_address.clone()),\n            Venue::OrderBook(ob_symbol.clone()),\n            amm_price,\n            ob_best_bid,\n            max_quantity,\n        ))\n    }\n\n    /// Check arbitrage: buy from order book, sell to AMM\n    fn check_orderbook_to_amm(\n        \u0026self,\n        order_book: \u0026ThreadSafeOrderBook,\n        amm_pool: \u0026ThreadSafeAMMPool,\n        ob_best_ask: Price,\n        amm_price: Price,\n        ob_symbol: \u0026Symbol,\n        pool_address: \u0026PoolAddress,\n    ) -\u003e Option\u003cArbitrageOpportunity\u003e {\n        // Check if AMM price is higher than order book ask (profitable to buy from OB, sell to AMM)\n        if amm_price.0 \u003c= ob_best_ask.0 {\n            return None;\n        }\n\n        let profit_per_unit = amm_price.0 - ob_best_ask.0;\n        let profit_percent = (profit_per_unit / ob_best_ask.0) * Decimal::from(10000); // Convert to basis points\n\n        if profit_percent \u003c Decimal::from(self.min_profit_bps) {\n            return None;\n        }\n\n        // Calculate maximum tradeable quantity\n        let ob_liquidity = order_book.quantity_at_price(Side::Ask, ob_best_ask);\n        let max_amm_trade = self.calculate_max_amm_trade(amm_pool, amm_price);\n\n        let max_quantity = Quantity(ob_liquidity.0.min(max_amm_trade.0).max(self.min_trade_size));\n\n        if max_quantity.0 \u003c self.min_trade_size {\n            return None;\n        }\n\n        Some(ArbitrageOpportunity::new(\n            Venue::OrderBook(ob_symbol.clone()),\n            Venue::AMM(pool_address.clone()),\n            ob_best_ask,\n            amm_price,\n            max_quantity,\n        ))\n    }\n\n    /// Calculate maximum trade size for AMM considering slippage tolerance\n    fn calculate_max_amm_trade(\n        \u0026self,\n        amm_pool: \u0026ThreadSafeAMMPool,\n        _current_price: Price,\n    ) -\u003e Quantity {\n        let max_slippage_decimal = Decimal::from(self.max_slippage_bps) / Decimal::from(10000);\n        let reserves = amm_pool.get_reserves();\n\n        // For constant product AMM, calculate max trade size that keeps slippage under threshold\n        // This is a simplified calculation - in production would need more sophisticated modeling\n        let max_trade_estimate = reserves.token0 * max_slippage_decimal;\n\n        Quantity(max_trade_estimate.max(self.min_trade_size))\n    }\n\n    /// Check multiple order books against multiple AMM pools\n    pub fn scan_opportunities(\n        \u0026self,\n        order_books: \u0026[ThreadSafeOrderBook],\n        amm_pools: \u0026[ThreadSafeAMMPool],\n    ) -\u003e Vec\u003cArbitrageOpportunity\u003e {\n        let mut opportunities = Vec::new();\n\n        for order_book in order_books {\n            for amm_pool in amm_pools {\n                if let Some(opportunity) = self.check_arbitrage(order_book, amm_pool) {\n                    opportunities.push(opportunity);\n                }\n            }\n        }\n\n        // Sort by profit percentage (descending)\n        opportunities.sort_by(|a, b| b.profit_percent.cmp(\u0026a.profit_percent));\n\n        opportunities\n    }\n\n    /// Get minimum profit threshold in basis points\n    pub fn min_profit_bps(\u0026self) -\u003e u32 {\n        self.min_profit_bps\n    }\n\n    /// Get maximum slippage tolerance in basis points\n    pub fn max_slippage_bps(\u0026self) -\u003e u32 {\n        self.max_slippage_bps\n    }\n\n    /// Get minimum trade size\n    pub fn min_trade_size(\u0026self) -\u003e Decimal {\n        self.min_trade_size\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{events::OrderBookSnapshot, types::TokenReserves};\n    use rust_decimal_macros::dec;\n\n    fn create_test_order_book() -\u003e ThreadSafeOrderBook {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .bids\n            .insert(Price(dec!(1999.0)), Quantity(dec!(5.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2002.0)), Quantity(dec!(12.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n        book\n    }\n\n    fn create_test_amm_pool(price_ratio: Decimal) -\u003e ThreadSafeAMMPool {\n        // Create pool with specific price ratio (token1/token0)\n        let token0_reserve = dec!(1000.0);\n        let token1_reserve = token0_reserve * price_ratio;\n        let reserves = TokenReserves::new(token0_reserve, token1_reserve);\n\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30))\n    }\n\n    #[test]\n    fn test_arbitrage_detection_amm_to_orderbook() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with lower price (1950) than order book best bid (2000)\n        let amm_pool = create_test_amm_pool(dec!(1950.0));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        assert!(opportunity.is_some());\n        let opp = opportunity.unwrap();\n\n        assert_eq!(opp.buy_venue, Venue::AMM(PoolAddress(\"0x123\".to_string())));\n        assert_eq!(\n            opp.sell_venue,\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()))\n        );\n        assert_eq!(opp.buy_price, Price(dec!(1950.0)));\n        assert_eq!(opp.sell_price, Price(dec!(2000.0)));\n        assert!(opp.profit_percent \u003e dec!(0.0));\n    }\n\n    #[test]\n    fn test_arbitrage_detection_orderbook_to_amm() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with higher price (2050) than order book best ask (2001)\n        let amm_pool = create_test_amm_pool(dec!(2050.0));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        assert!(opportunity.is_some());\n        let opp = opportunity.unwrap();\n\n        assert_eq!(\n            opp.buy_venue,\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()))\n        );\n        assert_eq!(opp.sell_venue, Venue::AMM(PoolAddress(\"0x123\".to_string())));\n        assert_eq!(opp.buy_price, Price(dec!(2001.0)));\n        assert_eq!(opp.sell_price, Price(dec!(2050.0)));\n        assert!(opp.profit_percent \u003e dec!(0.0));\n    }\n\n    #[test]\n    fn test_no_arbitrage_opportunity() {\n        let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n        let order_book = create_test_order_book();\n\n        // Create AMM with price within the spread (2000.5)\n        let amm_pool = create_test_amm_pool(dec!(2000.5));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        assert!(opportunity.is_none());\n    }\n\n    #[test]\n    fn test_insufficient_profit_threshold() {\n        let detector = ArbitrageDetector::new(500); // 5% minimum profit (very high)\n        let order_book = create_test_order_book();\n\n        // Create AMM with small arbitrage opportunity\n        let amm_pool = create_test_amm_pool(dec!(1990.0));\n\n        let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n        // Should be None because profit is below 5% threshold\n        assert!(opportunity.is_none());\n    }\n\n    #[test]\n    fn test_scan_multiple_opportunities() {\n        let detector = ArbitrageDetector::new(10);\n\n        let order_books = vec![create_test_order_book()];\n\n        let amm_pools = vec![\n            create_test_amm_pool(dec!(1950.0)), // Should create arbitrage opportunity\n            create_test_amm_pool(dec!(2000.5)), // No opportunity (within spread)\n            create_test_amm_pool(dec!(2050.0)), // Should create arbitrage opportunity\n        ];\n\n        let opportunities = detector.scan_opportunities(\u0026order_books, \u0026amm_pools);\n\n        // Should find 2 opportunities\n        assert_eq!(opportunities.len(), 2);\n\n        // Should be sorted by profit percentage (descending)\n        assert!(opportunities[0].profit_percent \u003e= opportunities[1].profit_percent);\n    }\n\n    #[test]\n    fn test_arbitrage_opportunity_calculations() {\n        let opp = ArbitrageOpportunity::new(\n            Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n            Venue::AMM(PoolAddress(\"0x123\".to_string())),\n            Price(dec!(2000.0)),\n            Price(dec!(2020.0)),\n            Quantity(dec!(10.0)),\n        );\n\n        assert_eq!(opp.estimated_profit, dec!(200.0)); // (2020 - 2000) * 10\n        assert_eq!(opp.profit_percent, dec!(1.0)); // (20 / 2000) * 100 = 1%\n    }\n\n    #[test]\n    fn test_detector_configuration() {\n        let detector = ArbitrageDetector::with_params(\n            25,         // 0.25% min profit\n            100,        // 1% max slippage\n            dec!(50.0), // min trade size\n        );\n\n        assert_eq!(detector.min_profit_bps(), 25);\n        assert_eq!(detector.max_slippage_bps(), 100);\n        assert_eq!(detector.min_trade_size(), dec!(50.0));\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":34,"address":[],"length":0,"stats":{"Line":24}},{"line":35,"address":[],"length":0,"stats":{"Line":24}},{"line":36,"address":[],"length":0,"stats":{"Line":24}},{"line":37,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":16}},{"line":113,"address":[],"length":0,"stats":{"Line":48}},{"line":114,"address":[],"length":0,"stats":{"Line":48}},{"line":117,"address":[],"length":0,"stats":{"Line":48}},{"line":118,"address":[],"length":0,"stats":{"Line":16}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":34}},{"line":139,"address":[],"length":0,"stats":{"Line":20}},{"line":140,"address":[],"length":0,"stats":{"Line":20}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":20}},{"line":143,"address":[],"length":0,"stats":{"Line":10}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":16}},{"line":163,"address":[],"length":0,"stats":{"Line":16}},{"line":164,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":10}},{"line":206,"address":[],"length":0,"stats":{"Line":10}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":10}},{"line":242,"address":[],"length":0,"stats":{"Line":30}},{"line":243,"address":[],"length":0,"stats":{"Line":30}},{"line":247,"address":[],"length":0,"stats":{"Line":20}},{"line":249,"address":[],"length":0,"stats":{"Line":20}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":14}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":269,"address":[],"length":0,"stats":{"Line":10}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":276,"address":[],"length":0,"stats":{"Line":2}},{"line":280,"address":[],"length":0,"stats":{"Line":2}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":2}},{"line":286,"address":[],"length":0,"stats":{"Line":2}}],"covered":47,"coverable":55},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","events.rs"],"content":"use crate::domain::types::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::BTreeMap;\n\n/// Price level in an order book\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceLevel {\n    /// Price at this level\n    pub price: Price,\n    /// Quantity available at this price\n    pub quantity: Quantity,\n}\n\nimpl PriceLevel {\n    /// Creates a new price level with the given price and quantity\n    pub fn new(price: Price, quantity: Quantity) -\u003e Self {\n        Self { price, quantity }\n    }\n}\n\n/// Price level update for order book deltas\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct PriceLevelUpdate {\n    /// Order side (bid or ask)\n    pub side: Side,\n    /// Price level\n    pub price: Price,\n    /// Quantity at this price level\n    pub quantity: Quantity,\n    /// Action to perform (update or delete)\n    pub action: UpdateAction,\n}\n\nimpl PriceLevelUpdate {\n    /// Creates a new price level update\n    pub fn new(side: Side, price: Price, quantity: Quantity, action: UpdateAction) -\u003e Self {\n        Self {\n            side,\n            price,\n            quantity,\n            action,\n        }\n    }\n\n    /// Creates an update action for the given side, price, and quantity\n    pub fn update(side: Side, price: Price, quantity: Quantity) -\u003e Self {\n        Self::new(side, price, quantity, UpdateAction::Update)\n    }\n\n    /// Creates a delete action for the given side and price\n    pub fn delete(side: Side, price: Price) -\u003e Self {\n        Self::new(side, price, Quantity::zero(), UpdateAction::Delete)\n    }\n}\n\n/// Complete order book snapshot with full state\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct OrderBookSnapshot {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the snapshot\n    pub timestamp: Timestamp,\n    /// Bid levels (price -\u003e quantity)\n    pub bids: BTreeMap\u003cPrice, Quantity\u003e,\n    /// Ask levels (price -\u003e quantity)\n    pub asks: BTreeMap\u003cPrice, Quantity\u003e,\n}\n\nimpl OrderBookSnapshot {\n    /// Creates a new empty order book snapshot\n    pub fn new(sequence: SequenceNumber, timestamp: Timestamp) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            bids: BTreeMap::new(),\n            asks: BTreeMap::new(),\n        }\n    }\n\n    /// Creates a new order book snapshot with the given levels\n    pub fn with_levels(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        bids: BTreeMap\u003cPrice, Quantity\u003e,\n        asks: BTreeMap\u003cPrice, Quantity\u003e,\n    ) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            bids,\n            asks,\n        }\n    }\n\n    /// Get the best bid (highest price on bid side)\n    pub fn best_bid(\u0026self) -\u003e Option\u003c\u0026Price\u003e {\n        self.bids.keys().next_back()\n    }\n\n    /// Get the best ask (lowest price on ask side)\n    pub fn best_ask(\u0026self) -\u003e Option\u003c\u0026Price\u003e {\n        self.asks.keys().next()\n    }\n\n    /// Get the mid price if both sides have liquidity\n    pub fn mid_price(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price((bid.0 + ask.0) / rust_decimal::Decimal::from(2))),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get the spread between best bid and ask\n    pub fn spread(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price(ask.0 - bid.0)),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// Incremental order book delta with incremental updates\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct OrderBookDelta {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the delta\n    pub timestamp: Timestamp,\n    /// List of price level updates\n    pub updates: Vec\u003cPriceLevelUpdate\u003e,\n}\n\nimpl OrderBookDelta {\n    /// Creates a new empty order book delta\n    pub fn new(sequence: SequenceNumber, timestamp: Timestamp) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            updates: Vec::new(),\n        }\n    }\n\n    /// Creates a new order book delta with the given updates\n    pub fn with_updates(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        updates: Vec\u003cPriceLevelUpdate\u003e,\n    ) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            updates,\n        }\n    }\n\n    /// Adds a price level update to this delta\n    pub fn add_update(\u0026mut self, update: PriceLevelUpdate) {\n        self.updates.push(update);\n    }\n}\n\n/// Trade execution event\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct Trade {\n    /// Sequence number for ordering\n    pub sequence: SequenceNumber,\n    /// Timestamp of the trade\n    pub timestamp: Timestamp,\n    /// Trade price\n    pub price: Price,\n    /// Trade quantity\n    pub quantity: Quantity,\n    /// Taker side of the trade\n    pub side: Side,\n}\n\nimpl Trade {\n    /// Creates a new trade event\n    pub fn new(\n        sequence: SequenceNumber,\n        timestamp: Timestamp,\n        price: Price,\n        quantity: Quantity,\n        side: Side,\n    ) -\u003e Self {\n        Self {\n            sequence,\n            timestamp,\n            price,\n            quantity,\n            side,\n        }\n    }\n}\n\n/// AMM pool state update\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct AMMPoolUpdate {\n    /// Timestamp of the update\n    pub timestamp: Timestamp,\n    /// Updated token reserves\n    pub reserves: TokenReserves,\n    /// Updated square root price (for V3 pools)\n    pub sqrt_price: Option\u003cSqrtPriceX96\u003e,\n    /// Pool fee tier\n    pub fee_tier: FeeTier,\n}\n\nimpl AMMPoolUpdate {\n    /// Creates a new AMM pool update\n    pub fn new(\n        timestamp: Timestamp,\n        reserves: TokenReserves,\n        sqrt_price: Option\u003cSqrtPriceX96\u003e,\n        fee_tier: FeeTier,\n    ) -\u003e Self {\n        Self {\n            timestamp,\n            reserves,\n            sqrt_price,\n            fee_tier,\n        }\n    }\n\n    /// Calculate implied mid price from reserves (Uniswap V2 style)\n    pub fn implied_mid_from_reserves(\u0026self) -\u003e Price {\n        if self.reserves.token0.is_zero() {\n            return Price::zero();\n        }\n        Price(self.reserves.token1 / self.reserves.token0)\n    }\n\n    /// Get implied mid price (prefer sqrt_price if available, otherwise use reserves)\n    pub fn implied_mid(\u0026self) -\u003e Price {\n        match self.sqrt_price {\n            Some(sqrt_price) =\u003e sqrt_price.to_price(),\n            None =\u003e self.implied_mid_from_reserves(),\n        }\n    }\n}\n\n/// Market events that can be processed by the system\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub enum MarketEvent {\n    /// Order book snapshot\n    OrderBookSnapshot(Symbol, OrderBookSnapshot),\n    /// Order book delta update\n    OrderBookDelta(Symbol, OrderBookDelta),\n    /// Trade execution\n    Trade(Symbol, Trade),\n    /// AMM pool update\n    AMMUpdate(PoolAddress, AMMPoolUpdate),\n}\n\nimpl MarketEvent {\n    /// Returns the timestamp of this market event\n    pub fn timestamp(\u0026self) -\u003e Timestamp {\n        match self {\n            MarketEvent::OrderBookSnapshot(_, snapshot) =\u003e snapshot.timestamp,\n            MarketEvent::OrderBookDelta(_, delta) =\u003e delta.timestamp,\n            MarketEvent::Trade(_, trade) =\u003e trade.timestamp,\n            MarketEvent::AMMUpdate(_, update) =\u003e update.timestamp,\n        }\n    }\n\n    /// Returns the sequence number if available\n    pub fn sequence(\u0026self) -\u003e Option\u003cSequenceNumber\u003e {\n        match self {\n            MarketEvent::OrderBookSnapshot(_, snapshot) =\u003e Some(snapshot.sequence),\n            MarketEvent::OrderBookDelta(_, delta) =\u003e Some(delta.sequence),\n            MarketEvent::Trade(_, trade) =\u003e Some(trade.sequence),\n            MarketEvent::AMMUpdate(_, _) =\u003e None, // AMM updates don't have sequence numbers\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_order_book_snapshot_best_prices() {\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n\n        // Add some bid levels\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n\n        // Add some ask levels\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(12.0)));\n\n        assert_eq!(snapshot.best_bid(), Some(\u0026Price(dec!(100.0))));\n        assert_eq!(snapshot.best_ask(), Some(\u0026Price(dec!(100.5))));\n        assert_eq!(snapshot.mid_price(), Some(Price(dec!(100.25))));\n        assert_eq!(snapshot.spread(), Some(Price(dec!(0.5))));\n    }\n\n    #[test]\n    fn test_amm_pool_implied_price() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n\n        let implied_price = update.implied_mid_from_reserves();\n        assert_eq!(implied_price, Price(dec!(2.0))); // 2000 / 1000 = 2.0\n    }\n\n    #[test]\n    fn test_price_level_update_creation() {\n        let update = PriceLevelUpdate::update(Side::Bid, Price(dec!(100.0)), Quantity(dec!(5.0)));\n\n        assert_eq!(update.side, Side::Bid);\n        assert_eq!(update.price, Price(dec!(100.0)));\n        assert_eq!(update.quantity, Quantity(dec!(5.0)));\n        assert_eq!(update.action, UpdateAction::Update);\n\n        let delete = PriceLevelUpdate::delete(Side::Ask, Price(dec!(101.0)));\n        assert_eq!(delete.action, UpdateAction::Delete);\n        assert!(delete.quantity.is_zero());\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":20}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":47,"address":[],"length":0,"stats":{"Line":40}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":43}},{"line":75,"address":[],"length":0,"stats":{"Line":43}},{"line":76,"address":[],"length":0,"stats":{"Line":43}},{"line":81,"address":[],"length":0,"stats":{"Line":204}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":16}},{"line":101,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":16}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":2}},{"line":115,"address":[],"length":0,"stats":{"Line":8}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":12}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":12}},{"line":226,"address":[],"length":0,"stats":{"Line":4}},{"line":227,"address":[],"length":0,"stats":{"Line":8}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}}],"covered":26,"coverable":48},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","market_data.rs"],"content":"use crate::domain::{amm_pool::*, events::*, order_book::*, types::*};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// Market data manager that holds all order books and AMM pools\n#[derive(Debug)]\npub struct MarketDataManager {\n    /// Thread-safe order books indexed by symbol\n    pub orderbooks: Arc\u003cRwLock\u003cHashMap\u003cSymbol, ThreadSafeOrderBook\u003e\u003e\u003e,\n    /// Thread-safe AMM pools indexed by address\n    pub amm_pools: Arc\u003cRwLock\u003cHashMap\u003cPoolAddress, ThreadSafeAMMPool\u003e\u003e\u003e,\n}\n\nimpl MarketDataManager {\n    /// Creates a new market data manager\n    pub fn new() -\u003e Self {\n        Self {\n            orderbooks: Arc::new(RwLock::new(HashMap::new())),\n            amm_pools: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Process a market event\n    pub fn process_event(\u0026self, event: MarketEvent) -\u003e TradingResult\u003c()\u003e {\n        match event {\n            MarketEvent::OrderBookSnapshot(symbol, snapshot) =\u003e {\n                self.apply_orderbook_snapshot(symbol, snapshot)\n            }\n            MarketEvent::OrderBookDelta(symbol, delta) =\u003e {\n                self.apply_orderbook_delta(symbol, \u0026delta)\n            }\n            MarketEvent::Trade(symbol, trade) =\u003e self.process_trade(symbol, trade),\n            MarketEvent::AMMUpdate(address, update) =\u003e self.process_amm_update(address, update),\n        }\n    }\n\n    /// Apply order book snapshot\n    pub fn apply_orderbook_snapshot(\n        \u0026self,\n        symbol: Symbol,\n        snapshot: OrderBookSnapshot,\n    ) -\u003e TradingResult\u003c()\u003e {\n        let mut books = self\n            .orderbooks\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        if let Some(book) = books.get(\u0026symbol) {\n            book.apply_snapshot(snapshot)?\n        } else {\n            // Create new order book if it doesn't exist\n            let new_book = ThreadSafeOrderBook::new(symbol.clone());\n            new_book.apply_snapshot(snapshot)?;\n            books.insert(symbol, new_book);\n        }\n        Ok(())\n    }\n\n    /// Apply order book delta update\n    pub fn apply_orderbook_delta(\n        \u0026self,\n        symbol: Symbol,\n        delta: \u0026OrderBookDelta,\n    ) -\u003e TradingResult\u003c()\u003e {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        if let Some(book) = books.get(\u0026symbol) {\n            book.apply_delta(delta)?\n        } else {\n            return Err(TradingError::ParseError(format!(\n                \"No order book found for symbol: {}\",\n                symbol\n            )));\n        }\n        Ok(())\n    }\n\n    /// Process trade (for now, just log it - could be used for analytics)\n    fn process_trade(\u0026self, _symbol: Symbol, _trade: Trade) -\u003e TradingResult\u003c()\u003e {\n        // In a full implementation, this would update trade statistics,\n        // volume metrics, etc.\n        Ok(())\n    }\n\n    /// Process AMM pool update\n    fn process_amm_update(\u0026self, address: PoolAddress, update: AMMPoolUpdate) -\u003e TradingResult\u003c()\u003e {\n        let mut pools = self\n            .amm_pools\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        match pools.get(\u0026address) {\n            Some(pool) =\u003e {\n                pool.update_state(update)?;\n            }\n            None =\u003e {\n                // Create new pool - assume V2 style if no sqrt_price, V3 if sqrt_price exists\n                let pool = match update.sqrt_price {\n                    Some(sqrt_price) =\u003e ThreadSafeAMMPool::new_v3(\n                        address.clone(),\n                        update.reserves,\n                        sqrt_price,\n                        update.fee_tier,\n                    ),\n                    None =\u003e {\n                        ThreadSafeAMMPool::new_v2(address.clone(), update.reserves, update.fee_tier)\n                    }\n                };\n                pools.insert(address, pool);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get order book for symbol\n    pub fn get_orderbook(\u0026self, symbol: \u0026Symbol) -\u003e Option\u003cThreadSafeOrderBook\u003e {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        books.get(symbol).cloned()\n    }\n\n    /// Get AMM pool for address\n    pub fn get_amm_pool(\u0026self, address: \u0026PoolAddress) -\u003e Option\u003cThreadSafeAMMPool\u003e {\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        pools.get(address).cloned()\n    }\n\n    /// Add new AMM pool\n    pub fn add_amm_pool(\u0026self, address: PoolAddress, pool: ThreadSafeAMMPool) {\n        let mut pools = self\n            .amm_pools\n            .write()\n            .expect(\"Failed to acquire write lock\");\n        pools.insert(address, pool);\n    }\n\n    /// Get all order book symbols\n    pub fn get_orderbook_symbols(\u0026self) -\u003e Vec\u003cSymbol\u003e {\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        books.keys().cloned().collect()\n    }\n\n    /// Get all AMM pool addresses\n    pub fn get_amm_pool_addresses(\u0026self) -\u003e Vec\u003cPoolAddress\u003e {\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        pools.keys().cloned().collect()\n    }\n\n    /// Get market metrics for all instruments\n    pub fn get_market_metrics(\u0026self) -\u003e MarketMetrics {\n        let mut metrics = MarketMetrics::new();\n\n        // Collect order book metrics\n        let books = self.orderbooks.read().expect(\"Failed to acquire read lock\");\n        for (symbol, book) in books.iter() {\n            if let (Some(bid), Some(ask)) = (book.best_bid(), book.best_ask()) {\n                let spread = ask.0 - bid.0;\n                let mid_price = (bid.0 + ask.0) / rust_decimal::Decimal::from(2);\n\n                metrics.orderbook_metrics.insert(\n                    symbol.clone(),\n                    OrderBookMetrics {\n                        symbol: symbol.clone(),\n                        best_bid: bid,\n                        best_ask: ask,\n                        mid_price: Price(mid_price),\n                        spread,\n                        last_update: book.last_update(),\n                    },\n                );\n            }\n        }\n\n        // Collect AMM pool metrics\n        let pools = self.amm_pools.read().expect(\"Failed to acquire read lock\");\n        for (address, pool) in pools.iter() {\n            metrics.amm_metrics.insert(\n                address.clone(),\n                AMMMetrics {\n                    address: address.clone(),\n                    pool_type: pool.pool_type(),\n                    implied_mid: pool.implied_mid(),\n                    reserves: pool.get_reserves(),\n                    fee_tier: pool.get_fee_tier(),\n                    last_update: pool.last_update(),\n                },\n            );\n        }\n\n        metrics.timestamp = chrono::Utc::now();\n        metrics\n    }\n}\n\nimpl Default for MarketDataManager {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Market metrics aggregated across all instruments\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MarketMetrics {\n    /// Timestamp when metrics were collected\n    pub timestamp: Timestamp,\n    /// Order book metrics by symbol\n    pub orderbook_metrics: HashMap\u003cSymbol, OrderBookMetrics\u003e,\n    /// AMM pool metrics by pool address\n    pub amm_metrics: HashMap\u003cPoolAddress, AMMMetrics\u003e,\n}\n\nimpl MarketMetrics {\n    /// Creates new market metrics with current timestamp\n    pub fn new() -\u003e Self {\n        Self {\n            timestamp: chrono::Utc::now(),\n            orderbook_metrics: HashMap::new(),\n            amm_metrics: HashMap::new(),\n        }\n    }\n}\n\nimpl Default for MarketMetrics {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Order book metrics for a specific symbol\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBookMetrics {\n    /// Trading symbol\n    pub symbol: Symbol,\n    /// Best bid price\n    pub best_bid: Price,\n    /// Best ask price\n    pub best_ask: Price,\n    /// Mid price (average of best bid and ask)\n    pub mid_price: Price,\n    /// Bid-ask spread\n    pub spread: rust_decimal::Decimal,\n    /// Timestamp of last update\n    pub last_update: Timestamp,\n}\n\n/// AMM pool metrics\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AMMMetrics {\n    /// Pool address\n    pub address: PoolAddress,\n    /// Type of AMM pool (V2/V3)\n    pub pool_type: AMMPoolType,\n    /// Implied mid price from reserves\n    pub implied_mid: Price,\n    /// Token reserves in the pool\n    pub reserves: TokenReserves,\n    /// Fee tier for the pool\n    pub fee_tier: FeeTier,\n    /// Timestamp of last update\n    pub last_update: Timestamp,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_market_data_manager_creation() {\n        let manager = MarketDataManager::new();\n        assert!(manager.get_orderbook_symbols().is_empty());\n        assert!(manager.get_amm_pool_addresses().is_empty());\n    }\n\n    #[test]\n    fn test_orderbook_snapshot_processing() {\n        let manager = MarketDataManager::new();\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        let book = manager.get_orderbook(\u0026symbol).unwrap();\n        assert_eq!(book.best_bid(), Some(Price(dec!(2000.0))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(2001.0))));\n    }\n\n    #[test]\n    fn test_orderbook_delta_processing() {\n        let manager = MarketDataManager::new();\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        // First, create initial snapshot\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        // Then apply delta\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(1999.0)),\n                Quantity(dec!(5.0)),\n            )],\n        );\n\n        let event = MarketEvent::OrderBookDelta(symbol.clone(), delta);\n        manager.process_event(event).unwrap();\n\n        let book = manager.get_orderbook(\u0026symbol).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(1999.0))),\n            Quantity(dec!(5.0))\n        );\n    }\n\n    #[test]\n    fn test_amm_update_processing() {\n        let manager = MarketDataManager::new();\n        let address = PoolAddress(\"0x123\".to_string());\n\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n\n        let event = MarketEvent::AMMUpdate(address.clone(), update);\n        manager.process_event(event).unwrap();\n\n        let pool = manager.get_amm_pool(\u0026address).unwrap();\n        assert_eq!(pool.implied_mid(), Price(dec!(2.0)));\n        assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n    }\n\n    #[test]\n    fn test_market_metrics_collection() {\n        let manager = MarketDataManager::new();\n\n        // Add order book\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2000.0)), Quantity(dec!(10.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2001.0)), Quantity(dec!(8.0)));\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n        manager.process_event(event).unwrap();\n\n        // Add AMM pool\n        let address = PoolAddress(\"0x123\".to_string());\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n        let update = AMMPoolUpdate::new(chrono::Utc::now(), reserves, None, FeeTier(30));\n        let event = MarketEvent::AMMUpdate(address.clone(), update);\n        manager.process_event(event).unwrap();\n\n        // Get metrics\n        let metrics = manager.get_market_metrics();\n\n        assert_eq!(metrics.orderbook_metrics.len(), 1);\n        assert_eq!(metrics.amm_metrics.len(), 1);\n\n        let ob_metrics = metrics.orderbook_metrics.get(\u0026symbol).unwrap();\n        assert_eq!(ob_metrics.best_bid, Price(dec!(2000.0)));\n        assert_eq!(ob_metrics.best_ask, Price(dec!(2001.0)));\n        assert_eq!(ob_metrics.mid_price, Price(dec!(2000.5)));\n\n        let amm_metrics = metrics.amm_metrics.get(\u0026address).unwrap();\n        assert_eq!(amm_metrics.implied_mid, Price(dec!(2.0)));\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":18}},{"line":20,"address":[],"length":0,"stats":{"Line":72}},{"line":21,"address":[],"length":0,"stats":{"Line":36}},{"line":26,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":30}},{"line":28,"address":[],"length":0,"stats":{"Line":16}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":32,"address":[],"length":0,"stats":{"Line":24}},{"line":34,"address":[],"length":0,"stats":{"Line":12}},{"line":35,"address":[],"length":0,"stats":{"Line":36}},{"line":40,"address":[],"length":0,"stats":{"Line":16}},{"line":45,"address":[],"length":0,"stats":{"Line":32}},{"line":46,"address":[],"length":0,"stats":{"Line":16}},{"line":49,"address":[],"length":0,"stats":{"Line":32}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":64}},{"line":54,"address":[],"length":0,"stats":{"Line":48}},{"line":55,"address":[],"length":0,"stats":{"Line":16}},{"line":57,"address":[],"length":0,"stats":{"Line":16}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":66,"address":[],"length":0,"stats":{"Line":24}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":12}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":116,"address":[],"length":0,"stats":{"Line":12}},{"line":117,"address":[],"length":0,"stats":{"Line":48}},{"line":118,"address":[],"length":0,"stats":{"Line":36}},{"line":122,"address":[],"length":0,"stats":{"Line":4}},{"line":123,"address":[],"length":0,"stats":{"Line":16}},{"line":124,"address":[],"length":0,"stats":{"Line":12}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":16}},{"line":139,"address":[],"length":0,"stats":{"Line":12}},{"line":143,"address":[],"length":0,"stats":{"Line":4}},{"line":144,"address":[],"length":0,"stats":{"Line":16}},{"line":145,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":16}},{"line":154,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":16}},{"line":175,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":4}},{"line":190,"address":[],"length":0,"stats":{"Line":4}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":215,"address":[],"length":0,"stats":{"Line":8}},{"line":216,"address":[],"length":0,"stats":{"Line":4}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}}],"covered":60,"coverable":75},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","mod.rs"],"content":"//! Domain layer containing core business logic and entities\n//!\n//! This module contains the core domain entities and business logic for the quantitative\n//! trading system, including order books, AMM pools, arbitrage detection, and market events.\n\n/// AMM pool implementations and utilities\npub mod amm_pool;\n/// Arbitrage detection and opportunity analysis\npub mod arbitrage;\n/// Market events and data structures\npub mod events;\n/// Market data management and aggregation\npub mod market_data;\n/// Order book implementations\npub mod order_book;\n/// Core types and primitives\npub mod types;\n\npub use events::*;\npub use market_data::*;\npub use types::*;\n\npub use amm_pool::{AMMPool, AMMPoolType, PriceImpactResult, ThreadSafeAMMPool, TokenIndex};\npub use arbitrage::{ArbitrageDetector, ArbitrageOpportunity, Venue};\npub use order_book::{OrderBookL2, ThreadSafeOrderBook};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","order_book.rs"],"content":"use crate::domain::{events::*, types::*};\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse std::sync::RwLock;\n\n/// Thread-safe L2 order book implementation\n/// Uses BTreeMap for automatic price sorting and O(log n) operations\n#[derive(Debug)]\npub struct OrderBookL2 {\n    symbol: Symbol,\n    /// Bids sorted by price (descending - highest first)\n    bids: BTreeMap\u003cPrice, Quantity\u003e,\n    /// Asks sorted by price (ascending - lowest first)  \n    asks: BTreeMap\u003cPrice, Quantity\u003e,\n    /// Last processed sequence number for idempotent replay\n    last_sequence: SequenceNumber,\n    /// Timestamp of last update\n    last_update: Timestamp,\n}\n\nimpl OrderBookL2 {\n    /// Creates a new order book for the given symbol\n    pub fn new(symbol: Symbol) -\u003e Self {\n        Self {\n            symbol,\n            bids: BTreeMap::new(),\n            asks: BTreeMap::new(),\n            last_sequence: SequenceNumber(0),\n            last_update: chrono::Utc::now(),\n        }\n    }\n\n    /// Apply a complete snapshot, replacing all existing data\n    pub fn apply_snapshot(\u0026mut self, snapshot: OrderBookSnapshot) -\u003e TradingResult\u003c()\u003e {\n        // Validate sequence number progression\n        if snapshot.sequence.0 \u003c= self.last_sequence.0 {\n            return Err(TradingError::SequenceOutOfOrder {\n                expected: self.last_sequence.0 + 1,\n                actual: snapshot.sequence.0,\n            });\n        }\n\n        self.bids = snapshot.bids;\n        self.asks = snapshot.asks;\n        self.last_sequence = snapshot.sequence;\n        self.last_update = snapshot.timestamp;\n\n        Ok(())\n    }\n\n    /// Apply incremental delta updates\n    pub fn apply_delta(\u0026mut self, delta: OrderBookDelta) -\u003e TradingResult\u003c()\u003e {\n        // Validate sequence number progression for idempotent replay\n        if delta.sequence.0 \u003c= self.last_sequence.0 {\n            // Skip if we've already processed this sequence\n            return Ok(());\n        }\n\n        if delta.sequence.0 != self.last_sequence.0 + 1 {\n            return Err(TradingError::SequenceOutOfOrder {\n                expected: self.last_sequence.0 + 1,\n                actual: delta.sequence.0,\n            });\n        }\n\n        // Apply each update in the delta\n        for update in delta.updates {\n            self.apply_price_level_update(update)?;\n        }\n\n        self.last_sequence = delta.sequence;\n        self.last_update = delta.timestamp;\n\n        Ok(())\n    }\n\n    /// Apply a single price level update\n    fn apply_price_level_update(\u0026mut self, update: PriceLevelUpdate) -\u003e TradingResult\u003c()\u003e {\n        let levels = match update.side {\n            Side::Bid =\u003e \u0026mut self.bids,\n            Side::Ask =\u003e \u0026mut self.asks,\n        };\n\n        match update.action {\n            UpdateAction::Update =\u003e {\n                if update.quantity.is_zero() {\n                    levels.remove(\u0026update.price);\n                } else {\n                    levels.insert(update.price, update.quantity);\n                }\n            }\n            UpdateAction::Delete =\u003e {\n                levels.remove(\u0026update.price);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get atomic snapshot without blocking writers\n    pub fn get_snapshot(\u0026self) -\u003e OrderBookSnapshot {\n        OrderBookSnapshot::with_levels(\n            self.last_sequence,\n            self.last_update,\n            self.bids.clone(),\n            self.asks.clone(),\n        )\n    }\n\n    /// Get best bid price (highest bid)\n    pub fn best_bid(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.bids.keys().next_back().copied()\n    }\n\n    /// Get best ask price (lowest ask)\n    pub fn best_ask(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.asks.keys().next().copied()\n    }\n\n    /// Get mid price if both sides have liquidity\n    pub fn mid_price(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price((bid.0 + ask.0) / rust_decimal::Decimal::from(2))),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get spread between best bid and ask\n    pub fn spread(\u0026self) -\u003e Option\u003cPrice\u003e {\n        match (self.best_bid(), self.best_ask()) {\n            (Some(bid), Some(ask)) =\u003e Some(Price(ask.0 - bid.0)),\n            _ =\u003e None,\n        }\n    }\n\n    /// Get quantity at specific price level\n    pub fn quantity_at_price(\u0026self, side: Side, price: Price) -\u003e Quantity {\n        let levels = match side {\n            Side::Bid =\u003e \u0026self.bids,\n            Side::Ask =\u003e \u0026self.asks,\n        };\n\n        levels.get(\u0026price).copied().unwrap_or(Quantity::zero())\n    }\n\n    /// Get depth (total quantity) up to a certain price\n    pub fn depth_to_price(\u0026self, side: Side, max_price: Price) -\u003e Quantity {\n        let levels = match side {\n            Side::Bid =\u003e \u0026self.bids,\n            Side::Ask =\u003e \u0026self.asks,\n        };\n\n        let mut total = rust_decimal::Decimal::ZERO;\n\n        match side {\n            Side::Bid =\u003e {\n                // For bids, sum all levels \u003e= max_price (since we want depth at or above this price)\n                for (_price, quantity) in levels.range(max_price..) {\n                    total += quantity.0;\n                }\n            }\n            Side::Ask =\u003e {\n                // For asks, sum all levels \u003c= max_price (since we want depth at or below this price)\n                for (_price, quantity) in levels.range(..=max_price) {\n                    total += quantity.0;\n                }\n            }\n        }\n\n        Quantity(total)\n    }\n\n    /// Get the symbol for this order book\n    pub fn symbol(\u0026self) -\u003e \u0026Symbol {\n        \u0026self.symbol\n    }\n\n    /// Get last processed sequence number\n    pub fn last_sequence(\u0026self) -\u003e SequenceNumber {\n        self.last_sequence\n    }\n\n    /// Get timestamp of last update\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.last_update\n    }\n}\n\n/// Thread-safe wrapper around OrderBookL2\n#[derive(Debug, Clone)]\npub struct ThreadSafeOrderBook {\n    inner: Arc\u003cRwLock\u003cOrderBookL2\u003e\u003e,\n}\n\nimpl ThreadSafeOrderBook {\n    /// Creates a new thread-safe order book for the given symbol\n    pub fn new(symbol: Symbol) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(OrderBookL2::new(symbol))),\n        }\n    }\n\n    /// Apply snapshot with write lock\n    pub fn apply_snapshot(\u0026self, snapshot: OrderBookSnapshot) -\u003e TradingResult\u003c()\u003e {\n        let mut book = self\n            .inner\n            .write()\n            .map_err(|_| TradingError::LockError(\"Failed to acquire write lock\".to_string()))?;\n        book.apply_snapshot(snapshot)\n    }\n\n    /// Apply a delta update to the order book\n    pub fn apply_delta(\u0026self, delta: \u0026OrderBookDelta) -\u003e TradingResult\u003c()\u003e {\n        let mut book = self\n            .inner\n            .write()\n            .map_err(|_| TradingError::LockError(\"Failed to acquire write lock\".to_string()))?;\n        book.apply_delta(delta.clone())\n    }\n\n    /// Get a snapshot of the current order book state\n    pub fn get_snapshot(\u0026self) -\u003e OrderBookSnapshot {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .get_snapshot()\n    }\n\n    /// Get the best bid price\n    pub fn best_bid(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .best_bid()\n    }\n\n    /// Get the best ask price\n    pub fn best_ask(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .best_ask()\n    }\n\n    /// Get the mid price (average of best bid and ask)\n    pub fn mid_price(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .mid_price()\n    }\n\n    /// Get the spread (difference between best ask and bid)\n    pub fn spread(\u0026self) -\u003e Option\u003cPrice\u003e {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .spread()\n    }\n\n    /// Get quantity available at a specific price level\n    pub fn quantity_at_price(\u0026self, side: Side, price: Price) -\u003e Quantity {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .quantity_at_price(side, price)\n    }\n\n    /// Get total depth up to a maximum price\n    pub fn depth_to_price(\u0026self, side: Side, max_price: Price) -\u003e Quantity {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .depth_to_price(side, max_price)\n    }\n\n    /// Get the symbol for this order book\n    pub fn symbol(\u0026self) -\u003e Symbol {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .symbol()\n            .clone()\n    }\n\n    /// Get the last sequence number\n    pub fn last_sequence(\u0026self) -\u003e SequenceNumber {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_sequence()\n    }\n\n    /// Get the last update timestamp\n    pub fn last_update(\u0026self) -\u003e Timestamp {\n        self.inner\n            .read()\n            .expect(\"Failed to acquire read lock\")\n            .last_update()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n    use std::thread;\n    use std::time::Duration;\n\n    #[test]\n    fn test_order_book_snapshot_application() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(8.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(12.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.0))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(100.5))));\n        assert_eq!(book.mid_price(), Some(Price(dec!(100.25))));\n    }\n\n    #[test]\n    fn test_order_book_delta_application() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Apply initial snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Apply delta update\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(100.5)),\n                Quantity(dec!(15.0)),\n            )],\n        );\n\n        book.apply_delta(delta).unwrap();\n\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.5))));\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.5))),\n            Quantity(dec!(15.0))\n        );\n    }\n\n    #[test]\n    fn test_idempotent_replay() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        book.apply_snapshot(snapshot).unwrap();\n\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(2),\n            chrono::Utc::now(),\n            vec![PriceLevelUpdate::update(\n                Side::Bid,\n                Price(dec!(100.0)),\n                Quantity(dec!(10.0)),\n            )],\n        );\n\n        // Apply delta first time\n        book.apply_delta(delta.clone()).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.0))),\n            Quantity(dec!(10.0))\n        );\n\n        // Apply same delta again - should be idempotent\n        book.apply_delta(delta).unwrap();\n        assert_eq!(\n            book.quantity_at_price(Side::Bid, Price(dec!(100.0))),\n            Quantity(dec!(10.0))\n        );\n    }\n\n    #[test]\n    fn test_sequence_validation() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Try to apply delta with wrong sequence number\n        let delta = OrderBookDelta::new(SequenceNumber(5), chrono::Utc::now()); // Should be 2\n\n        let result = book.apply_delta(delta);\n        assert!(result.is_err());\n\n        if let Err(TradingError::SequenceOutOfOrder { expected, actual }) = result {\n            assert_eq!(expected, 2);\n            assert_eq!(actual, 5);\n        } else {\n            panic!(\"Expected SequenceOutOfOrder error\");\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_order_book() {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Apply initial snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test concurrent reads\n        let book_clone = book.clone();\n        let handle = thread::spawn(move || {\n            for _ in 0..100 {\n                let _ = book_clone.best_bid();\n                let _ = book_clone.get_snapshot();\n                thread::sleep(Duration::from_micros(1));\n            }\n        });\n\n        // Concurrent reads from main thread\n        for _ in 0..100 {\n            let _ = book.best_ask();\n            let _ = book.mid_price();\n            thread::sleep(Duration::from_micros(1));\n        }\n\n        handle.join().unwrap();\n\n        // Verify state is still consistent\n        assert_eq!(book.best_bid(), Some(Price(dec!(100.0))));\n    }\n\n    #[test]\n    fn test_depth_calculation() {\n        let mut book = OrderBookL2::new(Symbol(\"ETHUSDC\".to_string()));\n\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(100.0)), Quantity(dec!(10.0)));\n        snapshot.bids.insert(Price(dec!(99.5)), Quantity(dec!(5.0)));\n        snapshot.bids.insert(Price(dec!(99.0)), Quantity(dec!(8.0)));\n\n        snapshot\n            .asks\n            .insert(Price(dec!(100.5)), Quantity(dec!(12.0)));\n        snapshot\n            .asks\n            .insert(Price(dec!(101.0)), Quantity(dec!(7.0)));\n\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test bid depth\n        let bid_depth = book.depth_to_price(Side::Bid, Price(dec!(99.5)));\n        assert_eq!(bid_depth, Quantity(dec!(15.0))); // 10.0 + 5.0\n\n        // Test ask depth\n        let ask_depth = book.depth_to_price(Side::Ask, Price(dec!(101.0)));\n        assert_eq!(ask_depth, Quantity(dec!(19.0))); // 12.0 + 7.0\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":43}},{"line":26,"address":[],"length":0,"stats":{"Line":86}},{"line":27,"address":[],"length":0,"stats":{"Line":86}},{"line":28,"address":[],"length":0,"stats":{"Line":43}},{"line":29,"address":[],"length":0,"stats":{"Line":43}},{"line":34,"address":[],"length":0,"stats":{"Line":43}},{"line":36,"address":[],"length":0,"stats":{"Line":43}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":14}},{"line":54,"address":[],"length":0,"stats":{"Line":14}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":30}},{"line":68,"address":[],"length":0,"stats":{"Line":30}},{"line":71,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":79,"address":[],"length":0,"stats":{"Line":20}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":81,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":10}},{"line":86,"address":[],"length":0,"stats":{"Line":10}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":10}},{"line":101,"address":[],"length":0,"stats":{"Line":200}},{"line":103,"address":[],"length":0,"stats":{"Line":200}},{"line":104,"address":[],"length":0,"stats":{"Line":200}},{"line":105,"address":[],"length":0,"stats":{"Line":400}},{"line":106,"address":[],"length":0,"stats":{"Line":400}},{"line":111,"address":[],"length":0,"stats":{"Line":442}},{"line":112,"address":[],"length":0,"stats":{"Line":1326}},{"line":116,"address":[],"length":0,"stats":{"Line":438}},{"line":117,"address":[],"length":0,"stats":{"Line":1314}},{"line":121,"address":[],"length":0,"stats":{"Line":207}},{"line":122,"address":[],"length":0,"stats":{"Line":828}},{"line":123,"address":[],"length":0,"stats":{"Line":7}},{"line":124,"address":[],"length":0,"stats":{"Line":200}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":8}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":18}},{"line":138,"address":[],"length":0,"stats":{"Line":36}},{"line":139,"address":[],"length":0,"stats":{"Line":14}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":108}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":12}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":12}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":12}},{"line":164,"address":[],"length":0,"stats":{"Line":10}},{"line":170,"address":[],"length":0,"stats":{"Line":6}},{"line":174,"address":[],"length":0,"stats":{"Line":16}},{"line":175,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":33}},{"line":199,"address":[],"length":0,"stats":{"Line":99}},{"line":204,"address":[],"length":0,"stats":{"Line":33}},{"line":205,"address":[],"length":0,"stats":{"Line":66}},{"line":206,"address":[],"length":0,"stats":{"Line":33}},{"line":208,"address":[],"length":0,"stats":{"Line":33}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":12}},{"line":215,"address":[],"length":0,"stats":{"Line":6}},{"line":217,"address":[],"length":0,"stats":{"Line":6}},{"line":222,"address":[],"length":0,"stats":{"Line":200}},{"line":223,"address":[],"length":0,"stats":{"Line":400}},{"line":230,"address":[],"length":0,"stats":{"Line":229}},{"line":231,"address":[],"length":0,"stats":{"Line":458}},{"line":238,"address":[],"length":0,"stats":{"Line":227}},{"line":239,"address":[],"length":0,"stats":{"Line":454}},{"line":246,"address":[],"length":0,"stats":{"Line":205}},{"line":247,"address":[],"length":0,"stats":{"Line":410}},{"line":254,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":12}},{"line":263,"address":[],"length":0,"stats":{"Line":36}},{"line":266,"address":[],"length":0,"stats":{"Line":24}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":16}},{"line":279,"address":[],"length":0,"stats":{"Line":32}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":4}},{"line":296,"address":[],"length":0,"stats":{"Line":8}}],"covered":88,"coverable":99},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","domain","types.rs"],"content":"use rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Trading symbol identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct Symbol(pub String);\n\nimpl fmt::Display for Symbol {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Price with decimal precision to avoid floating-point errors\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct Price(pub Decimal);\n\nimpl Price {\n    /// Creates a zero price\n    pub fn zero() -\u003e Self {\n        Price(Decimal::ZERO)\n    }\n\n    /// Returns true if the price is zero\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl fmt::Display for Price {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Quantity with decimal precision\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct Quantity(pub Decimal);\n\nimpl Quantity {\n    /// Creates a zero quantity\n    pub fn zero() -\u003e Self {\n        Quantity(Decimal::ZERO)\n    }\n\n    /// Returns true if the quantity is zero\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl fmt::Display for Quantity {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Order side (bid or ask)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub enum Side {\n    /// Bid (buy) side\n    Bid,\n    /// Ask (sell) side\n    Ask,\n}\n\nimpl fmt::Display for Side {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            Side::Bid =\u003e write!(f, \"BID\"),\n            Side::Ask =\u003e write!(f, \"ASK\"),\n        }\n    }\n}\n\n/// Sequence number for idempotent message processing\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\npub struct SequenceNumber(pub u64);\n\nimpl fmt::Display for SequenceNumber {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Update action for price level changes\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum UpdateAction {\n    /// Add or update a price level\n    Update,\n    /// Remove a price level\n    Delete,\n}\n\n/// AMM pool address identifier\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct PoolAddress(pub String);\n\nimpl fmt::Display for PoolAddress {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n/// Token reserves in an AMM pool\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\npub struct TokenReserves {\n    /// Reserve amount for token0\n    pub token0: Decimal,\n    /// Reserve amount for token1\n    pub token1: Decimal,\n}\n\nimpl TokenReserves {\n    /// Creates new token reserves with the given amounts\n    pub fn new(token0: Decimal, token1: Decimal) -\u003e Self {\n        Self { token0, token1 }\n    }\n}\n\n/// Square root price for Uniswap V3 style pools\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub struct SqrtPriceX96(pub u128);\n\nimpl SqrtPriceX96 {\n    /// Convert sqrtPriceX96 to regular price\n    pub fn to_price(\u0026self) -\u003e Price {\n        // sqrtPriceX96 = sqrt(price) * 2^96\n        // So price = (sqrtPriceX96 / 2^96)^2\n\n        // Use a safer conversion that handles large numbers better\n        if self.0 == 0 {\n            return Price(Decimal::ZERO);\n        }\n\n        // Convert to f64 for calculation, then back to Decimal\n        let sqrt_price_f64 = self.0 as f64 / (2u128.pow(96) as f64);\n        let price_f64 = sqrt_price_f64 * sqrt_price_f64;\n\n        // Convert back to Decimal safely\n        match Decimal::try_from(price_f64) {\n            Ok(price) =\u003e Price(price),\n            Err(_) =\u003e Price(Decimal::ZERO), // Fallback for conversion errors\n        }\n    }\n}\n\n/// Fee tier for AMM pools (in basis points)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct FeeTier(pub u32);\n\nimpl FeeTier {\n    /// Convert to decimal (e.g., 30 basis points = 0.003)\n    pub fn to_decimal(\u0026self) -\u003e Decimal {\n        Decimal::from(self.0) / Decimal::from(10000u32)\n    }\n}\n\n/// Timestamp for market events\npub type Timestamp = chrono::DateTime\u003cchrono::Utc\u003e;\n\n/// Trading system errors\n#[derive(Debug, thiserror::Error)]\npub enum TradingError {\n    /// Invalid price value\n    #[error(\"Invalid price: {0}\")]\n    /// Invalid price provided\n    InvalidPrice(String),\n\n    /// Invalid quantity value\n    #[error(\"Invalid quantity: {0}\")]\n    /// Invalid quantity provided\n    InvalidQuantity(String),\n\n    /// Sequence number out of order\n    #[error(\"Sequence out of order: expected {expected}, got {actual}\")]\n    /// Sequence number is out of expected order\n    SequenceOutOfOrder {\n        /// Expected sequence number\n        expected: u64,\n        /// Actual sequence number received\n        actual: u64,\n    },\n\n    /// Insufficient liquidity for trade\n    #[error(\"Insufficient liquidity: {0}\")]\n    /// Insufficient liquidity available for the requested trade\n    InsufficientLiquidity(Decimal),\n\n    /// Parse error\n    #[error(\"Parse error: {0}\")]\n    /// Error parsing data\n    ParseError(String),\n\n    /// IO error\n    #[error(\"IO error: {0}\")]\n    /// Input/output error\n    IoError(#[from] std::io::Error),\n\n    /// Lock error\n    #[error(\"Lock error: {0}\")]\n    /// Error acquiring lock\n    LockError(String),\n\n    /// JSON error\n    #[error(\"JSON error: {0}\")]\n    /// JSON serialization/deserialization error\n    JsonError(#[from] serde_json::Error),\n}\n\n/// Result type for trading operations\npub type TradingResult\u003cT\u003e = Result\u003cT, TradingError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_price_ordering() {\n        let p1 = Price(dec!(100.50));\n        let p2 = Price(dec!(100.51));\n        assert!(p1 \u003c p2);\n    }\n\n    #[test]\n    fn test_quantity_operations() {\n        let q1 = Quantity(dec!(10.5));\n        let q2 = Quantity(dec!(5.25));\n        assert!(q1 \u003e q2);\n        assert!(!q1.is_zero());\n        assert!(Quantity::zero().is_zero());\n    }\n\n    #[test]\n    fn test_fee_tier_conversion() {\n        let fee = FeeTier(30); // 30 basis points\n        assert_eq!(fee.to_decimal(), dec!(0.003));\n    }\n\n    #[test]\n    fn test_sqrt_price_conversion() {\n        // Test with a simple case where sqrtPriceX96 represents sqrt(1) = 1\n        let sqrt_price = SqrtPriceX96(2u128.pow(96)); // This represents sqrt(1)\n        let price = sqrt_price.to_price();\n        // Should be approximately 1.0, allowing for some precision loss\n        assert!((price.0 - dec!(1.0)).abs() \u003c dec!(0.1));\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":24}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":24}},{"line":44,"address":[],"length":0,"stats":{"Line":24}},{"line":48,"address":[],"length":0,"stats":{"Line":18}},{"line":49,"address":[],"length":0,"stats":{"Line":36}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":42}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":133,"address":[],"length":0,"stats":{"Line":6}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":210}},{"line":156,"address":[],"length":0,"stats":{"Line":420}}],"covered":12,"coverable":30},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","ingestion","mod.rs"],"content":"//! Stream ingestion utilities for real-time market data processing\n//!\n//! This module provides components for ingesting and processing real-time market data streams\n//! with comprehensive statistics tracking and error handling.\n\n/// Stream ingestion with statistics and error handling\npub mod stream_ingester;\n\npub use stream_ingester::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","ingestion","stream_ingester.rs"],"content":"use crate::domain::{events::*, market_data::*};\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::{error, info};\n\n/// Stream ingester that processes market events concurrently\npub struct StreamIngester {\n    /// Channel receiver for incoming market events\n    receiver: mpsc::Receiver\u003cMarketEvent\u003e,\n    /// Market data manager to process events\n    manager: Arc\u003cMarketDataManager\u003e,\n    /// Buffer size for backpressure handling\n    buffer_size: usize,\n}\n\nimpl StreamIngester {\n    /// Create new stream ingester\n    pub fn new(receiver: mpsc::Receiver\u003cMarketEvent\u003e, manager: Arc\u003cMarketDataManager\u003e) -\u003e Self {\n        Self {\n            receiver,\n            manager,\n            buffer_size: 1000, // Default buffer size\n        }\n    }\n\n    /// Create stream ingester with custom buffer size\n    pub fn with_buffer_size(\n        receiver: mpsc::Receiver\u003cMarketEvent\u003e,\n        manager: Arc\u003cMarketDataManager\u003e,\n        buffer_size: usize,\n    ) -\u003e Self {\n        Self {\n            receiver,\n            manager,\n            buffer_size,\n        }\n    }\n\n    /// Run the ingestion loop\n    pub async fn run(\u0026mut self) {\n        info!(\n            \"Starting stream ingester with buffer size: {}\",\n            self.buffer_size\n        );\n\n        let mut event_count = 0u64;\n        let mut error_count = 0u64;\n\n        while let Some(event) = self.receiver.recv().await {\n            event_count += 1;\n\n            // Process the event\n            if let Err(e) = self.manager.process_event(event.clone()) {\n                error_count += 1;\n                error!(\"Failed to process event: {:?}, error: {}\", event, e);\n\n                // Log error details based on event type\n                match event {\n                    MarketEvent::OrderBookSnapshot(symbol, _) =\u003e {\n                        error!(\"Failed to process snapshot for symbol: {}\", symbol);\n                    }\n                    MarketEvent::OrderBookDelta(symbol, delta) =\u003e {\n                        error!(\n                            \"Failed to process delta for symbol: {}, seq: {}\",\n                            symbol, delta.sequence\n                        );\n                    }\n                    MarketEvent::Trade(symbol, trade) =\u003e {\n                        error!(\n                            \"Failed to process trade for symbol: {}, seq: {}\",\n                            symbol, trade.sequence\n                        );\n                    }\n                    MarketEvent::AMMUpdate(address, _) =\u003e {\n                        error!(\"Failed to process AMM update for pool: {}\", address);\n                    }\n                }\n            }\n\n            // Log progress periodically\n            if event_count % 1000 == 0 {\n                info!(\n                    \"Processed {} events, {} errors ({}% error rate)\",\n                    event_count,\n                    error_count,\n                    (error_count as f64 / event_count as f64) * 100.0\n                );\n            }\n        }\n\n        info!(\n            \"Stream ingester finished. Total events: {}, errors: {}\",\n            event_count, error_count\n        );\n    }\n\n    /// Get current buffer size\n    pub fn buffer_size(\u0026self) -\u003e usize {\n        self.buffer_size\n    }\n}\n\n/// Multi-stream ingester that can handle multiple concurrent streams\npub struct MultiStreamIngester {\n    /// Multiple receivers for different data streams\n    receivers: Vec\u003cmpsc::Receiver\u003cMarketEvent\u003e\u003e,\n    /// Market data manager to process events\n    manager: Arc\u003cMarketDataManager\u003e,\n    /// Buffer size per stream\n    buffer_size: usize,\n}\n\nimpl MultiStreamIngester {\n    /// Create new multi-stream ingester\n    pub fn new(\n        receivers: Vec\u003cmpsc::Receiver\u003cMarketEvent\u003e\u003e,\n        manager: Arc\u003cMarketDataManager\u003e,\n    ) -\u003e Self {\n        Self {\n            receivers,\n            manager,\n            buffer_size: 1000,\n        }\n    }\n\n    /// Run all streams concurrently\n    pub async fn run(self) {\n        info!(\n            \"Starting multi-stream ingester with {} streams\",\n            self.receivers.len()\n        );\n\n        let mut handles = Vec::new();\n\n        // Spawn a task for each stream\n        for (stream_id, receiver) in self.receivers.into_iter().enumerate() {\n            let manager = Arc::clone(\u0026self.manager);\n            let buffer_size = self.buffer_size;\n\n            let handle = tokio::spawn(async move {\n                let mut ingester = StreamIngester::with_buffer_size(receiver, manager, buffer_size);\n                info!(\"Starting stream {} ingestion\", stream_id);\n                ingester.run().await;\n                info!(\"Stream {} ingestion completed\", stream_id);\n            });\n\n            handles.push(handle);\n        }\n\n        // Wait for all streams to complete\n        for (stream_id, handle) in handles.into_iter().enumerate() {\n            if let Err(e) = handle.await {\n                error!(\"Stream {} failed: {}\", stream_id, e);\n            }\n        }\n\n        info!(\"All streams completed\");\n    }\n}\n\n/// Event statistics for stream ingestion performance\n#[derive(Debug, Clone, Default)]\npub struct IngestionStats {\n    /// Total number of events processed\n    pub total_events: u64,\n    /// Number of successfully processed events\n    pub successful_events: u64,\n    /// Number of events that failed processing\n    pub failed_events: u64,\n    /// Current processing rate in events per second\n    pub events_per_second: f64,\n    /// Timestamp of the last processed event\n    pub last_event_timestamp: Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e,\n    /// Timestamp when ingestion started\n    pub start_time: chrono::DateTime\u003cchrono::Utc\u003e,\n}\n\nimpl IngestionStats {\n    /// Creates new ingestion statistics\n    pub fn new() -\u003e Self {\n        Self {\n            start_time: chrono::Utc::now(),\n            ..Default::default()\n        }\n    }\n\n    /// Records an event and updates statistics\n    pub fn record_event(\u0026mut self, success: bool) {\n        self.total_events += 1;\n        self.last_event_timestamp = Some(chrono::Utc::now());\n\n        if success {\n            self.successful_events += 1;\n        } else {\n            self.failed_events += 1;\n        }\n    }\n\n    /// Calculates the success rate as a percentage\n    pub fn success_rate(\u0026self) -\u003e f64 {\n        if self.total_events \u003e 0 {\n            (self.successful_events as f64 / self.total_events as f64) * 100.0\n        } else {\n            0.0\n        }\n    }\n\n    /// Calculates the error rate as a percentage\n    pub fn error_rate(\u0026self) -\u003e f64 {\n        if self.total_events \u003e 0 {\n            (self.failed_events as f64 / self.total_events as f64) * 100.0\n        } else {\n            0.0\n        }\n    }\n}\n\n/// Stream ingester with detailed statistics tracking\npub struct StatisticalStreamIngester {\n    receiver: mpsc::Receiver\u003cMarketEvent\u003e,\n    manager: Arc\u003cMarketDataManager\u003e,\n    stats: IngestionStats,\n    report_interval: u64,\n}\n\nimpl StatisticalStreamIngester {\n    /// Creates a new stream ingester with the given receiver and market data manager\n    pub fn new(receiver: mpsc::Receiver\u003cMarketEvent\u003e, manager: Arc\u003cMarketDataManager\u003e) -\u003e Self {\n        Self {\n            receiver,\n            manager,\n            stats: IngestionStats::new(),\n            report_interval: 1000, // Report every 1000 events\n        }\n    }\n\n    /// Runs the statistical stream ingester, processing events and reporting statistics\n    pub async fn run(\u0026mut self) {\n        info!(\"Starting statistical stream ingester\");\n\n        while let Some(event) = self.receiver.recv().await {\n            // Process the event\n            let success = self.manager.process_event(event.clone()).is_ok();\n            self.stats.record_event(success);\n\n            if !success {\n                error!(\"Failed to process event: {:?}\", event);\n            }\n\n            // Report statistics periodically\n            if self.stats.total_events % self.report_interval == 0 {\n                self.report_stats();\n            }\n        }\n\n        // Final report\n        self.report_stats();\n        info!(\"Statistical stream ingester finished\");\n    }\n\n    fn report_stats(\u0026self) {\n        info!(\n            \"Stats - Total: {}, Successful: {}, Failed: {}, Success Rate: {:.2}%, Error Rate: {:.2}%\",\n            self.stats.total_events,\n            self.stats.successful_events,\n            self.stats.failed_events,\n            self.stats.success_rate(),\n            self.stats.error_rate()\n        );\n    }\n\n    /// Returns the current ingestion statistics\n    pub fn get_stats(\u0026self) -\u003e \u0026IngestionStats {\n        \u0026self.stats\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::types::*;\n    use rust_decimal_macros::dec;\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn test_stream_ingester_basic() {\n        let manager = Arc::new(MarketDataManager::new());\n        let (tx, rx) = mpsc::channel(10);\n        let mut ingester = StreamIngester::new(rx, manager.clone());\n\n        // Send a test event\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n\n        tx.send(event).await.unwrap();\n        drop(tx); // Close the channel\n\n        // Run ingester\n        ingester.run().await;\n\n        // Verify event was processed\n        assert!(manager.get_orderbook(\u0026symbol).is_some());\n    }\n\n    #[tokio::test]\n    async fn test_multi_stream_ingester() {\n        let manager = Arc::new(MarketDataManager::new());\n\n        // Create multiple streams\n        let (tx1, rx1) = mpsc::channel(10);\n        let (tx2, rx2) = mpsc::channel(10);\n\n        let multi_ingester = MultiStreamIngester::new(vec![rx1, rx2], manager.clone());\n\n        // Send events to both streams\n        let symbol1 = Symbol(\"ETHUSDC\".to_string());\n        let symbol2 = Symbol(\"BTCUSDC\".to_string());\n\n        let snapshot1 = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        let snapshot2 = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n\n        tx1.send(MarketEvent::OrderBookSnapshot(symbol1.clone(), snapshot1))\n            .await\n            .unwrap();\n        tx2.send(MarketEvent::OrderBookSnapshot(symbol2.clone(), snapshot2))\n            .await\n            .unwrap();\n\n        drop(tx1);\n        drop(tx2);\n\n        // Run multi-stream ingester\n        multi_ingester.run().await;\n\n        // Verify both events were processed\n        assert!(manager.get_orderbook(\u0026symbol1).is_some());\n        assert!(manager.get_orderbook(\u0026symbol2).is_some());\n    }\n\n    #[tokio::test]\n    async fn test_ingestion_stats() {\n        let manager = Arc::new(MarketDataManager::new());\n        let (tx, rx) = mpsc::channel(10);\n        let mut ingester = StatisticalStreamIngester::new(rx, manager);\n\n        // Send multiple events\n        let symbol = Symbol(\"ETHUSDC\".to_string());\n\n        // Snapshot\n        let snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        tx.send(MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot))\n            .await\n            .unwrap();\n\n        // Delta\n        let delta = OrderBookDelta::new(SequenceNumber(2), chrono::Utc::now());\n        tx.send(MarketEvent::OrderBookDelta(symbol.clone(), delta))\n            .await\n            .unwrap();\n\n        // Trade\n        let trade = Trade::new(\n            SequenceNumber(3),\n            chrono::Utc::now(),\n            Price(dec!(2445.0)),\n            Quantity(dec!(1.0)),\n            Side::Bid,\n        );\n        tx.send(MarketEvent::Trade(symbol, trade)).await.unwrap();\n\n        drop(tx);\n\n        // Run ingester\n        ingester.run().await;\n\n        // Check stats\n        let stats = ingester.get_stats();\n        assert_eq!(stats.total_events, 3);\n        assert_eq!(stats.successful_events, 3);\n        assert_eq!(stats.failed_events, 0);\n    }\n\n    #[test]\n    fn test_ingestion_stats_calculations() {\n        let mut stats = IngestionStats::new();\n\n        // Simulate some events\n\n        for _ in 0..8 {\n            stats.record_event(true);\n        }\n\n        // Record some failures\n        stats.record_event(false);\n        stats.record_event(false);\n\n        assert_eq!(stats.total_events, 10);\n        assert_eq!(stats.failed_events, 2);\n        assert_eq!(stats.error_rate(), 20.0); // 2/10 * 100 = 20%\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":27,"address":[],"length":0,"stats":{"Line":4}},{"line":40,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":16}},{"line":47,"address":[],"length":0,"stats":{"Line":16}},{"line":49,"address":[],"length":0,"stats":{"Line":72}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":20}},{"line":142,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":8}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":14}},{"line":152,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":2}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":26}},{"line":189,"address":[],"length":0,"stats":{"Line":26}},{"line":190,"address":[],"length":0,"stats":{"Line":26}},{"line":192,"address":[],"length":0,"stats":{"Line":48}},{"line":193,"address":[],"length":0,"stats":{"Line":22}},{"line":195,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":2}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":4}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":30}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":274,"address":[],"length":0,"stats":{"Line":2}}],"covered":42,"coverable":86},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","collector.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::{Arc, RwLock};\n\n/// Performance metrics collector for system performance monitoring\n#[derive(Debug, Default)]\npub struct MetricsCollector {\n    counters: Arc\u003cRwLock\u003cHashMap\u003cString, AtomicU64\u003e\u003e\u003e,\n    gauges: Arc\u003cRwLock\u003cHashMap\u003cString, AtomicU64\u003e\u003e\u003e,\n}\n\nimpl MetricsCollector {\n    /// Creates a new metrics collector\n    pub fn new() -\u003e Self {\n        Self {\n            counters: Arc::new(RwLock::new(HashMap::new())),\n            gauges: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Increments a named counter by 1\n    pub fn increment_counter(\u0026self, name: \u0026str) {\n        if let Some(counter) = self.counters.read().unwrap().get(name) {\n            counter.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    /// Sets a gauge to a specific value\n    pub fn set_gauge(\u0026self, name: \u0026str, value: u64) {\n        if let Some(gauge) = self.gauges.read().unwrap().get(name) {\n            gauge.store(value, Ordering::Relaxed);\n        }\n    }\n\n    /// Gets the current value of a counter\n    pub fn get_counter(\u0026self, name: \u0026str) -\u003e u64 {\n        self.counters\n            .read()\n            .unwrap()\n            .get(name)\n            .map(|c| c.load(Ordering::Relaxed))\n            .unwrap_or(0)\n    }\n\n    /// Gets the current value of a gauge\n    pub fn get_gauge(\u0026self, name: \u0026str) -\u003e u64 {\n        self.gauges\n            .read()\n            .unwrap()\n            .get(name)\n            .map(|g| g.load(Ordering::Relaxed))\n            .unwrap_or(0)\n    }\n}\n\n/// System-wide performance metrics snapshot\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SystemMetrics {\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Total number of events processed\n    pub total_events_processed: u64,\n    /// Current events processing rate per second\n    pub events_per_second: f64,\n    /// Memory usage in megabytes\n    pub memory_usage_mb: u64,\n    /// CPU usage as a percentage\n    pub cpu_usage_percent: f64,\n    /// Number of active connections\n    pub active_connections: u64,\n}\n\nimpl SystemMetrics {\n    /// Creates a new system metrics snapshot with default values\n    pub fn new() -\u003e Self {\n        Self {\n            uptime_seconds: 0,\n            total_events_processed: 0,\n            events_per_second: 0.0,\n            memory_usage_mb: 0,\n            cpu_usage_percent: 0.0,\n            active_connections: 0,\n        }\n    }\n}\n\nimpl Default for SystemMetrics {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_metrics_collector() {\n        let collector = MetricsCollector::new();\n\n        // Test counter operations\n        collector.increment_counter(\"test_counter\");\n        assert_eq!(collector.get_counter(\"test_counter\"), 0); // No counter registered\n\n        // Test gauge operations\n        collector.set_gauge(\"test_gauge\", 42);\n        assert_eq!(collector.get_gauge(\"test_gauge\"), 0); // No gauge registered\n\n        // Test non-existent metrics\n        assert_eq!(collector.get_counter(\"non_existent\"), 0);\n        assert_eq!(collector.get_gauge(\"non_existent\"), 0);\n    }\n\n    #[test]\n    fn test_system_metrics() {\n        let metrics = SystemMetrics::new();\n        assert_eq!(metrics.uptime_seconds, 0);\n        assert_eq!(metrics.total_events_processed, 0);\n        assert_eq!(metrics.events_per_second, 0.0);\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":2}},{"line":24,"address":[],"length":0,"stats":{"Line":4}},{"line":30,"address":[],"length":0,"stats":{"Line":2}},{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":52,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":18},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","exporter.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse tokio::time::{Duration, Instant};\n\n/// Metrics exporter for external monitoring systems\n#[derive(Debug, Clone)]\npub struct MetricsExporter {\n    start_time: Instant,\n    export_interval: Duration,\n}\n\nimpl MetricsExporter {\n    /// Creates a new metrics exporter with specified export interval\n    pub fn new(export_interval: Duration) -\u003e Self {\n        Self {\n            start_time: Instant::now(),\n            export_interval,\n        }\n    }\n\n    /// Returns the uptime since exporter creation\n    pub fn uptime(\u0026self) -\u003e Duration {\n        self.start_time.elapsed()\n    }\n\n    /// Returns the configured export interval\n    pub fn export_interval(\u0026self) -\u003e Duration {\n        self.export_interval\n    }\n\n    /// Export metrics in Prometheus format\n    pub fn export_prometheus(\u0026self, metrics: \u0026HashMap\u003cString, f64\u003e) -\u003e String {\n        let mut output = String::new();\n\n        for (name, value) in metrics {\n            output.push_str(\u0026format!(\"# TYPE {} gauge\\n\", name));\n            output.push_str(\u0026format!(\"{} {}\\n\", name, value));\n        }\n\n        output\n    }\n\n    /// Export metrics in JSON format\n    pub fn export_json(\u0026self, metrics: \u0026HashMap\u003cString, f64\u003e) -\u003e Result\u003cString, serde_json::Error\u003e {\n        let export_data = MetricsExport {\n            timestamp: chrono::Utc::now(),\n            uptime_seconds: self.uptime().as_secs(),\n            metrics: metrics.clone(),\n        };\n\n        serde_json::to_string_pretty(\u0026export_data)\n    }\n}\n\nimpl Default for MetricsExporter {\n    fn default() -\u003e Self {\n        Self::new(Duration::from_secs(60))\n    }\n}\n\n/// Metrics export data structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MetricsExport {\n    /// Timestamp when metrics were exported\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Map of metric names to values\n    pub metrics: HashMap\u003cString, f64\u003e,\n}\n\n/// Health status information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HealthStatus {\n    /// Overall system status\n    pub status: String,\n    /// System version\n    pub version: String,\n    /// System uptime in seconds\n    pub uptime_seconds: u64,\n    /// Timestamp of health check\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    /// Health status of individual components\n    pub components: HashMap\u003cString, ComponentHealth\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n/// Health status of an individual system component\npub struct ComponentHealth {\n    /// Component status (healthy/unhealthy)\n    pub status: String,\n    /// Timestamp of last health check\n    pub last_check: chrono::DateTime\u003cchrono::Utc\u003e,\n    /// Optional details about component status\n    pub details: Option\u003cString\u003e,\n}\n\nimpl HealthStatus {\n    /// Creates a new health status with the given version and uptime\n    pub fn new(version: \u0026str, uptime: Duration) -\u003e Self {\n        Self {\n            status: \"healthy\".to_string(),\n            version: version.to_string(),\n            uptime_seconds: uptime.as_secs(),\n            timestamp: chrono::Utc::now(),\n            components: HashMap::new(),\n        }\n    }\n\n    /// Adds a component health status\n    pub fn add_component(\u0026mut self, name: String, health: ComponentHealth) {\n        self.components.insert(name, health);\n    }\n\n    /// Returns true if all components are healthy\n    pub fn is_healthy(\u0026self) -\u003e bool {\n        self.status == \"healthy\" \u0026\u0026 self.components.values().all(|c| c.status == \"healthy\")\n    }\n}\n\nimpl ComponentHealth {\n    /// Creates a healthy component status\n    pub fn healthy() -\u003e Self {\n        Self {\n            status: \"healthy\".to_string(),\n            last_check: chrono::Utc::now(),\n            details: None,\n        }\n    }\n\n    /// Creates an unhealthy component status with details\n    pub fn unhealthy(details: String) -\u003e Self {\n        Self {\n            status: \"unhealthy\".to_string(),\n            last_check: chrono::Utc::now(),\n            details: Some(details),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_metrics_exporter() {\n        let exporter = MetricsExporter::new(Duration::from_secs(30));\n        assert_eq!(exporter.export_interval(), Duration::from_secs(30));\n        // Just verify uptime is available\n        let _uptime = exporter.uptime();\n    }\n\n    #[test]\n    fn test_prometheus_export() {\n        let exporter = MetricsExporter::default();\n        let mut metrics = HashMap::new();\n        metrics.insert(\"test_metric\".to_string(), 42.0);\n        metrics.insert(\"another_metric\".to_string(), std::f64::consts::PI);\n\n        let prometheus_output = exporter.export_prometheus(\u0026metrics);\n        assert!(prometheus_output.contains(\"# TYPE test_metric gauge\"));\n        assert!(prometheus_output.contains(\"test_metric 42\"));\n        assert!(prometheus_output.contains(\"another_metric 3.14\"));\n    }\n\n    #[test]\n    fn test_json_export() {\n        let exporter = MetricsExporter::default();\n        let mut metrics = HashMap::new();\n        metrics.insert(\"test_metric\".to_string(), 42.0);\n\n        let json_output = exporter.export_json(\u0026metrics).unwrap();\n        assert!(json_output.contains(\"test_metric\"));\n        assert!(json_output.contains(\"42\"));\n        assert!(json_output.contains(\"timestamp\"));\n        assert!(json_output.contains(\"uptime_seconds\"));\n    }\n\n    #[test]\n    fn test_health_status() {\n        let mut health = HealthStatus::new(\"1.0.0\", Duration::from_secs(3600));\n        assert_eq!(health.status, \"healthy\");\n        assert_eq!(health.version, \"1.0.0\");\n        assert_eq!(health.uptime_seconds, 3600);\n        assert!(health.is_healthy());\n\n        health.add_component(\"orderbook\".to_string(), ComponentHealth::healthy());\n        assert!(health.is_healthy());\n\n        health.add_component(\n            \"amm\".to_string(),\n            ComponentHealth::unhealthy(\"Connection lost\".to_string()),\n        );\n        assert!(!health.is_healthy());\n    }\n\n    #[test]\n    fn test_component_health() {\n        let healthy = ComponentHealth::healthy();\n        assert_eq!(healthy.status, \"healthy\");\n        assert!(healthy.details.is_none());\n\n        let unhealthy = ComponentHealth::unhealthy(\"Database connection failed\".to_string());\n        assert_eq!(unhealthy.status, \"unhealthy\");\n        assert_eq!(\n            unhealthy.details,\n            Some(\"Database connection failed\".to_string())\n        );\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":6}},{"line":16,"address":[],"length":0,"stats":{"Line":6}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":8}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":40,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":4}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":56,"address":[],"length":0,"stats":{"Line":4}},{"line":57,"address":[],"length":0,"stats":{"Line":8}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":102,"address":[],"length":0,"stats":{"Line":6}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":111,"address":[],"length":0,"stats":{"Line":4}},{"line":112,"address":[],"length":0,"stats":{"Line":16}},{"line":116,"address":[],"length":0,"stats":{"Line":6}},{"line":117,"address":[],"length":0,"stats":{"Line":28}},{"line":123,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":12}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":4}},{"line":134,"address":[],"length":0,"stats":{"Line":12}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":4}}],"covered":34,"coverable":34},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","metrics","mod.rs"],"content":"//! Metrics collection and export functionality\n//!\n//! This module provides comprehensive metrics collection, aggregation, and export capabilities\n//! for monitoring system performance and health.\n\n/// Metrics collection utilities\npub mod collector;\n/// Metrics export and health monitoring\npub mod exporter;\n\npub use collector::*;\npub use exporter::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","mod.rs"],"content":"//! Infrastructure layer providing data ingestion, metrics, and parsing capabilities\n//!\n//! This module contains the infrastructure components that support the domain layer,\n//! including stream ingestion, metrics collection, and data parsing utilities.\n\n/// Stream ingestion utilities for real-time market data\npub mod ingestion;\n/// Metrics collection and export functionality\npub mod metrics;\n/// Data parsing utilities for various market data formats\npub mod parsers;\n\npub use ingestion::*;\npub use parsers::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","parsers","json_parser.rs"],"content":"use crate::domain::{events::*, types::*};\nuse rust_decimal::Decimal;\nuse serde::Deserialize;\nuse std::collections::BTreeMap;\nuse std::str::FromStr;\n\n/// Raw JSON structures for parsing the provided data files\n/// Raw order book snapshot from JSON\n#[derive(Debug, Deserialize)]\nstruct RawOrderBookSnapshot {\n    #[serde(rename = \"type\")]\n    event_type: String,\n    symbol: String,\n    seq: u64,\n    ts: String,\n    bids: Vec\u003cVec\u003cString\u003e\u003e,\n    asks: Vec\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Raw order book delta from JSON\n#[derive(Debug, Deserialize)]\nstruct RawOrderBookDelta {\n    #[serde(rename = \"type\")]\n    event_type: String,\n    symbol: String,\n    seq: u64,\n    ts: String,\n    bids: Vec\u003cVec\u003cString\u003e\u003e,\n    asks: Vec\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Raw AMM pool from JSON\n#[derive(Debug, Deserialize)]\nstruct RawAMMPool {\n    pool: String,\n    fee: u32,\n    ts: String,\n    reserves: RawReserves,\n    #[serde(rename = \"sqrtPriceX96\")]\n    sqrt_price_x96: Option\u003cString\u003e,\n}\n\n/// Raw reserves from JSON\n#[derive(Debug, Deserialize)]\nstruct RawReserves {\n    amount0: String,\n    amount1: String,\n}\n\n/// Parse order book snapshot from JSON string\npub fn parse_lob_snapshot(json_str: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookSnapshot)\u003e {\n    let raw: RawOrderBookSnapshot = serde_json::from_str(json_str)?;\n\n    if raw.event_type != \"snapshot\" {\n        return Err(TradingError::ParseError(format!(\n            \"Expected snapshot type, got: {}\",\n            raw.event_type\n        )));\n    }\n\n    let symbol = Symbol(raw.symbol);\n    let sequence = SequenceNumber(raw.seq);\n    let timestamp = parse_timestamp(\u0026raw.ts)?;\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n\n    // Parse bids (price, quantity pairs)\n    for bid in raw.bids {\n        if bid.len() != 2 {\n            return Err(TradingError::ParseError(\"Invalid bid format\".to_string()));\n        }\n        let price = Price(\n            Decimal::from_str(\u0026bid[0])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid price: {}\", e)))?,\n        );\n        let quantity = Quantity(\n            Decimal::from_str(\u0026bid[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid quantity: {}\", e)))?,\n        );\n        bids.insert(price, quantity);\n    }\n\n    // Parse asks (price, quantity pairs)\n    for ask in raw.asks {\n        if ask.len() != 2 {\n            return Err(TradingError::ParseError(\"Invalid ask format\".to_string()));\n        }\n        let price = Price(\n            Decimal::from_str(\u0026ask[0])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask price: {}\", e)))?,\n        );\n        let quantity = Quantity(\n            Decimal::from_str(\u0026ask[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask quantity: {}\", e)))?,\n        );\n        asks.insert(price, quantity);\n    }\n\n    let snapshot = OrderBookSnapshot::with_levels(sequence, timestamp, bids, asks);\n    Ok((symbol, snapshot))\n}\n\n/// Parse order book delta from JSON string\npub fn parse_lob_delta(json_str: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookDelta)\u003e {\n    let raw: RawOrderBookDelta = serde_json::from_str(json_str)?;\n\n    if raw.event_type != \"delta\" {\n        return Err(TradingError::ParseError(format!(\n            \"Expected delta type, got: {}\",\n            raw.event_type\n        )));\n    }\n\n    let symbol = Symbol(raw.symbol);\n    let sequence = SequenceNumber(raw.seq);\n    let timestamp = parse_timestamp(\u0026raw.ts)?;\n\n    let mut updates = Vec::new();\n\n    // Parse bid updates (action, price, quantity)\n    for bid in raw.bids {\n        if bid.len() != 3 {\n            return Err(TradingError::ParseError(\n                \"Invalid bid delta format\".to_string(),\n            ));\n        }\n\n        let action = match bid[0].as_str() {\n            \"u\" =\u003e UpdateAction::Update,\n            \"d\" =\u003e UpdateAction::Delete,\n            \"n\" =\u003e UpdateAction::Update, // New level is same as update\n            _ =\u003e {\n                return Err(TradingError::ParseError(format!(\n                    \"Invalid bid action: {}\",\n                    bid[0]\n                )))\n            }\n        };\n\n        let price = Price(\n            Decimal::from_str(\u0026bid[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid bid price: {}\", e)))?,\n        );\n\n        let quantity =\n            if action == UpdateAction::Delete {\n                Quantity::zero()\n            } else {\n                Quantity(Decimal::from_str(\u0026bid[2]).map_err(|e| {\n                    TradingError::ParseError(format!(\"Invalid bid quantity: {}\", e))\n                })?)\n            };\n\n        updates.push(PriceLevelUpdate::new(Side::Bid, price, quantity, action));\n    }\n\n    // Parse ask updates (action, price, quantity)\n    for ask in raw.asks {\n        if ask.len() != 3 {\n            return Err(TradingError::ParseError(\n                \"Invalid ask delta format\".to_string(),\n            ));\n        }\n\n        let action = match ask[0].as_str() {\n            \"u\" =\u003e UpdateAction::Update,\n            \"d\" =\u003e UpdateAction::Delete,\n            \"n\" =\u003e UpdateAction::Update, // New level is same as update\n            _ =\u003e {\n                return Err(TradingError::ParseError(format!(\n                    \"Invalid ask action: {}\",\n                    ask[0]\n                )))\n            }\n        };\n\n        let price = Price(\n            Decimal::from_str(\u0026ask[1])\n                .map_err(|e| TradingError::ParseError(format!(\"Invalid ask price: {}\", e)))?,\n        );\n\n        let quantity =\n            if action == UpdateAction::Delete {\n                Quantity::zero()\n            } else {\n                Quantity(Decimal::from_str(\u0026ask[2]).map_err(|e| {\n                    TradingError::ParseError(format!(\"Invalid ask quantity: {}\", e))\n                })?)\n            };\n\n        updates.push(PriceLevelUpdate::new(Side::Ask, price, quantity, action));\n    }\n\n    let delta = OrderBookDelta::with_updates(sequence, timestamp, updates);\n    Ok((symbol, delta))\n}\n\n/// Parse AMM pool data from JSON string\npub fn parse_amm_pool(json_str: \u0026str) -\u003e TradingResult\u003c(PoolAddress, AMMPoolUpdate)\u003e {\n    let raw: RawAMMPool = serde_json::from_str(json_str)?;\n\n    let address = PoolAddress(raw.pool);\n    let timestamp = parse_timestamp(\u0026raw.ts)?;\n    let fee_tier = FeeTier(raw.fee);\n\n    let token0_reserve = Decimal::from_str(\u0026raw.reserves.amount0)\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid token0 reserve: {}\", e)))?;\n    let token1_reserve = Decimal::from_str(\u0026raw.reserves.amount1)\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid token1 reserve: {}\", e)))?;\n    let reserves = TokenReserves::new(token0_reserve, token1_reserve);\n\n    // Parse sqrt price if available\n    let sqrt_price = if let Some(sqrt_price_str) = raw.sqrt_price_x96 {\n        let sqrt_price_u128 = u128::from_str(\u0026sqrt_price_str)\n            .map_err(|e| TradingError::ParseError(format!(\"Invalid sqrtPriceX96: {}\", e)))?;\n        Some(SqrtPriceX96(sqrt_price_u128))\n    } else {\n        None\n    };\n\n    let update = AMMPoolUpdate::new(timestamp, reserves, sqrt_price, fee_tier);\n    Ok((address, update))\n}\n\n/// Parse timestamp from ISO 8601 string\nfn parse_timestamp(ts_str: \u0026str) -\u003e TradingResult\u003cTimestamp\u003e {\n    chrono::DateTime::parse_from_rfc3339(ts_str)\n        .map(|dt| dt.with_timezone(\u0026chrono::Utc))\n        .map_err(|e| TradingError::ParseError(format!(\"Invalid timestamp: {}\", e)))\n}\n\n/// Load and parse order book snapshot from file\npub fn load_lob_snapshot(file_path: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookSnapshot)\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_lob_snapshot(\u0026content)\n}\n\n/// Load and parse order book delta from file\npub fn load_lob_delta(file_path: \u0026str) -\u003e TradingResult\u003c(Symbol, OrderBookDelta)\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_lob_delta(\u0026content)\n}\n\n/// Load and parse AMM pool from file\npub fn load_amm_pool(file_path: \u0026str) -\u003e TradingResult\u003c(PoolAddress, AMMPoolUpdate)\u003e {\n    let content = std::fs::read_to_string(file_path)?;\n    parse_amm_pool(\u0026content)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_parse_lob_snapshot() {\n        let json = r#\"{\n            \"type\": \"snapshot\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1000,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"bids\": [\n                [\"2445.12\", \"3.1005\"],\n                [\"2445.11\", \"1.20\"]\n            ],\n            \"asks\": [\n                [\"2445.13\", \"2.05\"],\n                [\"2445.14\", \"1.50\"]\n            ]\n        }\"#;\n\n        let (symbol, snapshot) = parse_lob_snapshot(json).unwrap();\n\n        assert_eq!(symbol, Symbol(\"ETHUSDC\".to_string()));\n        assert_eq!(snapshot.sequence, SequenceNumber(1000));\n        assert_eq!(snapshot.bids.len(), 2);\n        assert_eq!(snapshot.asks.len(), 2);\n\n        // Check best bid and ask\n        assert_eq!(snapshot.best_bid(), Some(\u0026Price(dec!(2445.12))));\n        assert_eq!(snapshot.best_ask(), Some(\u0026Price(dec!(2445.13))));\n    }\n\n    #[test]\n    fn test_parse_lob_delta() {\n        let json = r#\"{\n            \"type\": \"delta\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1001,\n            \"ts\": \"2025-01-01T10:00:00.050Z\",\n            \"bids\": [\n                [\"u\", \"2445.12\", \"3.0000\"]\n            ],\n            \"asks\": [\n                [\"n\", \"2445.15\", \"1.00\"]\n            ]\n        }\"#;\n\n        let (symbol, delta) = parse_lob_delta(json).unwrap();\n\n        assert_eq!(symbol, Symbol(\"ETHUSDC\".to_string()));\n        assert_eq!(delta.sequence, SequenceNumber(1001));\n        assert_eq!(delta.updates.len(), 2);\n\n        // Check updates\n        let bid_update = \u0026delta.updates[0];\n        assert_eq!(bid_update.side, Side::Bid);\n        assert_eq!(bid_update.price, Price(dec!(2445.12)));\n        assert_eq!(bid_update.quantity, Quantity(dec!(3.0000)));\n        assert_eq!(bid_update.action, UpdateAction::Update);\n\n        let ask_update = \u0026delta.updates[1];\n        assert_eq!(ask_update.side, Side::Ask);\n        assert_eq!(ask_update.price, Price(dec!(2445.15)));\n        assert_eq!(ask_update.quantity, Quantity(dec!(1.00)));\n        assert_eq!(ask_update.action, UpdateAction::Update);\n    }\n\n    #[test]\n    fn test_parse_amm_pool() {\n        let json = r#\"{\n            \"pool\": \"0xPOOL\",\n            \"venue\": \"uniswap_v3\",\n            \"pair\": \"WETH/USDC\",\n            \"fee\": 5,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"reserves\": {\n                \"token0\": \"WETH\",\n                \"token1\": \"USDC\",\n                \"amount0\": \"1000.0000\",\n                \"amount1\": \"2445000.00\"\n            },\n            \"sqrtPriceX96\": \"79228162514264337593543950336\"\n        }\"#;\n\n        let (address, update) = parse_amm_pool(json).unwrap();\n\n        assert_eq!(address, PoolAddress(\"0xPOOL\".to_string()));\n        assert_eq!(update.fee_tier, FeeTier(5));\n        assert_eq!(update.reserves.token0, dec!(1000.0000));\n        assert_eq!(update.reserves.token1, dec!(2445000.00));\n        assert!(update.sqrt_price.is_some());\n\n        // Check implied price from reserves\n        let implied_price = update.implied_mid_from_reserves();\n        assert_eq!(implied_price, Price(dec!(2445.0))); // 2445000 / 1000\n    }\n\n    #[test]\n    fn test_parse_delta_delete_action() {\n        let json = r#\"{\n            \"type\": \"delta\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1002,\n            \"ts\": \"2025-01-01T10:00:00.100Z\",\n            \"bids\": [\n                [\"d\", \"2445.11\", \"0\"]\n            ],\n            \"asks\": []\n        }\"#;\n\n        let (_, delta) = parse_lob_delta(json).unwrap();\n\n        assert_eq!(delta.updates.len(), 1);\n        let update = \u0026delta.updates[0];\n        assert_eq!(update.action, UpdateAction::Delete);\n        assert!(update.quantity.is_zero());\n    }\n\n    #[test]\n    fn test_invalid_json_format() {\n        let json = r#\"{\"invalid\": \"format\"}\"#;\n        let result = parse_lob_snapshot(json);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_invalid_decimal_parsing() {\n        let json = r#\"{\n            \"type\": \"snapshot\",\n            \"venue\": \"binance\",\n            \"symbol\": \"ETHUSDC\",\n            \"seq\": 1000,\n            \"ts\": \"2025-01-01T10:00:00.000Z\",\n            \"bids\": [\n                [\"invalid_price\", \"3.1005\"]\n            ],\n            \"asks\": []\n        }\"#;\n\n        let result = parse_lob_snapshot(json);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Invalid bid price\"));\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":24}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":24}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":106,"address":[],"length":0,"stats":{"Line":18}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":18}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":4}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":4}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":14}},{"line":160,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":4}},{"line":169,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":6}},{"line":200,"address":[],"length":0,"stats":{"Line":4}},{"line":201,"address":[],"length":0,"stats":{"Line":12}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":8}},{"line":215,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":16}},{"line":228,"address":[],"length":0,"stats":{"Line":32}},{"line":229,"address":[],"length":0,"stats":{"Line":64}},{"line":230,"address":[],"length":0,"stats":{"Line":16}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":6}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":6}}],"covered":45,"coverable":77},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","infrastructure","parsers","mod.rs"],"content":"//! JSON parsing utilities for market data\n//!\n//! This module provides parsers for converting JSON market data into domain types.\n\n/// JSON parser for market data formats\npub mod json_parser;\n\npub use json_parser::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","lib.rs"],"content":"//! # Quant Trading System\n//!\n//! A high-performance, thread-safe quantitative trading system implementing:\n//! - CLOB (Central Limit Order Book) L2 order books with fast top-of-book access\n//! - AMM (Automated Market Maker) pools with price impact calculations\n//! - Real-time arbitrage detection between venues\n//! - Concurrent stream ingestion with backpressure handling\n//! - JSON parsing for market data feeds\n//!\n//! ## Architecture\n//!\n//! The system follows domain-driven design principles with clear separation of concerns:\n//!\n//! - **Domain**: Core business logic (order books, AMM pools, arbitrage detection)\n//! - **Infrastructure**: External concerns (JSON parsing, stream ingestion, metrics)\n//! - **Application**: Use cases and orchestration\n//!\n//! ## Thread Safety\n//!\n//! All data structures use `std::sync::RwLock` for concurrent access:\n//! - Multiple concurrent readers\n//! - Single writer exclusion\n//! - Atomic snapshots without blocking writers\n//!\n//! ## Performance Characteristics\n//!\n//! - **Latency**: Sub-microsecond order book operations\n//! - **Throughput**: 1M+ updates/second per symbol\n//! - **Memory**: O(n) where n = number of price levels\n//! - **Concurrency**: Lock-free reads, minimal write contention\n\npub mod domain;\npub mod infrastructure;\n\n/// Utilities for logging and metrics reporting\npub mod utils;\n\n// Re-export commonly used types for convenience\npub use domain::{\n    amm_pool::{AMMPool, AMMPoolType, PriceImpactResult, ThreadSafeAMMPool, TokenIndex},\n    arbitrage::{ArbitrageDetector, ArbitrageOpportunity, Venue},\n    events::*,\n    market_data::{MarketDataManager, MarketMetrics},\n    order_book::{OrderBookL2, ThreadSafeOrderBook},\n    types::*,\n};\n\npub use infrastructure::{\n    ingestion::{IngestionStats, MultiStreamIngester, StatisticalStreamIngester, StreamIngester},\n    parsers::{\n        load_amm_pool, load_lob_delta, load_lob_snapshot, parse_amm_pool, parse_lob_delta,\n        parse_lob_snapshot,\n    },\n};\n\n/// Main result type for the trading system\npub type Result\u003cT\u003e = std::result::Result\u003cT, TradingError\u003e;\n\n/// Version information\npub const VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg(test)]\nmod integration_tests {\n    use super::*;\n    use rust_decimal_macros::dec;\n    use std::sync::Arc;\n    use tokio::sync::mpsc;\n\n    #[tokio::test]\n    async fn test_full_system_integration() {\n        // Initialize logging for tests\n        let _ = tracing_subscriber::fmt::try_init();\n\n        // Create market data manager\n        let manager = Arc::new(MarketDataManager::new());\n\n        // Create stream ingester\n        let (tx, rx) = mpsc::channel(1000);\n        let mut ingester = StreamIngester::new(rx, manager.clone());\n\n        // Load and send initial data\n        let snapshot_result = load_lob_snapshot(\"data/LOB_snapshot.json\");\n        if let Ok((symbol, snapshot)) = snapshot_result {\n            let event = MarketEvent::OrderBookSnapshot(symbol.clone(), snapshot);\n            tx.send(event).await.unwrap();\n        }\n\n        let delta_result = load_lob_delta(\"data/LOB_delta.json\");\n        if let Ok((symbol, delta)) = delta_result {\n            let event = MarketEvent::OrderBookDelta(symbol, delta);\n            tx.send(event).await.unwrap();\n        }\n\n        let amm_result = load_amm_pool(\"data/amm_pool.json\");\n        if let Ok((address, update)) = amm_result {\n            let event = MarketEvent::AMMUpdate(address, update);\n            tx.send(event).await.unwrap();\n        }\n\n        // Close sender\n        drop(tx);\n\n        // Run ingester\n        tokio::spawn(async move {\n            ingester.run().await;\n        });\n\n        // Give some time for processing\n        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n\n        // Test arbitrage detection if we have both order book and AMM data\n        let symbols = manager.get_orderbook_symbols();\n        let pools = manager.get_amm_pool_addresses();\n\n        if !symbols.is_empty() \u0026\u0026 !pools.is_empty() {\n            let detector = ArbitrageDetector::new(10); // 0.1% minimum profit\n\n            if let (Some(book), Some(pool)) = (\n                manager.get_orderbook(\u0026symbols[0]),\n                manager.get_amm_pool(\u0026pools[0]),\n            ) {\n                let opportunity = detector.check_arbitrage(\u0026book, \u0026pool);\n                // Arbitrage opportunity may or may not exist depending on the data\n                println!(\"Arbitrage opportunity: {:?}\", opportunity);\n            }\n        }\n\n        // Get final metrics\n        let metrics = manager.get_market_metrics();\n        println!(\n            \"Final metrics: {} order books, {} AMM pools\",\n            metrics.orderbook_metrics.len(),\n            metrics.amm_metrics.len()\n        );\n    }\n\n    #[test]\n    fn test_order_book_operations() {\n        let book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n        // Create test snapshot\n        let mut snapshot = OrderBookSnapshot::new(SequenceNumber(1), chrono::Utc::now());\n        snapshot\n            .bids\n            .insert(Price(dec!(2445.12)), Quantity(dec!(3.1005)));\n        snapshot\n            .bids\n            .insert(Price(dec!(2445.11)), Quantity(dec!(1.20)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2445.13)), Quantity(dec!(2.05)));\n        snapshot\n            .asks\n            .insert(Price(dec!(2445.14)), Quantity(dec!(1.50)));\n\n        // Apply snapshot\n        book.apply_snapshot(snapshot).unwrap();\n\n        // Test basic operations\n        assert_eq!(book.best_bid(), Some(Price(dec!(2445.12))));\n        assert_eq!(book.best_ask(), Some(Price(dec!(2445.13))));\n        assert_eq!(book.mid_price(), Some(Price(dec!(2445.125))));\n        assert_eq!(book.spread(), Some(Price(dec!(0.01))));\n\n        // Test depth calculation\n        let bid_depth = book.depth_to_price(Side::Bid, Price(dec!(2445.11)));\n        assert_eq!(bid_depth, Quantity(dec!(4.3005))); // 3.1005 + 1.20\n    }\n\n    #[test]\n    fn test_amm_pool_operations() {\n        let reserves = TokenReserves::new(dec!(1000.0), dec!(2445000.0));\n        let pool = ThreadSafeAMMPool::new_v2(\n            PoolAddress(\"0xTEST\".to_string()),\n            reserves,\n            FeeTier(30), // 0.3%\n        );\n\n        // Test basic operations\n        assert_eq!(pool.implied_mid(), Price(dec!(2445.0)));\n        assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n\n        // Test price impact calculation\n        let result = pool\n            .calculate_price_impact(TokenIndex::Token0, dec!(10.0))\n            .unwrap();\n\n        // Should have some price impact and fee\n        assert!(result.price_impact_percent \u003e dec!(0.0));\n        assert_eq!(result.fee_amount, dec!(0.03)); // 0.3% of 10.0\n        assert!(result.output_amount \u003e dec!(0.0));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","main.rs"],"content":"//! # Quant Trading System\n//!\n//! A high-performance quantitative trading system with real-time market data processing,\n//! order book management, AMM pool integration, and arbitrage detection.\n//!\n//! This binary provides an example entry point that demonstrates the full system capabilities\n//! including market data ingestion, real-time processing, arbitrage monitoring, and metrics API.\n\nuse quant_trading_system::utils::logger::setup_logger;\nuse quant_trading_system::*;\nuse rust_decimal_macros::dec;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tracing::error;\nuse tracing::log::info;\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    // Initialize tracing/logging\n    info!(\"Initializing tracing subscriber...\");\n    setup_logger().expect(\"Failed to initialize logger\");\n    info!(\"Tracing subscriber initialized\");\n\n    info!(\"Starting Quant Trading System v{}\", VERSION);\n    info!(\"Initializing system components...\");\n\n    // Create the market data manager\n    info!(\"Creating market data manager...\");\n    let manager = Arc::new(MarketDataManager::new());\n    info!(\"Market data manager created successfully\");\n\n    // Create channels for different data streams\n    info!(\"Setting up communication channels...\");\n    let (market_tx, market_rx) = mpsc::channel::\u003cMarketEvent\u003e(1000);\n    info!(\"Channels created with buffer size 1000\");\n\n    // Start the stream ingester FIRST\n    info!(\"Starting stream ingester task...\");\n    let manager_clone = Arc::clone(\u0026manager);\n    let _ingester_handle = tokio::spawn(async move {\n        info!(\"Stream ingester task started\");\n        let mut ingester = StreamIngester::new(market_rx, manager_clone);\n        info!(\"Running stream ingester...\");\n        ingester.run().await;\n    });\n    info!(\"Stream ingester task spawned\");\n\n    // Load initial data from JSON files\n    info!(\"Loading initial market data from JSON files...\");\n    load_initial_data(\u0026market_tx).await?;\n    info!(\"Initial market data loaded successfully\");\n\n    // Give some time for events to be processed\n    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n    info!(\"Events processed, continuing with setup...\");\n\n    // Start real-time simulation (simulated here with periodic updates)\n    info!(\"Starting real-time simulation task...\");\n    let market_tx_clone = market_tx.clone();\n    tokio::spawn(async move {\n        info!(\"Real-time simulation task started\");\n        simulate_real_time_updates(market_tx_clone).await;\n    });\n    info!(\"Real-time simulation task spawned\");\n\n    // Start arbitrage monitoring\n    info!(\"Starting arbitrage monitoring task...\");\n    let manager_clone = Arc::clone(\u0026manager);\n    tokio::spawn(async move {\n        info!(\"Arbitrage monitoring task started\");\n        monitor_arbitrage(manager_clone).await;\n    });\n    info!(\"Arbitrage monitoring task spawned\");\n\n    // Start metrics API server\n    info!(\"Starting metrics API server...\");\n    expose_metrics_api(manager).await;\n    info!(\"Metrics API server started\");\n\n    Ok(())\n}\n\nasync fn load_initial_data(tx: \u0026mpsc::Sender\u003cMarketEvent\u003e) -\u003e anyhow::Result\u003c()\u003e {\n    info!(\"Loading order book snapshot from data/LOB_snapshot.json...\");\n\n    // Load snapshot from file\n    match load_lob_snapshot(\"data/LOB_snapshot.json\") {\n        Ok((symbol, snapshot)) =\u003e {\n            info!(\"Loaded snapshot for symbol: {}\", symbol);\n            tx.send(MarketEvent::OrderBookSnapshot(symbol, snapshot))\n                .await?;\n        }\n        Err(e) =\u003e {\n            error!(\"Failed to load order book snapshot: {}\", e);\n        }\n    }\n\n    // Load delta updates\n    info!(\"Loading order book delta from data/LOB_delta.json...\");\n    match load_lob_delta(\"data/LOB_delta.json\") {\n        Ok((symbol, delta)) =\u003e {\n            info!(\n                \"Loaded delta for symbol: {}, seq: {}\",\n                symbol, delta.sequence\n            );\n            tx.send(MarketEvent::OrderBookDelta(symbol, delta)).await?;\n        }\n        Err(e) =\u003e {\n            error!(\"Failed to load order book delta: {}\", e);\n        }\n    }\n\n    // Load AMM pool state\n    info!(\"Loading AMM pool data from data/amm_pool.json...\");\n    match load_amm_pool(\"data/amm_pool.json\") {\n        Ok((address, update)) =\u003e {\n            info!(\"Loaded AMM pool for address: {}\", address);\n            tx.send(MarketEvent::AMMUpdate(address, update)).await?;\n        }\n        Err(e) =\u003e {\n            error!(\"Failed to load AMM pool: {}\", e);\n        }\n    }\n\n    info!(\"Initial data loading completed\");\n    Ok(())\n}\n\nasync fn simulate_real_time_updates(tx: mpsc::Sender\u003cMarketEvent\u003e) {\n    info!(\"Starting real-time market data simulation...\");\n\n    let mut interval = tokio::time::interval(tokio::time::Duration::from_millis(100));\n    let mut seq = 1001u64;\n\n    loop {\n        interval.tick().await;\n\n        // Simulate order book updates\n        let delta = OrderBookDelta::with_updates(\n            SequenceNumber(seq),\n            chrono::Utc::now(),\n            vec![\n                PriceLevelUpdate::update(\n                    Side::Bid,\n                    Price(dec!(2445) + rust_decimal::Decimal::from(seq % 10)),\n                    Quantity(dec!(1) + rust_decimal::Decimal::from(seq % 5)),\n                ),\n                PriceLevelUpdate::update(\n                    Side::Ask,\n                    Price(dec!(2446) + rust_decimal::Decimal::from(seq % 10)),\n                    Quantity(dec!(1) + rust_decimal::Decimal::from(seq % 3)),\n                ),\n            ],\n        );\n\n        if tx\n            .send(MarketEvent::OrderBookDelta(\n                Symbol(\"ETHUSDC\".to_string()),\n                delta,\n            ))\n            .await\n            .is_err()\n        {\n            break; // Channel closed\n        }\n\n        // Occasionally simulate AMM pool updates\n        if seq % 50 == 0 {\n            let new_reserves = TokenReserves::new(\n                dec!(1000) + rust_decimal::Decimal::from(seq % 100),\n                dec!(2445000) + rust_decimal::Decimal::from(seq % 10000),\n            );\n\n            let amm_update =\n                AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n            if tx\n                .send(MarketEvent::AMMUpdate(\n                    PoolAddress(\"0xPOOL\".to_string()),\n                    amm_update,\n                ))\n                .await\n                .is_err()\n            {\n                break;\n            }\n        }\n\n        seq += 1;\n\n        // Stop after some time for demo purposes\n        if seq \u003e 2000 {\n            info!(\"Simulation completed after {} updates\", seq - 1001);\n            break;\n        }\n    }\n}\n\nasync fn monitor_arbitrage(manager: Arc\u003cMarketDataManager\u003e) {\n    info!(\"Starting arbitrage monitoring loop...\");\n\n    let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(1));\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    loop {\n        interval.tick().await;\n\n        // Get all order books and AMM pools\n        let symbols = manager.get_orderbook_symbols();\n        let addresses = manager.get_amm_pool_addresses();\n\n        // Check each combination for arbitrage\n        for symbol in \u0026symbols {\n            if let Some(book) = manager.get_orderbook(symbol) {\n                for address in \u0026addresses {\n                    if let Some(pool) = manager.get_amm_pool(address) {\n                        if let Some(opportunity) = detector.check_arbitrage(\u0026book, \u0026pool) {\n                            info!(\n                                \"ARBITRAGE DETECTED! Buy {} @ {:.2}, Sell {} @ {:.2}, Profit: {:.2}%, Max Qty: {}\",\n                                opportunity.buy_venue,\n                                opportunity.buy_price,\n                                opportunity.sell_venue,\n                                opportunity.sell_price,\n                                opportunity.profit_percent,\n                                opportunity.max_quantity\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nasync fn expose_metrics_api(manager: Arc\u003cMarketDataManager\u003e) {\n    info!(\"Starting metrics API server on port 3030...\");\n    info!(\"Setting up API routes...\");\n\n    use warp::Filter;\n\n    let manager = warp::any().map(move || Arc::clone(\u0026manager));\n\n    // Metrics endpoint\n    let metrics = warp::path(\"metrics\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc\u003cMarketDataManager\u003e| {\n            let metrics = mgr.get_market_metrics();\n            warp::reply::json(\u0026metrics)\n        });\n\n    // Health check endpoint\n    let _health = warp::path(\"health\").and(warp::get()).map(|| {\n        warp::reply::json(\u0026serde_json::json!({\n            \"status\": \"healthy\",\n            \"version\": VERSION,\n            \"timestamp\": chrono::Utc::now()\n        }))\n    });\n\n    // Order book endpoint\n    let orderbooks = warp::path(\"orderbooks\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc\u003cMarketDataManager\u003e| {\n            let symbols = mgr.get_orderbook_symbols();\n            let mut books = std::collections::HashMap::new();\n\n            for symbol in symbols {\n                if let Some(book) = mgr.get_orderbook(\u0026symbol) {\n                    books.insert(\n                        symbol.to_string(),\n                        serde_json::json!({\n                            \"symbol\": symbol,\n                            \"best_bid\": book.best_bid(),\n                            \"best_ask\": book.best_ask(),\n                            \"mid_price\": book.mid_price(),\n                            \"spread\": book.spread(),\n                            \"last_update\": book.last_update()\n                        }),\n                    );\n                }\n            }\n\n            warp::reply::json(\u0026books)\n        });\n\n    // AMM pools endpoint\n    let pools = warp::path(\"pools\")\n        .and(warp::get())\n        .and(manager.clone())\n        .map(|mgr: Arc\u003cMarketDataManager\u003e| {\n            let addresses = mgr.get_amm_pool_addresses();\n            let mut pool_data = std::collections::HashMap::new();\n\n            for address in addresses {\n                if let Some(pool) = mgr.get_amm_pool(\u0026address) {\n                    pool_data.insert(\n                        address.to_string(),\n                        serde_json::json!({\n                            \"address\": address,\n                            \"pool_type\": pool.pool_type(),\n                            \"implied_mid\": pool.implied_mid(),\n                            \"reserves\": pool.get_reserves(),\n                            \"fee_tier\": pool.get_fee_tier(),\n                            \"last_update\": pool.last_update()\n                        }),\n                    );\n                }\n            }\n\n            warp::reply::json(\u0026pool_data)\n        });\n\n    let routes = metrics\n        .or(orderbooks)\n        .or(pools)\n        .with(warp::cors().allow_any_origin());\n\n    info!(\"API routes configured successfully\");\n    info!(\"API server ready at http://localhost:3030\");\n    info!(\"Available endpoints:\");\n    info!(\"  GET /metrics - System metrics\");\n    info!(\"  GET /orderbooks - Order book data\");\n    info!(\"  GET /pools - AMM pool data\");\n    info!(\"Server starting on 127.0.0.1:3030...\");\n\n    warp::serve(routes).run(([127, 0, 0, 1], 3030)).await;\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":181},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","utils","logger.rs"],"content":"use std::env;\nuse std::sync::Once;\nuse tracing::Level;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\nstatic INIT: Once = Once::new();\n\n/// Sets up the logger with optional OpenTelemetry integration\n///\n/// Environment variables:\n/// - LOGLEVEL: Sets the log level (DEBUG, INFO, WARN, ERROR, TRACE)\n/// - ENABLE_TRACING: Enable OpenTelemetry tracing (true/false) - requires the \"opentelemetry\" feature\n/// - TRACING_ENDPOINT: OpenTelemetry endpoint (default: http://localhost:4317)\n/// - SERVICE_NAME: Service name for tracing (default: rust-app)\npub fn setup_logger() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    INIT.call_once(|| {\n        let log_level = env::var(\"LOGLEVEL\")\n            .unwrap_or_else(|_| \"INFO\".to_string())\n            .to_uppercase();\n\n        let level = match log_level.as_str() {\n            \"DEBUG\" =\u003e Level::DEBUG,\n            \"ERROR\" =\u003e Level::ERROR,\n            \"WARN\" =\u003e Level::WARN,\n            \"TRACE\" =\u003e Level::TRACE,\n            _ =\u003e Level::INFO,\n        };\n\n        let enable_tracing =\n            env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n\n        // Create the registry with fmt layer\n        let registry = tracing_subscriber::registry()\n            .with(\n                tracing_subscriber::fmt::layer()\n                    .with_target(false)\n                    .with_thread_ids(true),\n            )\n            .with(tracing_subscriber::EnvFilter::from_default_env().add_directive(level.into()));\n\n        {\n            registry.init();\n            if enable_tracing {\n                tracing::warn!(\"OpenTelemetry tracing requested but feature not enabled\");\n                tracing::warn!(\"Add the 'opentelemetry' feature to your Cargo.toml to enable it\");\n            }\n        }\n\n        tracing::debug!(\"Log level set to: {}\", level);\n    });\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::Mutex;\n\n    // Mutex to ensure tests run sequentially since they modify global state\n    static TEST_MUTEX: Mutex\u003c()\u003e = Mutex::new(());\n\n    /// Helper function to reset the Once static for testing\n    /// Note: This is a workaround since Once cannot be reset in standard library\n    fn with_clean_env\u003cF\u003e(env_vars: Vec\u003c(\u0026str, \u0026str)\u003e, test_fn: F)\n    where\n        F: FnOnce(),\n    {\n        let _guard = TEST_MUTEX.lock().unwrap();\n\n        // Store original values\n        let original_values: Vec\u003c_\u003e = env_vars\n            .iter()\n            .map(|(key, _)| (*key, env::var(key).ok()))\n            .collect();\n\n        // Set test values\n        for (key, value) in \u0026env_vars {\n            env::set_var(key, value);\n        }\n\n        // Run test\n        test_fn();\n\n        // Restore original values\n        for (key, original_value) in original_values {\n            match original_value {\n                Some(value) =\u003e env::set_var(key, value),\n                None =\u003e env::remove_var(key),\n            }\n        }\n    }\n    #[test]\n    fn test_log_level_parsing_debug() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"DEBUG\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::DEBUG);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_info() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"INFO\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::INFO);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_warn() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"WARN\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::WARN);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_error() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"ERROR\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::ERROR);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_trace() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"TRACE\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::TRACE);\n        });\n    }\n\n    #[test]\n    fn test_log_level_parsing_invalid_defaults_to_info() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"INVALID\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::INFO);\n        });\n    }\n\n    #[test]\n    fn test_log_level_case_insensitive() {\n        with_clean_env(vec![(\"LOGLEVEL\", \"debug\")], || {\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::DEBUG);\n        });\n    }\n\n    #[test]\n    fn test_default_log_level_when_env_not_set() {\n        with_clean_env(vec![], || {\n            env::remove_var(\"LOGLEVEL\");\n            let log_level = env::var(\"LOGLEVEL\")\n                .unwrap_or_else(|_| \"INFO\".to_string())\n                .to_uppercase();\n            let level = match log_level.as_str() {\n                \"DEBUG\" =\u003e Level::DEBUG,\n                \"ERROR\" =\u003e Level::ERROR,\n                \"WARN\" =\u003e Level::WARN,\n                \"TRACE\" =\u003e Level::TRACE,\n                _ =\u003e Level::INFO,\n            };\n            assert_eq!(level, Level::INFO);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_true() {\n        with_clean_env(vec![(\"ENABLE_TRACING\", \"true\")], || {\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(enable_tracing);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_false() {\n        with_clean_env(vec![(\"ENABLE_TRACING\", \"false\")], || {\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(!enable_tracing);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_default_false() {\n        with_clean_env(vec![], || {\n            env::remove_var(\"ENABLE_TRACING\");\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(!enable_tracing);\n        });\n    }\n\n    #[test]\n    fn test_enable_tracing_case_sensitive() {\n        with_clean_env(vec![(\"ENABLE_TRACING\", \"TRUE\")], || {\n            let enable_tracing =\n                env::var(\"ENABLE_TRACING\").unwrap_or_else(|_| \"false\".to_string()) == \"true\";\n            assert!(!enable_tracing); // Should be false because it's case-sensitive\n        });\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","src","utils","mod.rs"],"content":"/// Logging utilities\npub mod logger;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","amm_tests.rs"],"content":"use quant_trading_system::domain::{amm_pool::*, types::*};\nuse quant_trading_system::AMMPoolUpdate;\nuse rust_decimal_macros::dec;\n\n#[test]\nfn test_amm_pool_v2_creation() {\n    let address = PoolAddress(\"0x123\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address.clone(), reserves, fee_tier);\n\n    assert_eq!(pool.get_address(), address);\n    assert_eq!(pool.get_reserves().token0, dec!(1000.0));\n    assert_eq!(pool.get_reserves().token1, dec!(2000.0));\n    assert_eq!(pool.get_fee_tier(), fee_tier);\n    assert_eq!(pool.pool_type(), AMMPoolType::ConstantProduct);\n}\n\n#[test]\nfn test_amm_pool_v3_creation() {\n    let address = PoolAddress(\"0x456\".to_string());\n    let reserves = TokenReserves::new(dec!(500.0), dec!(1500.0));\n    let sqrt_price = SqrtPriceX96(2u128.pow(96) * 2); // sqrt(4) * 2^96\n    let fee_tier = FeeTier(5);\n\n    let pool = ThreadSafeAMMPool::new_v3(address.clone(), reserves, sqrt_price, fee_tier);\n\n    assert_eq!(pool.get_address(), address);\n    assert_eq!(pool.pool_type(), AMMPoolType::ConcentratedLiquidity);\n}\n\n#[test]\nfn test_implied_mid_price_v2() {\n    let address = PoolAddress(\"0x789\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n    let mid_price = pool.implied_mid();\n\n    // Price should be token1/token0 = 2000/1000 = 2.0\n    assert_eq!(mid_price, Price(dec!(2.0)));\n}\n\n#[test]\nfn test_implied_mid_price_v3_with_sqrt_price() {\n    let address = PoolAddress(\"0xABC\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let sqrt_price = SqrtPriceX96(2u128.pow(96)); // sqrt(1) * 2^96 = price of 1\n    let fee_tier = FeeTier(5);\n\n    let pool = ThreadSafeAMMPool::new_v3(address, reserves, sqrt_price, fee_tier);\n    let mid_price = pool.implied_mid();\n\n    // Should use sqrt_price, not reserves\n    assert!((mid_price.0 - dec!(1.0)).abs() \u003c dec!(0.1));\n}\n\n#[test]\nfn test_price_impact_calculation() {\n    let address = PoolAddress(\"0xDEF\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n\n    // Test small trade impact\n    let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(10.0));\n    assert!(result.is_ok());\n\n    let impact = result.unwrap();\n    assert!(impact.output_amount \u003e dec!(0.0));\n    assert!(impact.price_impact_percent \u003e= dec!(0.0));\n    assert!(impact.fee_amount \u003e dec!(0.0));\n}\n\n#[test]\nfn test_amm_pool_state_update() {\n    let address = PoolAddress(\"0x111\".to_string());\n    let initial_reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, initial_reserves, fee_tier);\n\n    // Update reserves\n    let new_reserves = TokenReserves::new(dec!(1100.0), dec!(1900.0));\n    let update = AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, fee_tier);\n\n    let result = pool.update_state(update);\n    assert!(result.is_ok());\n\n    // Verify updated state\n    assert_eq!(pool.get_reserves().token0, dec!(1100.0));\n    assert_eq!(pool.get_reserves().token1, dec!(1900.0));\n}\n\n#[test]\nfn test_zero_reserves_handling() {\n    let address = PoolAddress(\"0x222\".to_string());\n    let reserves = TokenReserves::new(dec!(0.0), dec!(1000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n    let mid_price = pool.implied_mid();\n\n    // Should return zero price when token0 reserve is zero\n    assert_eq!(mid_price, Price::zero());\n}\n\n#[test]\nfn test_large_trade_price_impact() {\n    let address = PoolAddress(\"0x333\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let fee_tier = FeeTier(30);\n\n    let pool = ThreadSafeAMMPool::new_v2(address, reserves, fee_tier);\n\n    // Test large trade (50% of pool)\n    let result = pool.calculate_price_impact(TokenIndex::Token0, dec!(500.0));\n    assert!(result.is_ok());\n\n    let impact = result.unwrap();\n    // Large trades should have significant price impact\n    assert!(impact.price_impact_percent \u003e dec!(10.0));\n}\n\n#[test]\nfn test_fee_tier_conversion() {\n    let fee_30 = FeeTier(30); // 30 basis points = 0.3%\n    assert_eq!(fee_30.to_decimal(), dec!(0.003));\n\n    let fee_5 = FeeTier(5); // 5 basis points = 0.05%\n    assert_eq!(fee_5.to_decimal(), dec!(0.0005));\n}\n\n#[test]\nfn test_token_reserves_operations() {\n    let reserves1 = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let reserves2 = TokenReserves::new(dec!(500.0), dec!(1000.0));\n\n    assert_eq!(reserves1.token0, dec!(1000.0));\n    assert_eq!(reserves1.token1, dec!(2000.0));\n    assert_ne!(reserves1, reserves2);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","arbitrage_tests.rs"],"content":"use quant_trading_system::domain::{amm_pool::*, arbitrage::*, events::*, order_book::*, types::*};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\n\n#[test]\nfn test_arbitrage_detector_creation() {\n    let _detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    // Test with custom parameters\n    let _custom_detector = ArbitrageDetector::with_params(50, 200, dec!(1.0));\n\n    // Should create successfully without panicking\n}\n\n#[test]\nfn test_arbitrage_opportunity_creation() {\n    let buy_venue = Venue::AMM(PoolAddress(\"0x123\".to_string()));\n    let sell_venue = Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()));\n    let buy_price = Price(dec!(2400.0));\n    let sell_price = Price(dec!(2450.0));\n    let max_quantity = Quantity(dec!(10.0));\n\n    let opportunity = ArbitrageOpportunity::new(\n        buy_venue.clone(),\n        sell_venue.clone(),\n        buy_price,\n        sell_price,\n        max_quantity,\n    );\n\n    assert_eq!(opportunity.buy_venue, buy_venue);\n    assert_eq!(opportunity.sell_venue, sell_venue);\n    assert_eq!(opportunity.buy_price, buy_price);\n    assert_eq!(opportunity.sell_price, sell_price);\n    assert_eq!(opportunity.max_quantity, max_quantity);\n\n    // Check profit calculation\n    let expected_profit_percent = (dec!(50.0) / dec!(2400.0)) * dec!(100);\n    assert!((opportunity.profit_percent - expected_profit_percent).abs() \u003c dec!(0.01));\n}\n\n#[test]\nfn test_no_arbitrage_when_prices_equal() {\n    let detector = ArbitrageDetector::new(10);\n\n    // Create order book with equal prices\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Create AMM pool with similar price\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool =\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n    let result = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n    assert!(result.is_none()); // No arbitrage opportunity\n}\n\n#[test]\nfn test_arbitrage_amm_to_orderbook() {\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    // Create order book with higher bid\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2450.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2451.0)), Quantity(dec!(10.0)));\n\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Create AMM pool with lower price\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool =\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n    let result = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n    assert!(result.is_some());\n\n    let opportunity = result.unwrap();\n    match opportunity.buy_venue {\n        Venue::AMM(_) =\u003e {} // AMM venue displays correctly\n        _ =\u003e panic!(\"Expected AMM as buy venue\"),\n    }\n    match opportunity.sell_venue {\n        Venue::OrderBook(_) =\u003e {} // OrderBook venue displays correctly\n        _ =\u003e panic!(\"Expected OrderBook as sell venue\"),\n    }\n}\n\n#[test]\nfn test_minimum_profit_threshold() {\n    let detector = ArbitrageDetector::new(500); // 5% min profit\n\n    // Create small price difference (1%)\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2424.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2425.0)), Quantity(dec!(10.0)));\n\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // AMM price lower by 1%\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool =\n        ThreadSafeAMMPool::new_v2(PoolAddress(\"0x123\".to_string()), reserves, FeeTier(30));\n\n    let result = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n    assert!(result.is_none()); // Should not detect due to minimum threshold\n}\n\n#[test]\nfn test_profit_calculation_accuracy() {\n    let buy_price = Price(dec!(2000.0));\n    let sell_price = Price(dec!(2100.0));\n    let max_quantity = Quantity(dec!(5.0));\n\n    let opportunity = ArbitrageOpportunity::new(\n        Venue::AMM(PoolAddress(\"0x123\".to_string())),\n        Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n        buy_price,\n        sell_price,\n        max_quantity,\n    );\n\n    // Profit per unit = 2100 - 2000 = 100\n    // Profit percent = (100 / 2000) * 100 = 5%\n    // Estimated profit = 100 * 5 = 500\n\n    assert_eq!(opportunity.profit_percent, dec!(5.0));\n    assert_eq!(opportunity.estimated_profit, dec!(500.0));\n}\n\n#[test]\nfn test_zero_price_handling() {\n    let opportunity = ArbitrageOpportunity::new(\n        Venue::AMM(PoolAddress(\"0x123\".to_string())),\n        Venue::OrderBook(Symbol(\"ETHUSDC\".to_string())),\n        Price::zero(),\n        Price(dec!(100.0)),\n        Quantity(dec!(1.0)),\n    );\n\n    // Should handle zero buy price gracefully\n    assert_eq!(opportunity.profit_percent, dec!(0.0));\n}\n\n#[test]\nfn test_venue_display() {\n    let amm_venue = Venue::AMM(PoolAddress(\"0xABC123\".to_string()));\n    let ob_venue = Venue::OrderBook(Symbol(\"ETHUSDC\".to_string()));\n\n    let amm_str = format!(\"{}\", amm_venue);\n    let ob_str = format!(\"{}\", ob_venue);\n\n    assert!(amm_str.contains(\"AMM\"));\n    assert!(amm_str.contains(\"0xABC123\"));\n    assert!(ob_str.contains(\"OrderBook\"));\n    assert!(ob_str.contains(\"ETHUSDC\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","concurrency_tests.rs"],"content":"use quant_trading_system::domain::{\n    amm_pool::*, events::*, market_data::*, order_book::*, types::*,\n};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\n#[test]\nfn test_concurrent_order_book_access() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let order_book_clone = order_book.clone();\n\n    // Spawn multiple threads to read from order book\n    let handles: Vec\u003c_\u003e = (0..10)\n        .map(|_| {\n            let ob = order_book_clone.clone();\n            thread::spawn(move || {\n                for _ in 0..100 {\n                    let best_bid = ob.best_bid();\n                    let best_ask = ob.best_ask();\n                    assert!(best_bid.is_some());\n                    assert!(best_ask.is_some());\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify order book is still in valid state\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n}\n\n#[test]\nfn test_concurrent_amm_pool_access() {\n    let amm_pool = ThreadSafeAMMPool::new_v2(\n        PoolAddress(\"0x123\".to_string()),\n        TokenReserves::new(dec!(1000.0), dec!(2000.0)),\n        FeeTier(30),\n    );\n\n    let pool_clone = amm_pool.clone();\n\n    // Spawn multiple threads to read from AMM pool\n    let handles: Vec\u003c_\u003e = (0..10)\n        .map(|_| {\n            let pool = pool_clone.clone();\n            thread::spawn(move || {\n                for _ in 0..100 {\n                    let mid_price = pool.implied_mid();\n                    let reserves = pool.get_reserves();\n                    let fee_tier = pool.get_fee_tier();\n\n                    assert_eq!(mid_price, Price(dec!(2.0)));\n                    assert_eq!(reserves.token0, dec!(1000.0));\n                    assert_eq!(reserves.token1, dec!(2000.0));\n                    assert_eq!(fee_tier, FeeTier(30));\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_concurrent_market_data_manager_access() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Add initial data\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n    manager.process_event(snapshot_event).unwrap();\n\n    let manager_clone = Arc::clone(\u0026manager);\n\n    // Spawn multiple threads to access market data\n    let handles: Vec\u003c_\u003e = (0..5)\n        .map(|_| {\n            let mgr = Arc::clone(\u0026manager_clone);\n            let sym = symbol.clone();\n            thread::spawn(move || {\n                for _ in 0..50 {\n                    if let Some(order_book) = mgr.get_orderbook(\u0026sym) {\n                        let best_bid = order_book.best_bid();\n                        let best_ask = order_book.best_ask();\n                        assert!(best_bid.is_some());\n                        assert!(best_ask.is_some());\n                    }\n\n                    let symbols = mgr.get_orderbook_symbols();\n                    assert!(!symbols.is_empty());\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_concurrent_order_book_updates() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let order_book_clone = order_book.clone();\n\n    // Spawn threads that apply deltas concurrently\n    let handles: Vec\u003c_\u003e = (0..5)\n        .map(|i| {\n            let ob = order_book_clone.clone();\n            thread::spawn(move || {\n                for j in 0..20 {\n                    let seq = 1001 + (i * 20) + j;\n                    let mut updates = Vec::new();\n                    updates.push(PriceLevelUpdate::new(\n                        Side::Bid,\n                        Price(dec!(2399.0) + rust_decimal::Decimal::from(j)),\n                        Quantity(dec!(1.0)),\n                        UpdateAction::Update,\n                    ));\n\n                    let delta = OrderBookDelta::with_updates(\n                        SequenceNumber(seq as u64),\n                        chrono::Utc::now(),\n                        updates,\n                    );\n\n                    let _ = ob.apply_delta(\u0026delta);\n                    thread::sleep(Duration::from_micros(10));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify order book is still in valid state\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n}\n\n#[test]\nfn test_concurrent_amm_pool_updates() {\n    let amm_pool = ThreadSafeAMMPool::new_v2(\n        PoolAddress(\"0x123\".to_string()),\n        TokenReserves::new(dec!(1000.0), dec!(2000.0)),\n        FeeTier(30),\n    );\n\n    let pool_clone = amm_pool.clone();\n\n    // Spawn threads that update pool state concurrently\n    let handles: Vec\u003c_\u003e = (0..3)\n        .map(|i| {\n            let pool = pool_clone.clone();\n            thread::spawn(move || {\n                for j in 0..10 {\n                    let new_reserves = TokenReserves::new(\n                        dec!(1000.0) + rust_decimal::Decimal::from(i * 10 + j),\n                        dec!(2000.0) + rust_decimal::Decimal::from(i * 20 + j * 2),\n                    );\n\n                    let update =\n                        AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n                    let _ = pool.update_state(update);\n                    thread::sleep(Duration::from_micros(10));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // Verify pool is still in valid state\n    let final_reserves = amm_pool.get_reserves();\n    assert!(final_reserves.token0 \u003e dec!(0.0));\n    assert!(final_reserves.token1 \u003e dec!(0.0));\n}\n\n#[test]\nfn test_concurrent_price_impact_calculations() {\n    let amm_pool = ThreadSafeAMMPool::new_v2(\n        PoolAddress(\"0x123\".to_string()),\n        TokenReserves::new(dec!(10000.0), dec!(20000.0)),\n        FeeTier(30),\n    );\n\n    let pool_clone = amm_pool.clone();\n\n    // Spawn multiple threads calculating price impact\n    let handles: Vec\u003c_\u003e = (0..8)\n        .map(|i| {\n            let pool = pool_clone.clone();\n            thread::spawn(move || {\n                for j in 0..25 {\n                    let trade_amount = dec!(1.0) + rust_decimal::Decimal::from(i + j);\n                    let result = pool.calculate_price_impact(TokenIndex::Token0, trade_amount);\n\n                    assert!(result.is_ok());\n                    let impact = result.unwrap();\n                    assert!(impact.output_amount \u003e dec!(0.0));\n                    assert!(impact.price_impact_percent \u003e= dec!(0.0));\n\n                    thread::sleep(Duration::from_micros(1));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_concurrent_metrics_collection() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Add some initial data\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n    manager.process_event(snapshot_event).unwrap();\n\n    let manager_clone = Arc::clone(\u0026manager);\n\n    // Spawn multiple threads collecting metrics\n    let handles: Vec\u003c_\u003e = (0..4)\n        .map(|_| {\n            let mgr = Arc::clone(\u0026manager_clone);\n            thread::spawn(move || {\n                for _ in 0..50 {\n                    let metrics = mgr.get_market_metrics();\n                    assert!(!metrics.orderbook_metrics.is_empty());\n\n                    thread::sleep(Duration::from_micros(5));\n                }\n            })\n        })\n        .collect();\n\n    // Wait for all threads to complete\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","integration_tests.rs"],"content":"use quant_trading_system::domain::{\n    amm_pool::*, arbitrage::*, events::*, market_data::*, types::*,\n};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\n\n#[tokio::test]\nasync fn test_full_market_data_processing_pipeline() {\n    let manager = Arc::new(MarketDataManager::new());\n    let (event_tx, mut event_rx) = mpsc::unbounded_channel();\n\n    // We'll process events directly without the ingester for this test\n\n    // Send order book snapshot\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n\n    event_tx.send(snapshot_event).unwrap();\n\n    // Process the event\n    if let Some(event) = event_rx.recv().await {\n        manager.process_event(event).unwrap();\n    }\n\n    // Verify order book was created and populated\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Send a delta update\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2399.5)),\n        Quantity(dec!(5.0)),\n        UpdateAction::Update,\n    )];\n\n    let delta_event = MarketEvent::OrderBookDelta(\n        symbol.clone(),\n        OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates),\n    );\n\n    event_tx.send(delta_event).unwrap();\n\n    // Process the delta\n    if let Some(event) = event_rx.recv().await {\n        manager.process_event(event).unwrap();\n    }\n\n    // Verify the update was applied\n    let updated_order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(updated_order_book.best_bid().is_some());\n    // Best bid should still be 2400.0 since 2399.5 is lower\n    assert_eq!(updated_order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n}\n\n#[tokio::test]\nasync fn test_arbitrage_detection_integration() {\n    let manager = Arc::new(MarketDataManager::new());\n    let detector = ArbitrageDetector::new(10); // 0.1% min profit\n\n    // Set up order book with higher prices\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2450.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2451.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n\n    manager.process_event(snapshot_event).unwrap();\n\n    // Set up AMM pool with lower price\n    let pool_address = PoolAddress(\"0x123\".to_string());\n    let reserves = TokenReserves::new(dec!(1000.0), dec!(2400000.0)); // Price = 2400\n    let amm_pool = ThreadSafeAMMPool::new_v2(pool_address.clone(), reserves, FeeTier(30));\n\n    manager.add_amm_pool(pool_address.clone(), amm_pool.clone());\n\n    // Check for arbitrage opportunity\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    let opportunity = detector.check_arbitrage(\u0026order_book, \u0026amm_pool);\n\n    assert!(opportunity.is_some());\n    let opp = opportunity.unwrap();\n    assert!(opp.estimated_profit \u003e dec!(0.0));\n    // Check that we're buying from AMM (lower price) and selling to OrderBook (higher price)\n    assert_eq!(opp.buy_venue, Venue::AMM(pool_address));\n    assert_eq!(opp.sell_venue, Venue::OrderBook(symbol));\n}\n\n#[tokio::test]\nasync fn test_concurrent_event_processing() {\n    let manager = Arc::new(MarketDataManager::new());\n    let (event_tx, mut event_rx) = mpsc::unbounded_channel();\n\n    // Spawn a task to process events\n    let manager_clone = Arc::clone(\u0026manager);\n    let processing_task = tokio::spawn(async move {\n        let mut processed_count = 0;\n        while let Some(event) = event_rx.recv().await {\n            if manager_clone.process_event(event).is_ok() {\n                processed_count += 1;\n            }\n            if processed_count \u003e= 10 {\n                break;\n            }\n        }\n        processed_count\n    });\n\n    // Send multiple events concurrently\n    for i in 0..10 {\n        let symbol = Symbol(format!(\"PAIR{}\", i));\n        let mut bids = BTreeMap::new();\n        let mut asks = BTreeMap::new();\n        bids.insert(\n            Price(dec!(100.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n        asks.insert(\n            Price(dec!(101.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n\n        let snapshot_event = MarketEvent::OrderBookSnapshot(\n            symbol,\n            OrderBookSnapshot::with_levels(\n                SequenceNumber(1000 + i as u64),\n                chrono::Utc::now(),\n                bids,\n                asks,\n            ),\n        );\n\n        event_tx.send(snapshot_event).unwrap();\n    }\n\n    // Wait for processing to complete\n    let processed_count = processing_task.await.unwrap();\n    assert_eq!(processed_count, 10);\n\n    // Verify all symbols were processed\n    let symbols = manager.get_orderbook_symbols();\n    assert_eq!(symbols.len(), 10);\n}\n\n#[tokio::test]\nasync fn test_market_metrics_integration() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Add multiple order books\n    for i in 0..5 {\n        let symbol = Symbol(format!(\"PAIR{}\", i));\n        let mut bids = BTreeMap::new();\n        let mut asks = BTreeMap::new();\n        bids.insert(\n            Price(dec!(100.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n        asks.insert(\n            Price(dec!(101.0) + rust_decimal::Decimal::from(i)),\n            Quantity(dec!(10.0)),\n        );\n\n        let snapshot_event = MarketEvent::OrderBookSnapshot(\n            symbol,\n            OrderBookSnapshot::with_levels(\n                SequenceNumber(1000 + i as u64),\n                chrono::Utc::now(),\n                bids,\n                asks,\n            ),\n        );\n\n        manager.process_event(snapshot_event).unwrap();\n    }\n\n    // Add AMM pools\n    for i in 0..3 {\n        let pool_address = PoolAddress(format!(\"0x{:x}\", i));\n        let reserves = TokenReserves::new(\n            dec!(1000.0) + rust_decimal::Decimal::from(i * 100),\n            dec!(2000.0) + rust_decimal::Decimal::from(i * 200),\n        );\n        let amm_pool = ThreadSafeAMMPool::new_v2(pool_address.clone(), reserves, FeeTier(30));\n\n        manager.add_amm_pool(pool_address, amm_pool);\n    }\n\n    // Get metrics\n    let metrics = manager.get_market_metrics();\n\n    assert_eq!(metrics.orderbook_metrics.len(), 5);\n    assert_eq!(metrics.amm_metrics.len(), 3);\n\n    // Verify metrics contain expected data\n    for (symbol, ob_metrics) in \u0026metrics.orderbook_metrics {\n        assert!(ob_metrics.best_bid \u003e Price::zero());\n        assert!(ob_metrics.best_ask \u003e Price::zero());\n        assert!(ob_metrics.spread \u003e dec!(0.0));\n        assert!(symbol.0.starts_with(\"PAIR\"));\n    }\n\n    for (address, amm_metrics) in \u0026metrics.amm_metrics {\n        assert!(amm_metrics.implied_mid \u003e Price::zero());\n        assert!(amm_metrics.reserves.token0 \u003e dec!(0.0));\n        assert!(amm_metrics.reserves.token1 \u003e dec!(0.0));\n        assert!(address.0.starts_with(\"0x\"));\n    }\n}\n\n#[tokio::test]\nasync fn test_error_handling_and_recovery() {\n    let manager = Arc::new(MarketDataManager::new());\n\n    // Test processing invalid sequence number\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    // Send initial snapshot\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(\n            SequenceNumber(1000),\n            chrono::Utc::now(),\n            bids.clone(),\n            asks.clone(),\n        ),\n    );\n\n    manager.process_event(snapshot_event).unwrap();\n\n    // Try to send a snapshot with lower sequence number (should fail)\n    let invalid_snapshot = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(\n            SequenceNumber(999), // Lower than previous\n            chrono::Utc::now(),\n            bids,\n            asks,\n        ),\n    );\n\n    let result = manager.process_event(invalid_snapshot);\n    assert!(result.is_err());\n\n    // Verify the original order book is still intact\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_some());\n}\n\n#[tokio::test]\nasync fn test_high_frequency_updates() {\n    let manager = Arc::new(MarketDataManager::new());\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n\n    // Initialize with snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot_event = MarketEvent::OrderBookSnapshot(\n        symbol.clone(),\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks),\n    );\n\n    manager.process_event(snapshot_event).unwrap();\n\n    // Send rapid delta updates\n    for i in 1..=100 {\n        let updates = vec![PriceLevelUpdate::new(\n            Side::Bid,\n            Price(dec!(2400.0) + rust_decimal::Decimal::from(i) / dec!(100.0)),\n            Quantity(dec!(1.0)),\n            UpdateAction::Update,\n        )];\n\n        let delta_event = MarketEvent::OrderBookDelta(\n            symbol.clone(),\n            OrderBookDelta::with_updates(SequenceNumber(1000 + i), chrono::Utc::now(), updates),\n        );\n\n        let result = manager.process_event(delta_event);\n        assert!(result.is_ok());\n    }\n\n    // Verify final state\n    let order_book = manager.get_orderbook(\u0026symbol).unwrap();\n    assert!(order_book.best_bid().is_some());\n    let best_bid = order_book.best_bid().unwrap();\n    // Should be the highest bid price from our updates (2400.0 + 1.0 = 2401.0)\n    assert!(best_bid.0 \u003e= dec!(2401.0));\n}\n\n#[tokio::test]\nasync fn test_amm_pool_state_updates() {\n    let manager = Arc::new(MarketDataManager::new());\n    let pool_address = PoolAddress(\"0xabc123\".to_string());\n\n    // Create initial AMM pool\n    let initial_reserves = TokenReserves::new(dec!(1000.0), dec!(2000.0));\n    let amm_pool = ThreadSafeAMMPool::new_v2(pool_address.clone(), initial_reserves, FeeTier(30));\n\n    manager.add_amm_pool(pool_address.clone(), amm_pool.clone());\n\n    // Verify initial state\n    let initial_mid = amm_pool.implied_mid();\n    assert_eq!(initial_mid, Price(dec!(2.0)));\n\n    // Update pool state\n    let new_reserves = TokenReserves::new(dec!(1100.0), dec!(2100.0));\n    let update = AMMPoolUpdate::new(chrono::Utc::now(), new_reserves, None, FeeTier(30));\n\n    amm_pool.update_state(update).unwrap();\n\n    // Verify updated state\n    let updated_reserves = amm_pool.get_reserves();\n    assert_eq!(updated_reserves.token0, dec!(1100.0));\n    assert_eq!(updated_reserves.token1, dec!(2100.0));\n\n    let updated_mid = amm_pool.implied_mid();\n    assert!(updated_mid.0 \u003e dec!(1.9) \u0026\u0026 updated_mid.0 \u003c dec!(2.0));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","joaquin","Repos","Assignments","Forgd","quant-trading-system","tests","orderbook_tests.rs"],"content":"use quant_trading_system::domain::{events::*, order_book::*, types::*};\nuse rust_decimal_macros::dec;\nuse std::collections::BTreeMap;\n\n#[test]\nfn test_order_book_creation() {\n    let symbol = Symbol(\"ETHUSDC\".to_string());\n    let order_book = ThreadSafeOrderBook::new(symbol.clone());\n\n    assert!(order_book.best_bid().is_none());\n    assert!(order_book.best_ask().is_none());\n    assert_eq!(order_book.symbol(), symbol);\n}\n\n#[test]\nfn test_order_book_snapshot_application() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    bids.insert(Price(dec!(2399.0)), Quantity(dec!(5.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(8.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(12.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n\n    let result = order_book.apply_snapshot(snapshot);\n    assert!(result.is_ok());\n\n    // Verify best prices\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Verify bid/ask quantities\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity(dec!(10.0))\n    );\n    assert_eq!(\n        order_book.quantity_at_price(Side::Ask, Price(dec!(2401.0))),\n        Quantity(dec!(8.0))\n    );\n}\n\n#[test]\nfn test_order_book_delta_updates() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Apply delta update - add new bid level\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2399.5)),\n        Quantity(dec!(5.0)),\n        UpdateAction::Update,\n    )];\n\n    let delta = OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates);\n\n    let result = order_book.apply_delta(\u0026delta);\n    assert!(result.is_ok());\n\n    // Verify the new bid level was added\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2399.5))),\n        Quantity(dec!(5.0))\n    );\n    // Best bid should still be 2400.0\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n}\n\n#[test]\nfn test_order_book_price_level_deletion() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot with multiple levels\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    bids.insert(Price(dec!(2399.0)), Quantity(dec!(5.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(8.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(12.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Delete the best bid\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2400.0)),\n        Quantity::zero(),\n        UpdateAction::Delete,\n    )];\n\n    let delta = OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates);\n\n    order_book.apply_delta(\u0026delta).unwrap();\n\n    // Best bid should now be 2399.0\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2399.0)));\n    // The deleted price level should not exist\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity::zero()\n    );\n}\n\n#[test]\nfn test_order_book_spread_calculation() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.5)), Quantity(dec!(8.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let spread = order_book.spread();\n    assert!(spread.is_some());\n    assert_eq!(spread.unwrap(), Price(dec!(1.5))); // 2401.5 - 2400.0\n}\n\n#[test]\nfn test_order_book_mid_price_calculation() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(8.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    let mid_price = order_book.mid_price();\n    assert!(mid_price.is_some());\n    assert_eq!(mid_price.unwrap(), Price(dec!(2401.0))); // (2400 + 2402) / 2\n}\n\n#[test]\nfn test_order_book_sequence_validation() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot = OrderBookSnapshot::with_levels(\n        SequenceNumber(1000),\n        chrono::Utc::now(),\n        bids.clone(),\n        asks.clone(),\n    );\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Try to apply snapshot with lower sequence number (should fail)\n    let invalid_snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(999), chrono::Utc::now(), bids, asks);\n\n    let result = order_book.apply_snapshot(invalid_snapshot);\n    assert!(result.is_err());\n\n    // Try to apply delta with non-sequential sequence number (should be skipped for idempotent replay)\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2399.0)),\n        Quantity(dec!(5.0)),\n        UpdateAction::Update,\n    )];\n\n    let old_delta = OrderBookDelta::with_updates(\n        SequenceNumber(999), // Lower than current - should be skipped\n        chrono::Utc::now(),\n        updates.clone(),\n    );\n\n    let result = order_book.apply_delta(\u0026old_delta);\n    assert!(result.is_ok()); // Should succeed but be skipped\n\n    // Try to apply delta with gap in sequence number (should fail)\n    let gap_delta = OrderBookDelta::with_updates(\n        SequenceNumber(1002), // Gap in sequence - should fail\n        chrono::Utc::now(),\n        updates,\n    );\n\n    let result = order_book.apply_delta(\u0026gap_delta);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_order_book_empty_state() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Test empty order book behavior\n    assert!(order_book.best_bid().is_none());\n    assert!(order_book.best_ask().is_none());\n    assert!(order_book.mid_price().is_none());\n    assert!(order_book.spread().is_none());\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity::zero()\n    );\n    assert_eq!(\n        order_book.quantity_at_price(Side::Ask, Price(dec!(2401.0))),\n        Quantity::zero()\n    );\n}\n\n#[test]\nfn test_order_book_partial_state() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply snapshot with only bids\n    let mut bids = BTreeMap::new();\n    let asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Should have bid but no ask\n    assert!(order_book.best_bid().is_some());\n    assert!(order_book.best_ask().is_none());\n    assert!(order_book.mid_price().is_none());\n    assert!(order_book.spread().is_none());\n}\n\n#[test]\nfn test_order_book_price_level_updates() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Apply initial snapshot\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Update existing bid quantity\n    let updates = vec![PriceLevelUpdate::new(\n        Side::Bid,\n        Price(dec!(2400.0)),\n        Quantity(dec!(15.0)), // Increased quantity\n        UpdateAction::Update,\n    )];\n\n    let delta = OrderBookDelta::with_updates(SequenceNumber(1001), chrono::Utc::now(), updates);\n\n    order_book.apply_delta(\u0026delta).unwrap();\n\n    // Verify quantity was updated\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2400.0))),\n        Quantity(dec!(15.0))\n    );\n}\n\n#[test]\nfn test_order_book_multiple_price_levels() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Create order book with multiple price levels\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n\n    // Multiple bid levels (descending prices)\n    bids.insert(Price(dec!(2400.0)), Quantity(dec!(10.0)));\n    bids.insert(Price(dec!(2399.5)), Quantity(dec!(8.0)));\n    bids.insert(Price(dec!(2399.0)), Quantity(dec!(5.0)));\n    bids.insert(Price(dec!(2398.5)), Quantity(dec!(3.0)));\n\n    // Multiple ask levels (ascending prices)\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(7.0)));\n    asks.insert(Price(dec!(2401.5)), Quantity(dec!(9.0)));\n    asks.insert(Price(dec!(2402.0)), Quantity(dec!(12.0)));\n    asks.insert(Price(dec!(2402.5)), Quantity(dec!(15.0)));\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n    order_book.apply_snapshot(snapshot).unwrap();\n\n    // Verify best prices (highest bid, lowest ask)\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2400.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Verify all levels exist\n    assert_eq!(\n        order_book.quantity_at_price(Side::Bid, Price(dec!(2398.5))),\n        Quantity(dec!(3.0))\n    );\n    assert_eq!(\n        order_book.quantity_at_price(Side::Ask, Price(dec!(2402.5))),\n        Quantity(dec!(15.0))\n    );\n}\n\n#[test]\nfn test_order_book_cross_spread_handling() {\n    let order_book = ThreadSafeOrderBook::new(Symbol(\"ETHUSDC\".to_string()));\n\n    // Create crossed order book (bid \u003e ask) - this is an invalid state but should be handled\n    let mut bids = BTreeMap::new();\n    let mut asks = BTreeMap::new();\n    bids.insert(Price(dec!(2402.0)), Quantity(dec!(10.0))); // Higher than ask\n    asks.insert(Price(dec!(2401.0)), Quantity(dec!(10.0))); // Lower than bid\n\n    let snapshot =\n        OrderBookSnapshot::with_levels(SequenceNumber(1000), chrono::Utc::now(), bids, asks);\n\n    // Should still apply the snapshot (system doesn't validate cross)\n    let result = order_book.apply_snapshot(snapshot);\n    assert!(result.is_ok());\n\n    // Verify the crossed state\n    assert_eq!(order_book.best_bid().unwrap(), Price(dec!(2402.0)));\n    assert_eq!(order_book.best_ask().unwrap(), Price(dec!(2401.0)));\n\n    // Spread should be negative in this case\n    let spread = order_book.spread().unwrap();\n    assert!(spread.0 \u003c dec!(0.0));\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>